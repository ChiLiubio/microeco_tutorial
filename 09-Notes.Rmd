# Notes
We show some other important points here.

## clone() function
R6 class has a special copy mechanism which is different from S3 and S4.
**If you want to copy an object completely, you should use the function clone() instead of direct assignment.**

```{r, echo = TRUE}
# use clone to copy completely
t1 <- clone(dataset)
t2 <- clone(t1)
t2$sample_table <- NULL
identical(t2, t1)
```

```{r, echo = TRUE}
# this operation is usually unuseful, because changing t2 will also affect t1
t2 <- t1
t2$sample_table <- NULL
identical(t2, t1)
```


## save() function

As an R6 object is an encapsulated environment, there is also another very useful advantage, i.e. the data repeatability and communication.
By applying R6 classes, the analyzed data in 'R Environment' can have minimum numbers of the intermediate files and can reduce memory spending.
It is also very convenient to save the analyzed data (i.e. object) to local computer with save() function for back-up and communication with others.
This is also the recommended way to send data for testing in 'Github Issues'.

```{r, echo = TRUE, eval = FALSE}
# save 'dataset' to local computer
save(dataset, file = "dataset.RData")
# dataset.RData can be compressed into zip format for the upload in 'Github Issues'
# load the data by others in their R project
load("dataset.RData")
```

The saved object is only related with the package version when you save it and has no matter with the updated package when you load it again.
So it is repeatable.


## subset of samples
We donnot provide the special function to filter samples in microtable class, as we think it is redundant.
**We recommend user to directly manipulate the sample_table in microtable object.**
For example, if we want to analyze samples from 'CW' and 'IW', respectively, we can operate like this: 

```{r, echo = TRUE}
# remember first clone the full dataset
group1 <- clone(dataset)
group1$sample_table <- subset(group1$sample_table, Group == "CW")
# this is necessary to make files in group1 corresponding
group1$tidy_dataset()
group1
# similar with obove operation
group2 <- clone(dataset)
group2$sample_table <- subset(group2$sample_table, Group == "IW")
group2$tidy_dataset()
# now we get two microtable objects: group1 for CW and group2 for IW
```

## change object
All the classes are set public, meaning that you can **change, add or remove the objects stored in them as you want**.

```{r, echo = TRUE}
# add a matrix you think useful
dataset$my_matrix <- matrix(1, nrow = 4, ncol = 4)
# change the information
dataset$sample_table %<>% .[, -2]
```

## group order
If you want to reorder the groups, **assign the factors may be the most simplest way.**

```{r, echo = TRUE}
data(dataset)
t1 <- trans_beta$new(dataset = dataset, group = "Group", measure = "bray")
t1$cal_ordination(ordination = "PCoA")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_group_ellipse = TRUE)
```

Then we assign factors to the 'Group' in sample_table of dataset.
We can find the changed group order in the legend and colors in the plot.

```{r, echo = TRUE}
dataset$sample_table$Group %<>% factor(., levels = c("IW", "TW", "CW"))
str(dataset$sample_table)
t1 <- trans_beta$new(dataset = dataset, group = "Group", measure = "bray")
t1$cal_ordination(ordination = "PCoA")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_group_ellipse = TRUE)
```


## add layers to plot
Most of the plots are generated by applying the ggplot2 package.
The important parameters in the plotting functions are configured according to our experience.
If the inner parameters can not enough, the user can add the layers to the plot like the following operation or
make the plot using the data (generally data.frame class) stored in the object.


```{r, echo = TRUE, eval = FALSE}
# The groupmean parameter can be used to obtain the group-mean barplot.
t1 <- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 10, groupmean = "Group")
g1 <- t1$plot_bar(others_color = "grey70", legend_text_italic = FALSE)
g1 + theme_classic() + theme(axis.title.y = element_text(size = 18))
```

```{r, out.width = "400px", fig.align="center", echo = FALSE}
knitr::include_graphics("Images/plot_bar_mean_classic.png")
```

## colors for many groups

In general, the color palette in the ploting function is enough for the settings of groups or samples,
such as RColorBrewer::brewer.pal(12, "Paired").
If the user has too many groups (e.g. 20), the color_palette_20 can be used. It has 20 colors with paired combinations.
If this is still not enough, the randomcoloR package can be used for generating more colors.

```{r, echo = TRUE, eval = TRUE}
color_palette_20
```

```{r, echo = TRUE, eval = FALSE}
barplot(1:20, col = color_palette_20)
```

## customized data input

From v0.7.0, trans_alpha, trans_env and trans_venn classes can accept NULL dataset input for some customized usage of some functions in those classes.

```{r, echo = TRUE, eval = FALSE}
t1 <- trans_env$new()
t1 <- trans_alpha$new(dataset = NULL, group = NULL)
```







