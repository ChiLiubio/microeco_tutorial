[["index.html", "Tutorial for R microeco package (v0.5.0) Chapter 1 Background", " Tutorial for R microeco package (v0.5.0) Chi Liu, Umer Zeeshan Ijaz, Felipe Mansoldo, Chenhao Li, Yang Cao, Jarrod J. Scott, Yaoming Cui, Alane B. Vermelho, Xiangzhen Li, Minjie Yao 2021-10-23 Chapter 1 Background R language (R Core Team 2016) and its packages ecosystem are wonderful tools for data analysis. In microbial community ecology field, many packages can be used for the data analysis, such as vegan(Oksanen et al. 2019), ape(Paradis and Schliep 2018) and picante(Kembel et al. 2010). However, with the development of the high-throughput sequencing techniques, the increasing data amount and complexity make the data mining a challenge. There have been some R packages created for the statistics and visualization in microbial community ecology, such as phyloseq(Mcmurdie and Holmes 2013), microbiome (https://github.com/microbiome/microbiome), microbiomeSeq (http://www.github.com/umerijaz/microbiomeSeq), ampvis2 (https://madsalbertsen.github.io/ampvis2/reference/index.html), MicrobiomeR(https://github.com/vallenderlab/MicrobiomeR), theseus(Price et al. 2018), rANOMALY(Theil and Rifa 2021), MicrobiomeExplorer(Reeder et al. 2021), tidyMicro(Carpenter et al. 2021) and so on. However, we lack a flexible, comprehensive and modularized R package to analyze and manage the data. So we create the microeco R package(Liu et al. 2021) for this goal (https://github.com/ChiLiubio/microeco). Besides, we also develop the file2meco package (https://github.com/ChiLiubio/file2meco) for the data input from other tools easily and mecodev package (https://github.com/ChiLiubio/mecodev) for some extending approaches in the area. References "],["intro.html", "Chapter 2 Introduction 2.1 R6 Class 2.2 Help 2.3 Dependence 2.4 Plotting", " Chapter 2 Introduction The microeco package has several advantages compared to other packages in R. The main goal of developing this package is to help users analyse communtiy ecology data fast. So a series of commonly-used approaches are implemented. Some new methods are in active development. To facilitate the data mining, the whole structure of microeco package are modularized to make users conveniently remember, search and use. It is notable that, beside the demonstration in the tutorial, users can also save the intermediate files in each object and apply those files to other tools according to the format requirement. Main files stored in the objects of microeco package is the commonly used data.frame format. So the intermediate and result files are easily saved, modified and used for other tools in microbial ecology. 2.1 R6 Class All the classes in microeco package depend on the R6 class (Chang 2020). R6 uses the encapsulated object-oriented programming paradigm, which means that R6 is a profoundly different OO system from S3 and S4 because it is built on encapsulated objects, rather than generic functions. If you are interested in the class feature, read more from ‘Advanced R’ book. A generic is a regular function, so it lives in the global namespace. An R6 method belongs to an object so it lives in a local namespace. This influences how we think about naming. The methods belong to objects, not generics, and you call them like object$method(). R6’s reference semantics allow methods to simultaneously return a value and modify an object. Every R6 object has an S3 class that reflects its hierarchy of R6 class. 2.2 Help The use of help documents in the microeco package may be a little different from other packages we often used. If you wish to see one of help documents of functions, you should search the name of the class (not the name of the function) and click the link of the function. # first install microeco, see https://github.com/ChiLiubio/microeco # load package microeco library(microeco) # this can show all the functions and the detailed descriptions in the microtable class ?microtable 2.3 Dependence 2.3.1 Important packages To keep the start and use of microeco package simplified, the installation of microeco only depend on several packages, which are compulsory-installed from CRAN and important in the data analysis. So the question is that you may encounter an error when using a class or function that invoke an additional package like this: library(microeco) data(dataset) t1 &lt;- trans_network$new(dataset = dataset, cal_cor = NA, taxa_level = &quot;OTU&quot;, filter_thres = 0.0005) t1$cal_network(network_method = &quot;SpiecEasi&quot;) Error in t1$cal_network(network_method = &quot;SpiecEasi&quot;): igraph package not installed ... The reason is that network construction require igraph package. We donot put the igraph and some other packages (e.g. SpiecEasi in github) on the “Imports” part of microeco package. The solutions: install the package when encounter such an error. Actually, it’s very easy to install the packages from CRAN or bioconductor. Just try it. install the packages in advance. We recommend this solution if you are interest in most of the methods in the microeco package and want to repeat the analysis in tutorial. We show several packages that are published in CRAN and not installed automatically. Package where description reshape2 microtable class data transformation MASS trans_diff class linear discriminant analysis GUniFrac cal_betadiv() UniFrac distance matrix ggpubr plot_alpha() some plotting functions randomForest trans_diff class random forest analysis ggdendro plot_clustering() plotting clustering dendrogram ggrepel trans_rda class reduce the text overlap in the plot agricolae cal_diff() multiple comparisons in anova gridExtra trans_diff class merge plots picante cal_alphadiv() Faith’s phylogenetic alpha diversity pheatmap plot_corr(pheatmap = TRUE) correlation heatmap with clustering dendrogram tidytree trans_diff class plot the taxonomic tree igraph trans_network class network related operations rgexf save_network() save network with gexf style ggalluvial plot_bar(use_alluvium = TRUE) alluvial plot Then, if you want to install these packages or some of them, you can do like this: # If a package is not installed, it will be installed from CRAN. # First select the packages of interest packages &lt;- c(&quot;reshape2&quot;, &quot;MASS&quot;, &quot;GUniFrac&quot;, &quot;ggpubr&quot;, &quot;randomForest&quot;, &quot;ggdendro&quot;, &quot;ggrepel&quot;, &quot;agricolae&quot;, &quot;gridExtra&quot;, &quot;picante&quot;, &quot;pheatmap&quot;, &quot;igraph&quot;, &quot;rgexf&quot;, &quot;ggalluvial&quot;) # Now check or install lapply(packages, function(x) { if(!require(x, character.only = TRUE)) { install.packages(x, dependencies = TRUE) }}) There are also some packages that are useful in some functions. These packages may be R packages published in github or bioconductor, or packages written by other languages. 2.3.2 ggtree Plotting the cladogram from the LEfSe result requires the ggtree package in bioconductor (https://bioconductor.org/packages/release/bioc/html/ggtree.html). if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;ggtree&quot;) 2.3.3 SpiecEasi The R package SpiecEasi can be used for the network construction using SPIEC-EASI (SParse InversE Covariance Estimation for Ecological Association Inference) approach. The package can be installed from Github https://github.com/zdk123/SpiecEasi 2.3.4 Gephi Gephi is an excellent network visualization tool and used to open the saved network file, i.e. network.gexf in the tutorial. You can download Gephi and learn how to use it from https://gephi.org/users/download/ 2.3.5 WGCNA In the correlation-based network, when the species number is very large, the correlation algorithm in WGCNA is very fast compared to the ‘cor’ option in trans_network. install.packages(&quot;WGCNA&quot;, dependencies = TRUE) 2.3.6 Tax4Fun Tax4Fun is an R package used for the prediction of functional potential of prokaryotic communities. install Tax4Fun package install.packages(&quot;RJSONIO&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;biom_0.3.12.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;qiimer_0.9.4.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;Tax4Fun_0.3.1.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) download SILVA123 reference data from http://tax4fun.gobics.de/ unzip SILVA123.zip , move it to a place that you can remember. 2.3.7 Tax4Fun2 Tax4Fun2 is another R package for the the prediction of functional profiles and functional gene redundancies of prokaryotic communities. It has higher accuracies than PICRUSt and Tax4Fun. The Tax4Fun2 approach implemented in microeco is a little different from the original package. Using Tax4Fun2 approach require the representative fasta file. The user do not need to install Tax4Fun2 R package. The only thing need to do is to download the blast tool and Ref99NR/Ref100NR database. Downlaod blast tools from “ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+” ; e.g. ncbi-blast-****-x64-win64.tar.gz for windows system. Downlaod Ref99NR.zip from “https://cloudstor.aarnet.edu.au/plus/s/DkoZIyZpMNbrzSw/download” or Ref100NR.zip from “https://cloudstor.aarnet.edu.au/plus/s/jIByczak9ZAFUB4/download” . Uncompress all the folders. The final folders should be like these structures: blast tools: |– ncbi-blast-2.11.0+ |—- bin |—— blastn.exe |—— makeblastdb.exe |—— …… Ref99NR/Ref100NR: |– Tax4Fun2_ReferenceData_v2 |—- Ref99NR |—— otu000001.tbl.gz |—— …… |—— Ref99NR.fasta |—— Ref99NR.tre The path “ncbi-blast-2.11.0+/bin” and “Tax4Fun2_ReferenceData_v2” will be required in the trans_func$cal_tax4fun2() function. # seqinr should be installed for reading and writing fasta file install.packages(&quot;seqinr&quot;, dependencies = TRUE) # Now we show how to read the fasta file # see https://github.com/ChiLiubio/file2meco if you do not have installed file2meco rep_fasta_path &lt;- system.file(&quot;extdata&quot;, &quot;rep.fna&quot;, package=&quot;file2meco&quot;) rep_fasta &lt;- seqinr::read.fasta(rep_fasta_path) # then see the help document of microtable class about the rep_fasta in microtable$new(). 2.4 Plotting Most of the plotting in the package rely on the ggplot2 package system. We provide some parameters to change the corresponding plot. The user can also assign the output a name and use the ggplot2-style grammers to modify it. Each data table used for plotting is stored in the object and can be downloaded for the personalized analysis and plotting. Of course, the user can also directly modify the class and reload them to use. Any contribution of a modified class is also appreciated through github pushing or email (liuchi0426@126.com). References "],["basic-class.html", "Chapter 3 Basic class 3.1 microtable class", " Chapter 3 Basic class 3.1 microtable class Many tools can be used for the bioinformatic analysis, such as QIIME(Caporaso et al. 2010), usearch(https://www.drive5.com/usearch/), mothur(Schloss et al. 2009), and RDP(http://rdp.cme.msu.edu/). Although the format of results may be different from various tools, the main files can be classified into the following parts: (1) OTU or ASV table, i.e. the species-sample abundance table; (2) taxonomy table, the taxonomy assignments information table; (3) phylogenetic tree; (4) representative sequences. (5) Generally, it is useful to create a detailed sample information table to store all the sample information, including the environmental data and the missing values (NA). The microtable class is the basic class and designed to store the basic data for all the downstream analysis in the microeco package. At least, the OTU table (i.e. species-sample abundance table) should be provided to create microtable object. Thus, the microtable class can recognize the sample information table is missing and create a default sample table according to the sample names of otu_table. To make the file reading more convenient, we also build another R package file2meco (https://github.com/ChiLiubio/file2meco) to read the output files of some tools into microtable object. Currently, those tools/softwares include not only commonly-used QIIME (Caporaso et al. 2010) and QIIME2(Bolyen et al. 2019), but also some metagenomic tools, such as HUMAnN (Franzosa et al. 2018). In this tutorial, we use the data inside the package microeco to show some operations. The 16S rRNA sequencing results in the example data of the package is used to show the main part of the tutorial. This dataset is the 16S rRNA gene Miseq sequencing results of wetland soils in China published by An et al.(An et al. 2019), who surveyed soil bacterial communities in Chinese inland wetlands (IW), coastal wetland (CW) and Tibet plateau wetlands (TW) using 16S rRNA gene amplicon sequencing method. These wetlands include both saline and non-saline samples. The sample information table have 4 columns: “SampleID,” “Group,” “Type” and “Saline.” The column “SampleID” is same with the rownames. The column “Group” represents the IW, CW and TW. The column “Type” represents the sampling region: northeastern region (NE), northwest region (NW), North China area (NC), middle-lower reaches of the Yangtze River (YML), southern coastal area (SC), upper reaches of the Yangtze River (YU), Qinghai-Tibet Plateau (QTP). The column “Saline” represents the saline soils and non-saline soils. In this dataset, the environmental factor table is separated from the sample information table. Another ITS sequencing dataset is also stored in the example data of the package(Gao et al. 2019). library(microeco) # load the example data; 16S rRNA gene amplicon sequencing dataset data(sample_info_16S) data(otu_table_16S) data(taxonomy_table_16S) data(phylo_tree_16S) # load the environmental data which is detached from sample table data(env_data_16S) # use pipe operator in magrittr package library(magrittr) # set.seed is used to fix the random number generation to make the results repeatable set.seed(123) # make the plotting background same with the tutorial library(ggplot2) theme_set(theme_bw()) Make sure that the data types of sample_table, otu_table and tax_table are all data.frame as the following part shows. class(otu_table_16S) ## [1] &quot;data.frame&quot; otu_table_16S[1:5, 1:5]   S1 S2 S3 S4 S5 OTU_4272 1 0 1 1 0 OTU_236 1 4 0 2 35 OTU_399 9 2 2 4 4 OTU_1556 5 18 7 3 2 OTU_32 83 9 19 8 102 class(taxonomy_table_16S) ## [1] &quot;data.frame&quot; taxonomy_table_16S[1:5, 1:3]   Kingdom Phylum Class OTU_4272 k__Bacteria p__Firmicutes c__Bacilli OTU_236 k__Bacteria p__Chloroflexi c__ OTU_399 k__Bacteria p__Proteobacteria c__Betaproteobacteria OTU_1556 k__Bacteria p__Acidobacteria c__Acidobacteria OTU_32 k__Archaea p__Miscellaneous Crenarchaeotic Group c__ Sometimes, your taxonomic table may have some chaotic information, such NA, unidentified and unknown. These information can influence the following taxonomic abundance calculation. So it is necessary to clean this file using the following code. Another important part of this operation is to unify the taxonomic prefix, e.g. transforming D_1__ to p__ for phylum level. # make the taxonomic information unified, important taxonomy_table_16S %&lt;&gt;% tidy_taxonomy The rownames of sample_table in microtable object (i.e. sample names) are used for selecting samples/groups in all the related operations in the package. Before you create microtable object, make sure that the rownames of sample information table are the correct sample names. class(sample_info_16S) ## [1] &quot;data.frame&quot; sample_info_16S[1:5, ]   SampleID Group Type Saline S1 S1 IW NE Non-saline soil S2 S2 IW NE Non-saline soil S3 S3 IW NE Non-saline soil S4 S4 IW NE Non-saline soil S5 S5 IW NE Non-saline soil In this example, the environmental data is stored in the env_data_16S alone. The user can also directly integrate those data into the sample information table. class(env_data_16S) ## [1] &quot;data.frame&quot;   Latitude Longitude Altitude Temperature Precipitation S1 52.96 122.6 432 -4.2 445 S2 52.95 122.6 445 -4.3 449 S3 52.95 122.6 430 -4.3 449 S4 52.95 122.6 430 -4.3 449 S5 52.95 122.6 429 -4.3 449 class(phylo_tree_16S) ## [1] &quot;phylo&quot; Then, we create an object of microtable class. This operation is very similar with the package phyloseq(Mcmurdie and Holmes 2013), but microeco is more brief and simpler. The otu_table in the microtable class must be the species-sample format: rownames must be OTU names, colnames must be sample names. The required sample names must be same in rownames of sample_table and colnames of otu_table. # In R6 class, &#39;$new&#39; is the original method used to create a new object of class dataset &lt;- microtable$new(otu_table = otu_table_16S) ## No sample_table provided, automatically use colnames in otu_table to create one ... # If you only provide abundance table, the class can help you create a sample info table class(dataset) ## [1] &quot;microtable&quot; &quot;R6&quot; dataset ## microtable class: ## sample_table have 90 rows and 2 columns ## otu_table have 13628 rows and 90 columns # Let&#39;s create a dataset microtable with more information dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, tax_table = taxonomy_table_16S, phylo_tree = phylo_tree_16S) dataset ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13628 rows and 7 columns ## phylo_tree have 14096 tips To make the species and sample information consistent across different files in the dataset object, we can use function tidy_dataset() to trim the dataset. dataset$tidy_dataset() print(dataset) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13628 rows and 7 columns ## phylo_tree have 13628 tips Then, we remove OTUs which are not assigned in the Kingdom \"k__Archaea\" or \"k__Bacteria\". dataset$tax_table %&lt;&gt;% base::subset(Kingdom == &quot;k__Archaea&quot; | Kingdom == &quot;k__Bacteria&quot;) print(dataset) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13330 rows and 7 columns ## phylo_tree have 13628 tips We also remove OTUs with the taxonomic assignments “mitochondria” or “chloroplast.” # This will remove the lines containing the taxa word regardless of taxonomic ranks and ignoring word case in the tax_table. # So if you want to filter some taxa not considerd pollutions, please use subset like the previous operation. dataset$filter_pollution(taxa = c(&quot;mitochondria&quot;, &quot;chloroplast&quot;)) ## Total 34 taxa are removed from tax_table ... print(dataset) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13296 rows and 7 columns ## phylo_tree have 13628 tips Then, to make the OTUs same in otu_table, tax_table and phylo_tree, we use tidy_dataset() again. dataset$tidy_dataset() print(dataset) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13296 rows and 90 columns ## tax_table have 13296 rows and 7 columns ## phylo_tree have 13296 tips Then we use sample_sums() to check the sequence numbers in each sample. dataset$sample_sums() %&gt;% range ## [1] 10316 37087 Sometimes, in order to reduce the effects of sequencing depth on the diversity measurements, we need to perform the resampling to make the sequence number equal for each sample. The function rarefy_samples can invoke the function tidy_dataset automatically before and after the rarefying. # As an example, we use 10000 sequences in each sample dataset$rarefy_samples(sample.size = 10000) ## 530 OTUs were removed because they are no longer present in any sample after random subsampling ... ## 530 taxa are removed from the otu_table, as the abundance is 0 ... dataset$sample_sums() %&gt;% range ## [1] 10000 10000 Then, we calculate the taxa abundance at each taxonomic rank using cal_abund(). This function return a list called taxa_abund containing several data frame of the abundance information at each taxonomic rank. The list is stored in the microtable object automatically. It’s worth noting that the cal_abund() function can be used to solve some complex cases, such as supporting both the relative and absolute abundance calculation and selecting the partial taxonomic columns. Those have been shown in README of file2meco package (https://github.com/ChiLiubio/file2meco). dataset$cal_abund() ## The result is stored in object$taxa_abund ... # return dataset$taxa_abund class(dataset$taxa_abund) ## [1] &quot;list&quot; The function save_abund() can be used to save the taxa abundance file to a local place. dir.create(&quot;taxa_abund&quot;) dataset$save_abund(dirpath = &quot;taxa_abund&quot;) Then, let’s calculate the alpha diversity. The result is also stored in the object microtable automatically. For the definition of each alpha diversity index, please see http://scikit-bio.org/docs/latest/generated/skbio.diversity.alpha.html As an example, we do not calculate phylogenetic diversity. # If you want to add Faith&#39;s phylogenetic diversity, use PD = TRUE, this will be a little slow dataset$cal_alphadiv(PD = FALSE) ## The result is stored in object$alpha_diversity ... # return dataset$alpha_diversity class(dataset$alpha_diversity) ## [1] &quot;data.frame&quot; # save dataset$alpha_diversity to a directory dir.create(&quot;alpha_diversity&quot;) dataset$save_alphadiv(dirpath = &quot;alpha_diversity&quot;) We also calculate the distance matrix of beta diversity using function cal_betadiv(). We provide four most frequently used indexes: Bray-curtis, Jaccard, weighted Unifrac and unweighted unifrac. # If you do not want to calculate unifrac metrics, use unifrac = FALSE # require GUniFrac package dataset$cal_betadiv(unifrac = TRUE) # return dataset$beta_diversity class(dataset$beta_diversity) # save dataset$beta_diversity to a directory dir.create(&quot;beta_diversity&quot;) dataset$save_betadiv(dirpath = &quot;beta_diversity&quot;) References "],["extended-class.html", "Chapter 4 Extended class 4.1 trans_abund class 4.2 trans_venn class 4.3 trans_alpha class 4.4 trans_beta class 4.5 trans_diff class 4.6 trans_env class 4.7 trans_nullmodel class 4.8 trans_network class 4.9 trans_func class", " Chapter 4 Extended class All the extended classes depend on the microtable class. Generally, one class can work alone. In some cases, one function of a class may interact with the object from another class to complete a method. 4.1 trans_abund class The trans_abund class is used to transform taxonomic abundance data for plotting the taxa abundance with the ggplot2 package. As a premise, the taxa_abund list in the object of microtable class must be first calculated. We first use this class for the bar plot. # create trans_abund object # use 10 Phyla with the highest abundance in the dataset. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10) # t1 object now include the transformed abundance data t1$abund_data and other elements for the following plotting We remove the sample names in x axis and add the facet to show abundance according to groups. t1$plot_bar(others_color = &quot;grey70&quot;, facet = &quot;Group&quot;, xtext_keep = FALSE, legend_text_italic = FALSE) # return a ggplot2 object # The groupmean parameter can be used to obtain the group-mean barplot. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) t1$plot_bar(others_color = &quot;grey70&quot;, legend_text_italic = FALSE) Then alluvial plot is implemented in the plot_bar function with the use_alluvium parameter. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 8) # use_alluvium = TRUE make the alluvial plot, clustering = TRUE can be used to reorder the samples by clustering t1$plot_bar(use_alluvium = TRUE, clustering = TRUE, xtext_type_hor = FALSE, xtext_size = 6) The box plot is an excellent way to intuitionally show data distribution across groups. # show 15 taxa at Class level t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Class&quot;, ntaxa = 15) t1$plot_box(group = &quot;Group&quot;) Then we show the heatmap with the high abundant genera. # show 40 taxa at Genus level t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Genus&quot;, ntaxa = 40) t1$plot_heatmap(facet = &quot;Group&quot;, xtext_keep = FALSE, withmargin = FALSE) Then, we show the pie chart with the group mean values. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 6, groupmean = &quot;Group&quot;) # all pie chart in one row t1$plot_pie(facet_nrow = 1) 4.2 trans_venn class The trans_venn class is used for venn analysis. To analyze the unique and shared OTUs of groups, we first merge samples according to the “Group” column of sample_table. # merge samples as one community for each group dataset1 &lt;- dataset$merge_samples(use_group = &quot;Group&quot;) # dataset1 is a new microtable object # create trans_venn object t1 &lt;- trans_venn$new(dataset1, ratio = &quot;seqratio&quot;) t1$plot_venn() # The integer data is OTU number # The percentage data is the sequence number/total sequence number When the groups are too many to show with venn plot, we can use petal plot. # use &quot;Type&quot; column in sample_table dataset1 &lt;- dataset$merge_samples(use_group = &quot;Type&quot;) t1 &lt;- trans_venn$new(dataset1) t1$plot_venn(petal_plot = TRUE) Sometimes, we are interested in the unique and shared species. In another words, the composition of the unique or shared species may account for the different and similar parts of ecological characteristics across groups(Mendes et al. 2011). For this goal, we first transform the results of venn plot to the traditional species-sample table, that is, another object of microtable class. dataset1 &lt;- dataset$merge_samples(use_group = &quot;Group&quot;) t1 &lt;- trans_venn$new(dataset1) ## The result is stored in object$venn_table and object$venn_count_abund ... # transform venn results to the sample-species table, here do not consider abundance, only use presence/absence information. t2 &lt;- t1$trans_venn_com(use_OTUs_frequency = TRUE) # t2 is a new microtable class, each part is considered as a sample class(t2) ## [1] &quot;microtable&quot; &quot;R6&quot; We use bar plot to show the composition at the Genus level. # calculate taxa abundance, that is, the frequency t2$cal_abund() # transform and plot t3 &lt;- trans_abund$new(dataset = t2, taxrank = &quot;Genus&quot;, ntaxa = 10) t3$plot_bar(bar_type = &quot;part&quot;, legend_text_italic = T, ylab_title = &quot;Frequency (%)&quot;, xtext_type_hor = FALSE) We also try to use pie chart to show the compositions at the Phylum level. t3 &lt;- trans_abund$new(dataset = t2, taxrank = &quot;Phylum&quot;, ntaxa = 8) t3$plot_pie(facet_nrow = 3, use_colors = rev(c(RColorBrewer::brewer.pal(8, &quot;Dark2&quot;), &quot;grey50&quot;))) 4.3 trans_alpha class Alpha diversity can be transformed and plotted using trans_alpha class. Creating the object of trans_alpha class can invoke the alpha_diversity data from the microtable object. The trans_alpha object have two data frame: alpha_data and alpha_stat. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) # return t1$alpha_stat t1$alpha_stat[1:5, ] ## The group statistics are stored in object$alpha_stat ... ## The transformed diversity data is stored in object$alpha_data ... Group Measure N Mean SD SE CW Observed 30 1843 220.6 40.27 CW Chao1 30 2553 338.1 61.73 CW ACE 30 2716 367 67.01 CW Shannon 30 6.308 0.5355 0.09777 CW Simpson 30 0.9897 0.01305 0.002382 Then, we test the differences among groups using the KW rank sum test and anova with multiple comparisons. t1$cal_diff(method = &quot;KW&quot;) # return t1$res_alpha_diff t1$res_alpha_diff[1:5, ] ## The result is stored in object$res_alpha_diff ... Groups Measure Test method p.value Significance IW vs CW Observed KW 0.0371 * IW vs TW Observed KW 0.4553 CW vs TW Observed KW 0.3912 IW vs CW vs TW Observed KW 0.155 IW vs CW Chao1 KW 0.002689 ** t1$cal_diff(method = &quot;anova&quot;) # return t1$res_alpha_diff t1$res_alpha_diff ## Registered S3 methods overwritten by &#39;klaR&#39;: ## method from ## predict.rda vegan ## print.rda vegan ## plot.rda vegan ## The result is stored in object$res_alpha_diff ...   Observed Chao1 ACE Shannon Simpson InvSimpson Fisher Coverage IW a a a a a a a b TW a ab b a a a a a CW a b b a a a a a Now, let us plot the mean and se of alpha diversity for each group, and add the duncan.test (agricolae package) result. t1$plot_alpha(add_letter = T, measure = &quot;Chao1&quot;, use_boxplot = FALSE) We can also use the boxplot to show the paired comparisons directly. t1$plot_alpha(pair_compare = TRUE, measure = &quot;Chao1&quot;, shape = &quot;Group&quot;) The multi-factor analysis of variance is also supported. It is notable that the result res_alpha_diff will be a list instead of a data.frame. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) t1$cal_diff(method = &quot;anova&quot;, anova_set = &quot;Group+Type&quot;) # now the result t1$res_alpha_diff is a list # see the help document for the usage of anova_set 4.4 trans_beta class The distance matrix of beta diversity can be transformed and plotted using trans_beta class. The analysis referred to the beta diversity in this class mainly include ordination, group distance, clustering and manova. We first show the ordination using PCoA. # we first create an trans_beta object # this operation invoke the distance matrix of bray in dataset$beta_diversity t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) ## Please also cite the original paper: An et al. (2019). Soil bacterial community structure in Chinese wetlands. Geoderma, 337, 290-299. t1$cal_ordination(ordination = &quot;PCoA&quot;) # t1$res_ordination is the ordination result list class(t1$res_ordination) # plot the PCoA result t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_group_ellipse = TRUE) Then we plot and compare the group distances. # calculate and plot sample distances within groups t1$cal_group_distance() # return t1$res_group_distance t1$plot_group_distance(distance_pair_stat = TRUE) # calculate and plot sample distances between groups t1$cal_group_distance(within_group = FALSE) t1$plot_group_distance(distance_pair_stat = TRUE) Clustering plot is also a frequently used method. # use replace_name to set the label name, group parameter used to set the color t1$plot_clustering(group = &quot;Group&quot;, replace_name = c(&quot;Saline&quot;, &quot;Type&quot;)) perMANOVA(Anderson 2001) is often used in the differential test of distances among groups. # manova for all groups t1$cal_manova(cal_manova_all = TRUE) t1$res_manova$aov.tab ## The result is stored in object$res_manova ... Permutation: free   Df SumsOfSqs MeanSqs F.Model R2 Pr(&gt;F) Group 2 6.121 3.06 10.57 0.1955 0.001 Residuals 87 25.18 0.2895 NA 0.8045 NA Total 89 31.3 NA NA 1 NA # manova for each paired groups t1$cal_manova(cal_manova_paired = TRUE) t1$res_manova ## The result is stored in object$res_manova ... Groups measure permutations R2 p.value Significance IW vs CW bray 999 0.1595 0.001 *** IW vs TW bray 999 0.147 0.001 *** CW vs TW bray 999 0.1556 0.001 *** # manova for specified group set: here &quot;Group + Type&quot; t1$cal_manova(cal_manova_set = &quot;Group + Type&quot;) t1$res_manova$aov.tab ## The result is stored in object$res_manova ... Permutation: free   Df SumsOfSqs MeanSqs F.Model R2 Pr(&gt;F) Group 2 6.121 3.06 12.01 0.1955 0.001 Type 3 3.783 1.261 4.949 0.1208 0.001 Residuals 84 21.4 0.2548 NA 0.6836 NA Total 89 31.3 NA NA 1 NA PERMDISP(Anderson et al. 2011) is also implemented to check multivariate homogeneity of groups dispersions (variances). # PERMDISP for the whole comparison and for each paired groups t1$cal_betadisper() ## The result is stored in object$res_betadisper ... t1$res_betadisper ## ## Permutation test for homogeneity of multivariate dispersions ## Permutation: free ## Number of permutations: 999 ## ## Response: Distances ## Df Sum Sq Mean Sq F N.Perm Pr(&gt;F) ## Groups 2 0.04131 0.0206545 4.1682 999 0.021 * ## Residuals 87 0.43110 0.0049552 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Pairwise comparisons: ## (Observed p-value below diagonal, permuted p-value above diagonal) ## CW IW TW ## CW 0.4690000 0.063 ## IW 0.4621193 0.005 ## TW 0.0566190 0.0050319 4.5 trans_diff class Differential abundance test is a very important part in the microbial community data analysis. It can be used to find the significant taxa in determining the community differences across groups. Currently, trans_diff class have four famous approaches to perform this analysis: metastat(White, Nagarajan, and Pop 2009), LEfSe(Segata et al. 2011), random forest and metagenomeSeq(Paulson et al. 2013). Metastat depends on the permutations and t-test and performs well on the sparse data. It is used for the comparisons of taxonomic abundance between two groups at any taxonomic level. LEfSe and random forest in this class is mainly used for the identification of biomarkers including all taxonomic level. metagenomeSeq method is implemented to find significant species between two groups at species level (OTU/ASV). # metastat analysis at Genus level t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;metastat&quot;, group = &quot;Group&quot;, metastat_taxa_level = &quot;Genus&quot;) # t1$res_metastat is the result # t1$res_metastat_group_matrix is the group comparisons order for plotting # plot the first paired groups, choose_group = 1 t1$plot_metastat(use_number = 1:10, qvalue = 0.05, choose_group = 1) LEfSe combines the non-parametric test and linear discriminant analysis. We implement this approach in this package instead of the python version. t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;lefse&quot;, group = &quot;Group&quot;, alpha = 0.01, lefse_subgroup = NULL) # t1$res_lefse is the LEfSe result # t1$res_abund is the abundance information t1$plot_lefse_bar(LDA_score = 4) t1$res_lefse[1:5, ] Taxa Group pvalue LDA k__Bacteria|p__Proteobacteria CW 3.21e-11 4.834 k__Bacteria|p__Acidobacteria|c__Acidobacteria IW 8.559e-13 4.787 k__Bacteria|p__Acidobacteria IW 5.749e-12 4.785 k__Bacteria|p__Bacteroidetes TW 1.19e-09 4.776 k__Bacteria|p__Proteobacteria|c__Gammaproteobacteria CW 5.475e-12 4.613 Then, we plot the abundance of biomarkers detected by LEfSe. t1$plot_diff_abund(use_number = 1:30) Then, we show the cladogram of the differential features in the taxonomic tree. There are too many taxa in this dataset. As an example, we only use the highest 200 abundant taxa in the tree and 50 differential features. We only show the full taxonomic label at Phylum level and use letters at other levels to reduce the text overlap. # clade_label_level 5 represent phylum level in this analysis # require ggtree package t1$plot_lefse_cladogram(use_taxa_num = 200, use_feature_num = 50, clade_label_level = 5) There may be a problem related with the taxonomic labels in the plot. When the levels used are too many, the taxonomic labels may have too much overlap. However, if you only indicate the Phylum labels, the taxa in the legend with marked letters are too many. At this time, you can select the taxa that you want to show in the plot manually like the following operation. # choose some taxa according to the positions in the previous picture; those taxa labels have minimum overlap use_labels &lt;- c(&quot;c__Deltaproteobacteria&quot;, &quot;c__Actinobacteria&quot;, &quot;o__Rhizobiales&quot;, &quot;p__Proteobacteria&quot;, &quot;p__Bacteroidetes&quot;, &quot;o__Micrococcales&quot;, &quot;p__Acidobacteria&quot;, &quot;p__Verrucomicrobia&quot;, &quot;p__Firmicutes&quot;, &quot;p__Chloroflexi&quot;, &quot;c__Acidobacteria&quot;, &quot;c__Gammaproteobacteria&quot;, &quot;c__Betaproteobacteria&quot;, &quot;c__KD4-96&quot;, &quot;c__Bacilli&quot;, &quot;o__Gemmatimonadales&quot;, &quot;f__Gemmatimonadaceae&quot;, &quot;o__Bacillales&quot;, &quot;o__Rhodobacterales&quot;) # then use parameter select_show_labels to show t1$plot_lefse_cladogram(use_taxa_num = 200, use_feature_num = 50, select_show_labels = use_labels) # Now we can see that more taxa names appear in the tree If you are interested in taxonomic tree, you can also use metacoder package(Foster, Sharpton, and Grunwald 2017) to plot the taxonomic tree based on the selected taxa. We do not show the usage here. The third approach is rf, which depends on the random forest(Beck and Foster 2014; Yatsunenko et al. 2012) and the non-parametric test. The current method can calculate random forest by bootstrapping like the method in LEfSe and only use the significant features. MeanDecreaseGini is selected as the indicator value in the analysis. # use Genus level for parameter rf_taxa_level, if you want to use all taxa, change to &quot;all&quot; # nresam = 1 and boots = 1 represent no bootstrapping and use all samples directly t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;rf&quot;, group = &quot;Group&quot;, rf_taxa_level = &quot;Genus&quot;) # t1$res_rf is the result stored in the object # plot the result t2 &lt;- t1$plot_diff_abund(use_number = 1:20, only_abund_plot = FALSE) gridExtra::grid.arrange(t2$p1, t2$p2, ncol=2, nrow = 1, widths = c(2,2)) # the middle asterisk represent the significances 4.6 trans_env class The environmental variables are very useful in analyzing microbial community structure and assembly mechanisms. We first show the RDA analysis (db-RDA and RDA). # add_data is used to add the environmental data t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use bray-curtis distance to do dbrda t1$cal_rda(use_dbrda = TRUE, use_measure = &quot;bray&quot;) # t1$res_rda is the result list stored in the object t1$trans_rda(adjust_arrow_length = TRUE, max_perc_env = 10) # t1$res_rda_trans is the transformed result for plotting t1$plot_rda(plot_color = &quot;Group&quot;) # use Genus t1$cal_rda(use_dbrda = FALSE, taxa_level = &quot;Genus&quot;) # As the main results of RDA are related with the projection and angles between different arrows, # we adjust the length of the arrow to show them clearly using several parameters. t1$trans_rda(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1500, max_perc_tax = 3000, min_perc_env = 200, min_perc_tax = 300) # t1$res_rda_trans is the transformed result for plotting t1$plot_rda(plot_color = &quot;Group&quot;) Mantel test can be used to check whether there is significant correlations between environmental variables and distance matrix. t1$cal_mantel(use_measure = &quot;bray&quot;) # return t1$res_mantel t1$res_mantel ## The result is stored in object$res_mantel or object$res_mantel_partial ... variable_name cor_method corr_res p_res significance Temperature pearson 0.452 0.001 *** Precipitation pearson 0.2791 0.001 *** TOC pearson 0.13 0.003 ** NH4 pearson -0.05539 0.926 NO3 pearson 0.06758 0.05 * pH pearson 0.4085 0.001 *** Conductivity pearson 0.2643 0.001 *** TN pearson 0.1321 0.002 ** The correlations between environmental variables and taxa are important in analyzing and inferring the factors affecting community structure. Let’s first perform a correlation heatmap using Genus level data. t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) t1$cal_cor(use_data = &quot;Genus&quot;, p_adjust_method = &quot;fdr&quot;) ## The correlation result is stored in object$res_cor ... # return t1$res_cor Then, we can plot the correlation results using plot_cor function. # default ggplot2 method with clustering t1$plot_cor() There are too many genera. We can use the filter_feature parameter in plot_cor to filter some taxa that do not have any significance &lt; 0.001. # filter genera that do not have at least one *** t1$plot_cor(filter_feature = c(&quot;&quot;, &quot;*&quot;, &quot;**&quot;)) Sometimes, if we want to conduct the correlation analysis between the environmental factors and some important taxa which are detected in the biomarker analysis, we can use other_taxa parameter in cal_cor function. # first create trans_diff object as a demonstration t2 &lt;- trans_diff$new(dataset = dataset, method = &quot;rf&quot;, group = &quot;Group&quot;, rf_taxa_level = &quot;Genus&quot;) ## Start differential test for Group ... ## Total 432 biomarkers found ... ## The result is stored in object$res_rf ... ## The abundance is stored in object$res_abund ... # then create trans_env object t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use other_taxa to select taxa you need t1$cal_cor(use_data = &quot;other&quot;, p_adjust_method = &quot;fdr&quot;, other_taxa = t2$res_rf$Taxa[1:40]) ## The correlation result is stored in object$res_cor ... t1$plot_cor() The pheatmap method is also available. # clustering heatmap; require pheatmap package t1$plot_cor(pheatmap = TRUE) Sometimes, if it is necessary to study the correlations between environmental variables and taxa for different groups, by_group parameter can be used for this goal. # calculate correlations for different groups using parameter by_group t1$cal_cor(by_group = &quot;Group&quot;, use_data = &quot;other&quot;, p_adjust_method = &quot;fdr&quot;, other_taxa = t2$res_rf$Taxa[1:40]) # return t1$res_cor t1$plot_cor() If you are concerned with the relationship between environmental factors and alpha diversity, you can also use this function. t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use add_abund_table parameter to add the extra data table t1$cal_cor(add_abund_table = dataset$alpha_diversity) t1$plot_cor() The function plot_scatterfit() in trans_env class is designed for the scatter plot, adding the fitted line and statistics. # use pH and bray-curtis distance t1$plot_scatterfit( x = &quot;pH&quot;, y = dataset$beta_diversity$bray[rownames(t1$env_data), rownames(t1$env_data)], alpha = .1, x_axis_title = &quot;Euclidean distance of pH&quot;, y_axis_title = &quot;Bray-Curtis distance&quot;, text_x_pos = 4, text_y_pos = .4) 4.7 trans_nullmodel class In recent decades, the integration of phylogenetic analysis and null model promotes the inference of niche and neutral influences on community assembly more powerfully by adding a phylogeny dimension (Webb et al. 2002; Stegen et al. 2013). The trans_nullmodel class provides an encapsulation, including the calculation of the phylogenetic signal, beta mean pairwise phylogenetic distance (betaMPD), beta mean nearest taxon distance (betaMNTD), beta nearest taxon index (betaNTI), beta net relatedness index (betaNRI) and Bray-Curtis-based Raup-Crick (RCbray). The approach for phylogenetic signal analysis is based on the mantel correlogram (Liu et al. 2017), in which the change of phylogenetic signal is intuitional and clear compared to other approaches. The algorithms of betaMNTD and betaMPD have been optimized to be faster than those in the picante package (Kembel et al. 2010). The combinations between RCbray and betaNTI (or betaNRI) can be used to infer the strength of each ecological process dominating the community assembly under the specific hypothesis (Stegen et al. 2013). This can be achievable by the function cal_process() to parse the percentage of each inferred process. We first check the phylogenetic signal. # generate trans_nullmodel object; use 1000 OTUs as example t1 &lt;- trans_nullmodel$new(dataset, taxa_number = 1000, add_data = env_data_16S) # use pH as the test variable t1$cal_mantel_corr(use_env = &quot;pH&quot;) # return t1$res_mantel_corr # plot the mantel correlogram t1$plot_mantel_corr() betaNRI(ses.betampd) is used to show the ‘basal’ phylogenetic turnover(Liu et al. 2017). Compared to betaNTI, it can capture more turnover information associated with the deep phylogeny. It is noted that there are many null models with the development in the several decades. In the trans_nullmodel class, we randomized the phylogenetic relatedness of species. This shuffling approach fix the observed levels of species α-diversity and β-diversity to explore whether the observed phylogenetic turnover significantly differ from null model that phylogenetic relatedness among species are random. # null model run 500 times t1$cal_ses_betampd(runs=500, abundance.weighted = TRUE) # return t1$res_ses_betampd If we want to plot the betaNRI, we can use plot_group_distance function in trans_beta class. For example, the results showed that the mean betaNRI of TW is extremely and significantly larger that those in CW and IW, revealing that the basal phylogenetic turnover in TW is high. # add betaNRI matrix to beta_diversity list dataset$beta_diversity[[&quot;betaNRI&quot;]] &lt;- t1$res_ses_betampd # create trans_beta class, use measure &quot;betaNRI&quot; t2 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;betaNRI&quot;) # transform the distance for each group t2$cal_group_distance() # plot the results g1 &lt;- t2$plot_group_distance(distance_pair_stat = TRUE) g1 + geom_hline(yintercept = -2, linetype = 2) + geom_hline(yintercept = 2, linetype = 2) Sometimes, if you want to perform null model analysis for each group individually, such as one group as one species pool, you can calculate the results for each group, respectively. We can find that, when we perform betaNRI for each group respectively, mean betaNRI between CW and TW are not significantly different, and they are both significantly higher than that in IW, revealing that the strength of variable selection in CW and TW may be similar under the condition that each area is considered as a specific species pool. # we create a list to store the trans_nullmodel results. sesbeta_each &lt;- list() group_col &lt;- &quot;Group&quot; all_groups &lt;- unique(dataset$sample_table[, group_col]) # calculate for each group, respectively for(i in all_groups){ # like the above operation, but need provide &#39;group&#39; and &#39;select_group&#39; test &lt;- trans_nullmodel$new(dataset, group = group_col, select_group = i, taxa_number = 1000, add_data = env_data_16S) test$cal_ses_betampd(runs = 500, abundance.weighted = TRUE) sesbeta_each[[i]] &lt;- test$res_ses_betampd } # merge and reshape to generate one symmetrical matrix test &lt;- lapply(sesbeta_each, melt) %&gt;% do.call(rbind, .) %&gt;% reshape2::dcast(., Var1~Var2, value.var = &quot;value&quot;) %&gt;% `row.names&lt;-`(.[,1]) %&gt;% .[, -1, drop = FALSE] # like the above operation dataset$beta_diversity[[&quot;betaNRI&quot;]] &lt;- test t2 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;betaNRI&quot;) t2$cal_group_distance() g1 &lt;- t2$plot_group_distance(distance_pair_stat = TRUE) g1 + geom_hline(yintercept = -2, linetype = 2) + geom_hline(yintercept = 2, linetype = 2) BetaNTI(ses.betamntd) can be used to indicate the phylogenetic terminal turnover (Stegen et al. 2013). # null model run 500 times t1$cal_ses_betamntd(runs=500, abundance.weighted = TRUE) # return t1$res_ses_betamntd   S1 S2 S3 S4 S5 S1 0 -6.554 -6.563 -6.308 -6.153 S2 -6.554 0 -6.678 -6.675 -6.124 S3 -6.563 -6.678 0 -6.544 -6.46 S4 -6.308 -6.675 -6.544 0 -6.356 S5 -6.153 -6.124 -6.46 -6.356 0 RCbray (Bray-Curtis-based Raup-Crick) can be calculated using function cal_rcbray() to assess whether the compositional turnover was governed primarily by drift (Chase et al. 2011). We applied null model to simulate species distribution by randomly sampling individuals from each species pool with preserving species occurrence frequency and sample species richness (Liu et al. 2017). # result stored in t1$res_rcbray t1$cal_rcbray(runs = 1000) # return t1$res_rcbray As an example, we also calculate the proportion of the inferred processes on the community assembly as shown in the references (Stegen et al. 2013; Liu et al. 2017). In the example, the fraction of pairwise comparisons with significant betaNTI values (|βNTI| &gt; 2) is the estimated influence of Selection; βNTI &gt; 2 represents the heterogeneous selection; βNTI &lt; -2 represents the homogeneous selection. The value of RCbray characterizes the magnitude of deviation between observed Bray–Curtis and Bray–Curtis expected under the randomization; a value of |RCbray| &gt; 0.95 was considered significant. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and RCbray &gt; +0.95 was taken as the influence of Dispersal Limitation combined with Drift. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and RCbray &lt; -0.95 was taken as an estimate for the influence of Homogenizing Dispersal. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and |RCbray| &lt; 0.95 estimates the influence of Drift acting alone. # use betaNTI and rcbray to evaluate processes t1$cal_process(use_betamntd = TRUE) ## The result is stored in object$res_process ... # return t1$res_process t1$res_process process percentage variable selection 3.995 homogeneous selection 48.34 dispersal limitation 0.02497 homogeneous dispersal 8.539 drift 39.1 4.8 trans_network class Network is a frequently used approach to study the co-occurrence patterns in microbial ecology(Deng et al. 2012; Faust and Raes 2012; Coyte, Schluter, and Foster 2015). In this part, we describe all the core contents in the trans_network class. The network construction approaches can be classified into two types: correlation-based and non correlation-based. Several approaches can be used to calculate correlations and significances. We first introduce the correlation-based network. The parameter cal_cor in trans_network is used for selecting the correlation calculation method. # Use R base cor.test, slow t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;base&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001, cor_method = &quot;spearman&quot;) # return t1$res_cor_p list; one table: correlation; another: p value # SparCC method, require SpiecEasi package # SparCC is very slow, so consider filtering more species with low abundance t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;SparCC&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.001, SparCC_simu_num = 100) # When the OTU number is large, use R WGCNA package to replace R base to calculate correlations # require WGCNA package t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;WGCNA&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001, cor_method = &quot;spearman&quot;) The parameter COR_cut can be used to select the correlation threshold. Furthermore, COR_optimization = TRUE represent using RMT theory to find the optimized correlation threshold instead of the COR_cut(Deng et al. 2012). # construct network; require igraph package t1$cal_network(p_thres = 0.01, COR_optimization = TRUE) # return t1$res_network # use arbitrary coefficient threshold to contruct network t1$cal_network(p_thres = 0.01, COR_cut = 0.7) # add modules in the network t1$cal_module() # save network # open the gexf file using Gephi(https://gephi.org/) # require rgexf package t1$save_network(filepath = &quot;network.gexf&quot;) We plot the network and present the node colors according to the calculated modules in Gephi. Now, we show the node colors with the Phylum information and the edges colors with the positive and negative correlations. All the data used has been stored in the network.gexf file, including modules classifications, Phylum information and edges classifications. # calculate network attributes t1$cal_network_attr() # return t1$res_network_attr Property Value Vertex 407 Edge 1989 Average_degree 9.774 Average_path_length 3.878 Network_diameter 9 Clustering_coefficient 0.4698 Density 0.02407 Heterogeneity 1.194 Centralization 0.09908 # classify the node; return t1$res_node_type t1$cal_node_type() # return t1$res_node_type # we retain the file for the following example in trans_func part network_node_type &lt;- t1$res_node_type   z module p taxa_roles OTU_50 -1.305 M2 0 Peripheral nodes OTU_1 -0.04067 M2 0 Peripheral nodes OTU_55 -1.239 M2 0 Peripheral nodes OTU_13824 -0.2403 M2 0 Peripheral nodes OTU_151 -1.372 M2 0.4444 Peripheral nodes # plot node roles in terms of the within-module connectivity and among-module connectivity t1$plot_taxa_roles(use_type = 1) # plot node roles with phylum information t1$plot_taxa_roles(use_type = 2) Now, we show the eigengene analysis of modules. The eigengene of a module, i.e. the first principal component of PCA, represents the main variance of the abundance in the species of the module. t1$cal_eigen() # return t1$res_eigen Then we perform correlation heatmap to show the relationships between eigengenes and environmental factors. # create trans_env object like the above operation t2 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # calculate correlations t2$cal_cor(add_abund_table = t1$res_eigen) # plot the correlation heatmap t2$plot_cor() The subset_network() function can be used to extract a part of nodes and edges among these nodes from the network. In this function, you should provide the nodes you need using the node parameter. # extract a sub network that contains all nodes in module M1 t1$subset_network(node = t1$res_node_type %&gt;% .[.$module == &quot;M1&quot;, ] %&gt;% rownames, rm_single = TRUE) # return a new network with igraph class # extract sub network in which all edge labels are &quot;+&quot;, i.e. positive edges t1$subset_network(edge = &quot;+&quot;) Then we show the next implemented network construction approach: SPIEC-EASI (SParse InversE Covariance Estimation for Ecological Association Inference) network in SpiecEasi R package (Kurtz et al. 2015). # cal_cor select NA t1 &lt;- trans_network$new(dataset = dataset, cal_cor = NA, taxa_level = &quot;OTU&quot;, filter_thres = 0.0005) # require SpiecEasi package https://github.com/zdk123/SpiecEasi t1$cal_network(network_method = &quot;SpiecEasi&quot;) # see t1$res_network We also introduce the third network construction approach: Probabilistic Graphical Models (PGM), which is implemented in julia package FlashWeave(Tackmann, Matias Rodrigues, and Mering 2019). It predicts ecological interactions among microbes from large-scale compositional abundance data (i.e. OTU tables constructed from sequencing data) through statistical co-occurrence. If you want to use this method like the following code, you should first install julia language in your computer and the FlashWeave package, and add the julia in the computer path. download and install julia from https://julialang.org/downloads/ Put julia in the computer env PATH, such as your_directory_path Open terminal or cmd or Powershell, open julia, install FlashWeave following the operation in https://github.com/meringlab/FlashWeave.jl # cal_cor select NA t1 &lt;- trans_network$new(dataset = dataset, cal_cor = NA, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001) # require Julia in the computer path, and the package FlashWeave t1$cal_network(network_method = &quot;PGM&quot;) # see t1$res_network 4.9 trans_func class Ecological researchers are usually interested in the the funtional profiles of microbial communities, because functional or metabolic data is powerful to explain the structure and dynamics of microbial communities and to infer the underlying mechanisms. As metagenomic sequencing is complicated and expensive, using amplicon sequencing data to predict functional profiles is a good choice. Several software are often used for this goal, such as PICRUSt(Langille et al. 2013), Tax4Fun(Aßhauer et al. 2015) and FAPROTAX(Stilianos Louca et al. 2016; S. Louca, Parfrey, and Doebeli 2016). These tools are great to be used for the prediction of functional profiles based on the prokaryotic communities from sequencing results. In addition, it is also important to obtain the functions for each taxa or OTU, not just the whole profile of communities. But it is hard to know exact functions of each OTU. FAPROTAX database is a collection of the traits and characteristics of prokaryotes based on the known research results published in books and literatures. We match the taxonomic information of prokaryotes against this database to identify the traits of prokaryotes on biogeochemical roles. The NJC19 database(Lim et al. 2020) is also available for animal associated prokaryotic data, such as human gut microbiota. We also implement the FUNGuild (Nguyen et al. 2016) and FungalTraits (Põlme et al. 2020) databases to identify the fungal traits. # Identify microbial traits # create object of trans_func t2 &lt;- trans_func$new(dataset) # mapping the taxonomy to the database # this can recognize prokaryotes or fungi automatically. # default database for prokaryotes is FAPROTAX database t2$cal_spe_func() ## Please also cite the original FAPROTAX paper: Louca et al. (2016). ## Decoupling function and taxonomy in the global ocean microbiome. Science, 353(6305), 1272. ## The functional table is stored in object$res_spe_func ... # return t2$res_spe_func, 1 represent function exists, 0 represent no or cannot confirmed. t2$res_spe_func[1:5, 1:2]   methanotrophy acetoclastic_methanogenesis OTU_4272 0 0 OTU_236 0 0 OTU_399 0 0 OTU_1556 0 0 OTU_32 0 0 The percentages of the OTUs having the same trait can reflect the functional redundancy of this function in the community or the module in the network. # calculate the percentages of OTUs for each trait in each module of network # use_community = FALSE represent calculating module, not community, node_type_table provide the module information t2$cal_spe_func_perc(use_community = FALSE, node_type_table = network_node_type) # return t2$res_spe_func_perc # we only plot some important traits, so we use the default group list to filter and show the traits. t2$plot_spe_func_perc(select_samples = paste0(&quot;M&quot;, 1:10)) # M represents module, ordered by the nodes number from high to low # If you want to change the group list, reset the list t2$func_group_list t2$func_group_list # use show_prok_func to see the detailed information of prokaryotic traits t2$show_prok_func(&quot;methanotrophy&quot;) # calculate the percentages for communities t2$cal_spe_func_perc(use_community = TRUE) ## The result table is stored in object$res_spe_func_perc ... # t2$res_spe_func_perc[1:5, 1:2]   methanotrophy acetoclastic_methanogenesis S1 0.39 0.04 S2 0.27 0 S3 0.48 0 S4 0.48 0 S5 0.56 0 # then we try to correlate the res_spe_func_perc of communities to environmental variables t3 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) t3$cal_cor(add_abund_table = t2$res_spe_func_perc, cor_method = &quot;spearman&quot;) t3$plot_cor(pheatmap = TRUE) Tax4Fun requires a strict input file demand on the taxonomic information. To analyze the trimmed or changed OTU data in R with Tax4Fun, we provide a link to the Tax4Fun functional prediction. t1 &lt;- trans_func$new(dataset) # install Tax4Fun package and download SILVA123 ref data from http://tax4fun.gobics.de/ # decompress SILVA123; provide path in folderReferenceData as you put t1$cal_tax4fun(folderReferenceData = &quot;./SILVA123&quot;) ## 载入需要的程辑包：Tax4Fun ## 载入需要的程辑包：Matrix ## 载入需要的程辑包：qiimer ## 载入需要的程辑包：biom ## Warning in write.table(otu_file, file = output, append = TRUE, quote = FALSE, : ## appending column names to file ## The KO abundance result is stored in object$tax4fun_KO ... ## The pathway abundance result is stored in object$tax4fun_path ... # return two files: t1$tax4fun_KO: KO file; t1$tax4fun_path: pathway file. # t1$tax4fun_KO$Tax4FunProfile[1:5, 1:2]   K00001; alcohol dehydrogenase [EC:1.1.1.1] K00002; alcohol dehydrogenase (NADP+) [EC:1.1.1.2] S1 0.0004823 5.942e-06 S2 0.0005266 4.017e-06 S3 0.0005054 6.168e-06 S4 0.0005109 5.888e-06 S5 0.0005083 5.547e-06 Now, we use pathway file to analyze the abundance of pathway. # must transpose to taxa row, sample column pathway_file &lt;- t1$tax4fun_path$Tax4FunProfile %&gt;% t %&gt;% as.data.frame # filter rownames, only keep ko+number rownames(pathway_file) %&lt;&gt;% gsub(&quot;(^.*);\\\\s.*&quot;, &quot;\\\\1&quot;, .) # load the pathway hierarchical metadata data(ko_map) # create a microtable object, familiar? func1 &lt;- microtable$new(otu_table = pathway_file, tax_table = ko_map, sample_table = t1$sample_table) print(func1) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 284 rows and 90 columns ## tax_table have 341 rows and 3 columns Now, we need to trim data and calculate abundance. func1$tidy_dataset() # calculate abundance automatically at three levels: level_1, level_2, level_3 func1$cal_abund() ## The result is stored in object$taxa_abund ... print(func1) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 284 rows and 90 columns ## tax_table have 284 rows and 3 columns ## Taxa abundance: calculated for level_1,level_2,level_3 Then, we can plot the abundance. # bar plot at level_1 func2 &lt;- trans_abund$new(func1, taxrank = &quot;level_1&quot;, groupmean = &quot;Group&quot;) func2$plot_bar(legend_text_italic = FALSE) We can also do something else. For example, we can use lefse to test the differences of the abundances and find the important enriched pathways across groups. func2 &lt;- trans_diff$new(dataset = func1, method = &quot;lefse&quot;, group = &quot;Group&quot;, alpha = 0.05, lefse_subgroup = NULL) func2$plot_lefse_bar(LDA_score = 3, width = 0.8) Tax4Fun2 (Wemheuer et al. 2020) is another R package for the prediction of functional profiles of prokaryotic communities from 16S rRNA gene sequences. It can provides two indexes for the evaluation of functional gene redundancies. We provide two functions cal_tax4fun2() and cal_tax4fun2_FRI() in trans_func class for the Tax4Fun2 analysis. If you want to use Tax4Fun2 method, you must add the fasta file to the microtable object. # create a microtable object with the fasta file data(sample_info_16S) data(otu_table_16S) data(taxonomy_table_16S) data(rep_fasta_16S) use_dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, tax_table = taxonomy_table_16S, rep_fasta = rep_fasta_16S) use_dataset$filter_pollution(taxa = c(&quot;mitochondria&quot;, &quot;chloroplast&quot;)) use_dataset$tidy_dataset() use_dataset t1 &lt;- trans_func$new(use_dataset) # create a directory for result and log files dir.create(&quot;test_prediction&quot;) # see https://github.com/ChiLiubio/microeco for downloading ncbi-blast and Ref99NR/Ref100NR t1$cal_tax4fun2(blast_tool_path = &quot;ncbi-blast-2.11.0+/bin&quot;, path_to_reference_data = &quot;test_ReferenceData_v2&quot;, path_to_temp_folder = &quot;test_prediction&quot;, database_mode = &quot;Ref99NR&quot;) # functional gene redundancies t1$cal_tax4fun2_FRI() References "],["other-data.html", "Chapter 5 Other data 5.1 Fungi data 5.2 Metagenomic data 5.3 Animal data", " Chapter 5 Other data 5.1 Fungi data The above examples are shown with the prokaryotic data. Now, we use the ITS amplicon sequencing dataset as an example to show the use of FUNGuild database(Nguyen et al. 2016). FungalTraits (Põlme et al. 2020) database is also available for identifying fungal traits. # load ITS data data(sample_info_ITS) data(otu_table_ITS) data(taxonomy_table_ITS) # create microtable object dataset &lt;- microtable$new(sample_table = sample_info_ITS, otu_table = otu_table_ITS, tax_table = taxonomy_table_ITS) # remove the taxa not assigned in the Kingdom &quot;k__Fungi&quot; dataset$tax_table %&lt;&gt;% base::subset(Kingdom == &quot;k__Fungi&quot;) # use tidy_dataset() to make OTUs and samples information consistent across files dataset$tidy_dataset() # create trans_network object t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;WGCNA&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.000001, cor_method = &quot;spearman&quot;) # create correlation network t1$cal_network(p_thres = 0.05, COR_cut = 0.6) # add modules t1$cal_module() # calculate node topological properties t1$cal_node_type() node_type_table &lt;- t1$res_node_type # create trans_func object t2 &lt;- trans_func$new(dataset) # identify species traits, automatically select database for prokaryotes or fungi # fungi_database = &quot;FungalTraits&quot; for the FungalTraits database t2$cal_spe_func(fungi_database = &quot;FUNGuild&quot;) # calculate abundance-unweighted functional redundancy of each trait for each network module t2$cal_spe_func_perc(use_community = FALSE, node_type_table = node_type_table) # plot the functional redundancy of network modules t2$plot_spe_func_perc(select_samples = paste0(&quot;M&quot;, 1:10)) 5.2 Metagenomic data Many methods in microeco package can be used not only for the traditional species abundance data, i.e. species-sample table, but also for other data, such as metagenomic and metabolomic data. In the file2meco package (https://github.com/ChiLiubio/file2meco), we provide several functions to transform the output files of some famous metagenomic tools (e.g. HUMAnN) to the microtable object directly. HUMAnN(Franzosa et al. 2018) is an excellent tool for functional profiling analysis of metagenomes and metatranscriptomes at species-level. Certainly, it can also be used for the whole community profile of metabolic pathways if you do not need something at species-level. The humann2meco() function can be used to creat the microtable object using metagenomic analysis files from HUMAnN2 and HUMAnN3 (https://huttenhower.sph.harvard.edu/humann). Currently, it supports both the MetaCyc (https://metacyc.org/) and KEGG pathway abundance file input. Here, we show the example of KEGG pathway results. library(microeco) library(file2meco) library(magrittr) ?humann2meco sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) # use KEGG pathway based HUMAnN result abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_HUMAnN_KEGG_abund.tsv&quot;, package=&quot;file2meco&quot;) test &lt;- humann2meco(abund_table = abund_file_path, db = &quot;KEGG&quot;, sample_data = sample_file_path, match_table = match_file_path) # remove the unclassified pathway in the top level test$tax_table %&lt;&gt;% subset(level1 != &quot;unclassified&quot;) test$tidy_dataset() # rel = FALSE donot use relative abundance, use the raw RPK test$cal_abund(select_cols = 1:3, rel = FALSE) test1 &lt;- trans_abund$new(test, taxrank = &quot;level2&quot;, ntaxa = 10) test1$plot_bar(facet = &quot;Group&quot;, ylab_title = &quot;Abundance (RPK)&quot;, use_colors = RColorBrewer::brewer.pal(12, &quot;Set3&quot;)) Then, we select both function and taxa to see which taxa the high abundant pathways come from. # This operation is more flexible test$cal_abund(select_cols = c(&quot;level1&quot;, &quot;Phylum&quot;, &quot;Genus&quot;), rel = FALSE) test$taxa_abund$level1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test$taxa_abund$Phylum %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Phylum&quot;, ntaxa = 10, delete_part_prefix = T) test1$plot_bar(facet = &quot;Group&quot;, ylab_title = &quot;Abundance (RPK)&quot;, use_colors = RColorBrewer::brewer.pal(12, &quot;Set3&quot;)) Let’s run LEfSe to find some functional biomarkers to differentiate two groups. # functional biomarker test$cal_abund(select_cols = 1:3, rel = TRUE) test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;) test1$plot_lefse_bar(LDA_score = 3) 5.3 Animal data We use mouse gut data stored in file2meco package to show the input of QIIME2 file and the use of metabolic trait database NJC19 database(Lim et al. 2020). library(microeco) library(file2meco) library(ggplot2) # use data files inside the file2meco package. abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;dada2_table.qza&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample-metadata.tsv&quot;, package=&quot;file2meco&quot;) taxonomy_file_path &lt;- system.file(&quot;extdata&quot;, &quot;taxonomy.qza&quot;, package=&quot;file2meco&quot;) # construct microtable object data1 &lt;- qiime2meco(ASV_data = abund_file_path, sample_data = sample_file_path, taxonomy_data = taxonomy_file_path) data1$tidy_dataset() # We correct the species names in tax_table select_rows &lt;- data1$tax_table$Species != &quot;s__&quot; data1$tax_table$Species[select_rows] &lt;- paste0(&quot;s__&quot;, gsub(&quot;g__&quot;, &quot;&quot;, data1$tax_table$Genus[select_rows]), &quot; &quot;, gsub(&quot;s__&quot;, &quot;&quot;, data1$tax_table$Species[select_rows])) # taxonomic abundance data1$cal_abund() # create object of trans_func data2 &lt;- trans_func$new(data1) # Select NJC19 database data2$cal_spe_func(prok_database = &quot;NJC19&quot;) # get the trait percentage data data2$cal_spe_func_perc(use_community = TRUE) # inset the trait percentage result into taxa_abund of microtable object data1$taxa_abund$Trait &lt;- as.data.frame(t(data2$res_spe_func_perc)) # use trans_abund to plot t1 &lt;- trans_abund$new(dataset = data1, taxrank = &quot;Trait&quot;, ntaxa = 10, use_percentage = FALSE) t1$plot_box(group = &quot;donor_status&quot;) + ylab(&quot;Relative population abundance (%)&quot;) + theme(axis.text.x = element_text(size = 13)) References "],["notes.html", "Chapter 6 Notes 6.1 clone 6.2 subset of samples 6.3 change object 6.4 group order 6.5 add layers to plot", " Chapter 6 Notes We show some important things here. 6.1 clone R6 class has a special copy mechanism which is different from S3 and S4. If you want to copy an object completely, you should use the function clone() instead of direct assignment. # use clone to copy completely t1 &lt;- clone(dataset) t2 &lt;- clone(t1) t2$sample_table &lt;- NULL identical(t2, t1) ## [1] FALSE # this operation is usually unuseful, because changing t2 will also affect t1 t2 &lt;- t1 t2$sample_table &lt;- NULL identical(t2, t1) ## [1] TRUE 6.2 subset of samples We donnot provide the special function to filter samples in microtable class, as we think it is redundant. We recommend user to directly manipulate the sample_table in microtable object. For example, if we want to analyze samples from ‘CW’ and ‘IW,’ respectively, we can operate like this: # remember first clone the full dataset group1 &lt;- clone(dataset) group1$sample_table &lt;- subset(group1$sample_table, Group == &quot;CW&quot;) # this is necessary to make files in group1 corresponding group1$tidy_dataset() # similar with obove operation group2 &lt;- clone(dataset) group2$sample_table &lt;- subset(group2$sample_table, Group == &quot;IW&quot;) group2$tidy_dataset() # now we get two microtable objects: group1 for CW and group2 for IW 6.3 change object All the classes are set public, meaning that you can change, add or remove the objects stored in them as you want. # add a matrix you think useful dataset$my_matrix &lt;- matrix(1, nrow = 4, ncol = 4) # change the information dataset$sample_table %&lt;&gt;% .[, -2] 6.4 group order If you want to reorder the groups, assign the factors may be the most simplest way. data(dataset) t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) ## Please also cite the original paper: An et al. (2019). Soil bacterial community structure in Chinese wetlands. Geoderma, 337, 290-299. t1$cal_ordination(ordination = &quot;PCoA&quot;) ## The ordination result is stored in object$res_ordination ... t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_group_ellipse = TRUE) Then we assign factors to the ‘Group’ in sample_table of dataset. We can find the changed group order in the legend and colors in the plot. dataset$sample_table$Group %&lt;&gt;% factor(., levels = c(&quot;IW&quot;, &quot;TW&quot;, &quot;CW&quot;)) str(dataset$sample_table) ## &#39;data.frame&#39;: 90 obs. of 4 variables: ## $ SampleID: chr &quot;S1&quot; &quot;S2&quot; &quot;S3&quot; &quot;S4&quot; ... ## $ Group : Factor w/ 3 levels &quot;IW&quot;,&quot;TW&quot;,&quot;CW&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Type : chr &quot;NE&quot; &quot;NE&quot; &quot;NE&quot; &quot;NE&quot; ... ## $ Saline : chr &quot;Non-saline soil&quot; &quot;Non-saline soil&quot; &quot;Non-saline soil&quot; &quot;Non-saline soil&quot; ... t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) ## Please also cite the original paper: An et al. (2019). Soil bacterial community structure in Chinese wetlands. Geoderma, 337, 290-299. t1$cal_ordination(ordination = &quot;PCoA&quot;) ## The ordination result is stored in object$res_ordination ... t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_group_ellipse = TRUE) 6.5 add layers to plot Most of the plots are generated by applying the ggplot2 package. The important parameters in the plotting functions are configured according to our experience. If the inner parameters can not enough, the user can add the layers to the plot like the following operation or make the plot using the data (generally data.frame class) stored in the object. # The groupmean parameter can be used to obtain the group-mean barplot. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) g1 &lt;- t1$plot_bar(others_color = &quot;grey70&quot;, legend_text_italic = FALSE) g1 + theme_classic() + theme(axis.title.y = element_text(size = 18)) "],["mecodev-package.html", "Chapter 7 mecodev package 7.1 trans_rarefy 7.2 trans_convert 7.3 trans_netchord 7.4 trans_ts 7.5 trans_gamma", " Chapter 7 mecodev package The mecodev package (https://github.com/ChiLiubio/mecodev/) is designed to develop more classes for data analysis based on the microeco package. 7.1 trans_rarefy The class trans_rarefy in mecodev package can be used for the rarefaction and the following plotting to see whether the sequencing depth is enough to cover all the so-called species in the microbial community. library(microeco) library(mecodev) data(sample_info_16S) data(otu_table_16S) # set.seed is used to fix the random number generation to make the results repeatable set.seed(123) dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S) dataset$tidy_dataset() # trans_rarefy class t1 &lt;- trans_rarefy$new(dataset, alphadiv = &quot;Shannon&quot;, depth = c(0, 10, 50, 500, 2000, 4000, 6000, 8000)) t1$plot_rarefy(color_values = rep(&quot;grey&quot;, 100), show_point = TRUE, add_fitting = FALSE, show_legend = FALSE) 7.2 trans_convert The class trans_convert provide several data transformation approaches for the microtable object. The output will also be a microtable object. data(dataset) test1 &lt;- trans_convert$new(dataset = dataset) test2 &lt;- test1$convert(method = &quot;log&quot;) # returned test2 is another microtable object 7.3 trans_netchord The class trans_netchord is developed to sum and plot the links number from one taxa to another or in the same taxa in the network. The input dataset must be a trans_network object. Creating the trans_netchord object can sum the links (edge) number from one taxa to another or in the same taxa. The function plot_sum_links() is used to show the result from the function cal_sum_links(). This is very useful to fast see how many nodes are connected between different taxa or within one taxa. In terms of “Phylum” level in the tutorial, the function cal_sum_links() sum the linkages number from one Phylum to another Phylum or the linkages in the same Phylum. So the numbers along the outside of the circular plot represent how many edges or linkages are related with the Phylum. For example, in terms of Proteobacteria, there are roughly total 900 edges associated with the OTUs in Proteobacteria, in which roughly 200 edges connect both OTUs in Proteobacteria and roughly 150 edges connect the OTUs from Proteobacteria with the OTUs from Chloroflexi. # Let&#39;s first create a network data(sample_info_16S) data(otu_table_16S) data(taxonomy_table_16S) dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, tax_table = taxonomy_table_16S) dataset$tidy_dataset() t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;WGCNA&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001, cor_method = &quot;spearman&quot;) t1$cal_network(p_thres = 0.01, COR_cut = 0.7) # trans_netchord test1 &lt;- trans_netchord$new(dataset = t1, taxa_level = &quot;Phylum&quot;) # require chorddiag package (https://github.com/mattflor/chorddiag) test1$plot_sum_links(plot_pos = TRUE, plot_num = 10) 7.4 trans_ts The class trans_ts is designed for the time series data analysis. A commonly used approach for modeling microbial ecology for time series data is the generalized Lotka-Volterra (gLV) model, the classical predator-prey systems. gLV models are based on ordinary differential equations that model the logistic growth of species; naturally capture predator-prey, amensalistic, and competitive interactions; and have been applied to study dynamics of microbial ecosystems. More importantly, from a practical perspective, gLV models have been used for a range of applications including identifying potential probiotics against pathogens, forecasting changes in microbial density, characterizing important community members (e.g., keystone species), and analyzing community stability (see (Li et al. 2019) and the references therein). Currently, the biomass estimation and biological interaction prediction approaches are implemented based on the beem package (Li et al. 2019). The example data ‘gut_microb_ts’ comes from the article (Gibbons et al. 2017). # R package beem should be first installed; see https://github.com/ChiLiubio/mecodev for installation steps library(mecodev) # load the example data in mecodev package; the input must be a microtable object # There are several strict requirements on the sample_table; see the document of the class. data(&quot;gut_microb_ts&quot;) # generally, using filter_thres to filter the taxa with low abundance is crutial # there are only 22 taxa in the example data, we use 0 t1 &lt;- trans_ts$new(dataset = gut_microb_ts, filter_thres = 0) # we use minimal 50 times for iteration t1$cal_biomass(min_iter = 50) # return t1$res_biomass and t1$res_param # generate the inferred biological network t1$cal_network() # Now let&#39;s use trans_network class to add the modules library(microeco) t2 &lt;- trans_network$new(dataset = gut_microb_ts, cal_cor = NA) t2$res_network &lt;- t1$res_network # use cluster_optimal; as the default cluster_fast_greedy can not be used for the directed network t2$cal_module(method = &quot;cluster_optimal&quot;) plot(t2$res_network) 7.5 trans_gamma The class trans_gamma is developed to explore the relationship between gamma diversity and beta diversity based on the methods from biogeographic studies(Zhang et al. 2020). Currently, the contents include the observed beta-gamma diversity relationship, simulated beta-gamma diversity relationship and the following plotting. If the observed gamma diversity and beta diversity are significantly correlated, species pool at regional scale (or maybe your defined scale, e.g., different treatments in the lab) can have large effect on the beta diversity. Thus, species pool should be first considered to explain beta diversity patterns. This class also provide simulation function to explore the relation between gamma diversity and beta diversity in the absence of any process other than random sampling based on the species log-normal distribution. We use the wetland data to show the observed beta-gamma diversity relationship. library(microeco) library(mecodev) # load the example data data(sample_info_16S) data(otu_table_16S) test &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S) test$tidy_dataset() test$rarefy_samples(sample.size = 10000) # then create trans_gamma object test1 &lt;- trans_gamma$new(dataset = test, group = &quot;Type&quot;, method = &quot;bray&quot;) test1$cal_observed(sample_size = NULL) test1$res_observed # use Spearman correlation test1$plot_observed(cor_method = &quot;spearman&quot;) Let’s simulate the relation between gamma diversity and beta diversity in the absence of any process other than random sampling based on the species log-normal distribution. # if you only run the simulation, dataset parameter is not necessary test1 &lt;- trans_gamma$new(method = &quot;bray&quot;) # use individul numbers at 200, 1000 and 2000, and hypothesize each species pool have 20 samples. test1$cal_simulation(ncom = 20, ind_vect = c(200, 1000, 2000)) test1$plot_simulation(add_fitting = FALSE) References "],["other-examples.html", "Chapter 8 Other examples 8.1 Custom taxa order in bar plot 8.2 The importance of tidy_taxonomy function 8.3 Question of prefix in the taxa 8.4 The use of phylogenetic tree", " Chapter 8 Other examples We encourage users to contribute some unique, special and helpful examples inspired by the microeco, file2meco and mecodev package. 8.1 Custom taxa order in bar plot Jarrod J. Scott contribute a cool answer to the question that how to use custom taxa and the order in bar plot. This is a discussion topic in microeco Discussions part. Here is the link (https://github.com/ChiLiubio/microeco/discussions/45). 8.2 The importance of tidy_taxonomy function The taxonomic classification with standard prefix is very important for some analysis methods, e.g. taxonomic abundance plotting and biomarker finding. The tidy_taxonomy function in microeco package is designed to make the taxa having standard prefix. See those Issues for the detailed examples: (https://github.com/ChiLiubio/microeco/issues/32) and (https://github.com/ChiLiubio/microeco/issues/22). 8.3 Question of prefix in the taxa The prefix of taxa in taxonomic table may affect the following performance of plotting, e.g. text in legend. Please see those Issues (https://github.com/ChiLiubio/microeco/issues/32), (https://github.com/ChiLiubio/microeco/issues/7) and (https://github.com/ChiLiubio/microeco/issues/15). 8.4 The use of phylogenetic tree One of Issues referred to the basic use of phylogenetic tree in the microeco package (https://github.com/ChiLiubio/microeco/issues/33). "],["references.html", "References", " References "]]
