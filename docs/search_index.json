[["index.html", "Tutorial for R microeco package (v0.6.5) Chapter 1 Background", " Tutorial for R microeco package (v0.6.5) Chi Liu, Felipe R. P. Mansoldo, Umer Zeeshan Ijaz, Chenhao Li, Yang Cao, Jarrod J. Scott, Yaoming Cui, Alane B. Vermelho, Minjie Yao, Xiangzhen Li 2022-03-07 Chapter 1 Background R language (R Core Team 2016) and its packages ecosystem are wonderful tools for data analysis. In the field of microbial community ecology, many packages can be used for the data analysis, such as vegan(Oksanen et al. 2019), ape(Paradis and Schliep 2018) and picante(Kembel et al. 2010). However, with the development of the high-throughput sequencing techniques, the increasing data amount and complexity make the data mining a challenge. There have been some R packages created for the statistics and visualization in microbial community ecology, such as phyloseq(Mcmurdie and Holmes 2013), microbiome (https://github.com/microbiome/microbiome), microbiomeSeq (http://www.github.com/umerijaz/microbiomeSeq), ampvis2 (https://madsalbertsen.github.io/ampvis2/reference/index.html), MicrobiomeR(https://github.com/vallenderlab/MicrobiomeR), theseus(Price et al. 2018), rANOMALY(Theil and Rifa 2021), MicrobiomeExplorer(Reeder et al. 2021), tidyMicro(Carpenter et al. 2021), microbial (https://github.com/guokai8/microbial), and so on. However, users still lack a flexible, comprehensive and modularized R package to analyze and manage the data easily. So we created the microeco R package(Liu et al. 2021) for this goal (https://github.com/ChiLiubio/microeco). Besides, we also develop the file2meco package (https://github.com/ChiLiubio/file2meco) for the data input from some famous tools easily and mecodev package (https://github.com/ChiLiubio/mecodev) for some extending approaches in this field. References "],["intro.html", "Chapter 2 Introduction 2.1 R6 Class 2.2 Help 2.3 Dependence 2.4 Plotting", " Chapter 2 Introduction The microeco package has several advantages compared to other packages in R. The main goal of developing this package is to help users analyse communtiy ecology data fast. So a series of commonly-used and cutting-edge approaches are implemented. To facilitate the data mining, the whole structure of microeco package are highly modularized to make users conveniently remember, search and use. It is notable that, beside the demonstration in the tutorial, users can also save the intermediate files in each object and apply those files to other tools according to the format requirement. Main files stored in the objects of microeco package is the commonly used data.frame format. So the intermediate and result files are easily saved, modified and used for other tools in microbial ecology. 2.1 R6 Class All the classes in microeco package depend on the R6 class (Chang 2020). R6 uses the encapsulated object-oriented programming paradigm, which means that R6 is a profoundly different OO system from S3 and S4 because it is built on encapsulated objects, rather than generic functions. If you are interested in the class features, read more from ‘Advanced R’ book (https://adv-r.hadley.nz/). A generic is a regular function, so it lives in the global namespace. An R6 method belongs to an object so it lives in a local namespace. This influences how we think about naming. The methods belong to objects, not generics, and you can call them like object$method(). R6’s reference semantics allow methods to simultaneously return a value and modify an object. Every R6 object has an S3 class that reflects its hierarchy of R6 class. 2.2 Help The use of help documents in the microeco package may be a little different from other packages we often used. If you wish to see one of help documents of functions, you should search the name of the class (not the name of the function) and click the link of each function. # first install microeco, see https://github.com/ChiLiubio/microeco # load package microeco library(microeco) # this can show all the functions and the detailed descriptions in the microtable class # same with: help(microtable) ?microtable 2.3 Dependence 2.3.1 Important packages To keep the start and use of microeco package simplified, the installation of microeco only depend on several packages, which are compulsory-installed from CRAN and frequently used in the data analysis. So the question is that you may encounter an error when using a class or function that invoke an additional package like this: library(microeco) data(dataset) t1 &lt;- trans_network$new(dataset = dataset, cal_cor = NA, taxa_level = &quot;OTU&quot;, filter_thres = 0.0005) t1$cal_network(network_method = &quot;SpiecEasi&quot;) Error in t1$cal_network(network_method = &quot;SpiecEasi&quot;): igraph package not installed ... The reason is that network construction require igraph package. We donot put the igraph and some other packages (e.g. SpiecEasi in github) on the “Imports” part of microeco package. The solutions: install the package when encounter such an error. Actually, it’s very easy to install the packages from CRAN or bioconductor or github. Just try it. install the packages in advance. We recommend this solution if you are interest in most of the methods in the microeco package and want to run a large number of examples in tutorial. We show several packages that are published in CRAN and not installed automatically. Package where description MASS trans_diff class linear discriminant analysis GUniFrac cal_betadiv() UniFrac distance matrix ggpubr plot_alpha() some plotting functions randomForest trans_diff class random forest analysis ggdendro plot_clustering() plotting clustering dendrogram ggrepel trans_rda class reduce the text overlap in the plot agricolae cal_diff() multiple comparisons in anova gridExtra trans_diff class merge plots picante cal_alphadiv() Faith’s phylogenetic alpha diversity pheatmap plot_corr(pheatmap = TRUE) correlation heatmap with clustering dendrogram tidytree trans_diff class plot the taxonomic tree igraph trans_network class network related operations rgexf save_network() save network with gexf style ggalluvial plot_bar(use_alluvium = TRUE) alluvial plot Then, if you want to install these packages or some of them, you can do like this: # If a package is not installed, it will be installed from CRAN. # First select the packages of interest packages &lt;- c(&quot;MASS&quot;, &quot;GUniFrac&quot;, &quot;ggpubr&quot;, &quot;randomForest&quot;, &quot;ggdendro&quot;, &quot;ggrepel&quot;, &quot;agricolae&quot;, &quot;gridExtra&quot;, &quot;picante&quot;, &quot;pheatmap&quot;, &quot;igraph&quot;, &quot;rgexf&quot;, &quot;ggalluvial&quot;, &quot;ggh4x&quot;) # Now check or install for(x in packages){ if(!require(x, character.only = TRUE)) { install.packages(x, dependencies = TRUE) } } There are also some packages that are useful in some functions. These packages may be R packages published in bioconductor or github, or packages written by other languages. 2.3.2 ggtree Plotting the cladogram from LEfSe result requires the ggtree package in bioconductor (https://bioconductor.org/packages/release/bioc/html/ggtree.html). if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;ggtree&quot;) 2.3.3 SpiecEasi The R package SpiecEasi can be used for the network construction using SPIEC-EASI (SParse InversE Covariance Estimation for Ecological Association Inference) approach. The package can be installed from Github https://github.com/zdk123/SpiecEasi 2.3.4 Gephi Gephi is an excellent network visualization tool and used to open the saved network file, i.e. network.gexf in the tutorial. You can download Gephi and learn how to use it from https://gephi.org/users/download/ 2.3.5 WGCNA In the correlation-based network, when the species number is very large, the correlation algorithm in WGCNA is very fast compared to the ‘cor’ option in trans_network. install.packages(&quot;WGCNA&quot;, dependencies = TRUE) 2.3.6 Tax4Fun Tax4Fun is an R package used for the prediction of functional potential of prokaryotic communities. install Tax4Fun package install.packages(&quot;RJSONIO&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;biom_0.3.12.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;qiimer_0.9.4.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;Tax4Fun_0.3.1.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) download SILVA123 reference data from http://tax4fun.gobics.de/ unzip SILVA123.zip and provide this path to the folderReferenceData parameter of cal_tax4fun function in trans_func class. 2.3.7 Tax4Fun2 Tax4Fun2 is another R package for the the prediction of functional profiles and functional gene redundancies of prokaryotic communities (Wemheuer et al. 2020). It has higher accuracies than PICRUSt and Tax4Fun. The Tax4Fun2 approach implemented in microeco is a little different from the original package. Using Tax4Fun2 approach require the representative fasta file. The user do not need to install Tax4Fun2 R package. The only thing need to do is to download the blast tool (ignore this if the blast tool has been in the path) and Ref99NR/Ref100NR database (select one). Downlaod blast tools from “ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+” ; e.g. ncbi-blast-****-x64-win64.tar.gz for windows system. Note that some errors can come from the latest versions because of memory issue (https://www.biostars.org/p/413294/). An easy solution is to use previous version (such as 2.5.0). Downlaod Ref99NR.zip from “https://cloudstor.aarnet.edu.au/plus/s/DkoZIyZpMNbrzSw/download” or Ref100NR.zip from “https://cloudstor.aarnet.edu.au/plus/s/jIByczak9ZAFUB4/download” . Uncompress all the folders. The final folders should be like these structures: blast tools: |– ncbi-blast-2.5.0+ |—- bin |—— blastn.exe |—— makeblastdb.exe |—— …… Ref99NR: |– Tax4Fun2_ReferenceData_v2 |—- Ref99NR |—— otu000001.tbl.gz |—— …… |—— Ref99NR.fasta |—— Ref99NR.tre The path “Tax4Fun2_ReferenceData_v2” will be required in the trans_func$cal_tax4fun2() function. The blast tool path “ncbi-blast-2.5.0+/bin” is also required if it is not added to the path (environmental variable). # Either seqinr or Biostrings package should be installed for reading and writing fasta file install.packages(&quot;seqinr&quot;, dependencies = TRUE) # or install Biostrings from bioconductor https://bioconductor.org/packages/release/bioc/html/Biostrings.html # Now we show how to read the fasta file # see https://github.com/ChiLiubio/file2meco if you do not have installed file2meco rep_fasta_path &lt;- system.file(&quot;extdata&quot;, &quot;rep.fna&quot;, package=&quot;file2meco&quot;) rep_fasta &lt;- seqinr::read.fasta(rep_fasta_path) # or use Biostrings::readDNAStringSet(rep_fasta_path) # then see the help document of microtable class about the rep_fasta in microtable$new(). 2.4 Plotting Most of the plotting in the package rely on the ggplot2 package system. We provide some parameters to change the corresponding plot, but it may be far from enough. The user can also assign the output a name and use the ggplot2-style grammers to modify it. Each data table used for plotting is stored in the object and can be saved for the customized analysis and plotting. Of course, the user can also directly modify the class and reload them to use. Any contribution of a modified class is also appreciated via github pushing or email (liuchi0426@126.com). References "],["basic-class.html", "Chapter 3 Basic class 3.1 microtable class", " Chapter 3 Basic class The microtable class is the basic class. All the other classes depend on the microtable class. 3.1 microtable class Many tools can be used for the bioinformatic analysis of amplicon sequencing data, such as QIIME (Caporaso et al. 2010), QIIME2 (Bolyen et al. 2019), usearch (https://www.drive5.com/usearch/), mothur (Schloss et al. 2009), SILVAngs (https://ngs.arb-silva.de/silvangs/), and RDP (http://rdp.cme.msu.edu/). Although the formats of results may be distinctive across various tools, the main files can be generally classified into the following parts: (1) OTU/ASV table, i.e. the species-sample abundance table; (2) taxonomy table, the taxonomic assignment table; (3) representative sequences; (4) phylogenetic tree; (5) metadata. It is generally useful to create a detailed sample information table to store all the sample information, including the environmental data. The microtable class is the basic class and designed to store the basic data for all the downstream analysis in the microeco package. At least, the OTU table (i.e. species-sample abundance table) should be provided to create microtable object. Thus, the microtable class can recognize the sample information table is missing and create a default sample table according to the sample names in otu_table. To make the file reading more convenient, we also build another R package file2meco (https://github.com/ChiLiubio/file2meco) to read the output files of some tools into microtable object. Currently, those tools/softwares include not only commonly-used QIIME (Caporaso et al. 2010) and QIIME2(Bolyen et al. 2019), but also some metagenomic tools, such as HUMAnN (Franzosa et al. 2018) and kraken2 (Wood, Lu, and Langmead 2019). In this tutorial, we use the data inside the package microeco to show some operations. 3.1.1 Example The 16S rRNA gene sequencing results in the example data of the package is used to show the main part of the tutorial. This dataset is the 16S rRNA gene Miseq sequencing results of wetland soils in China published by An et al.(An et al. 2019), who surveyed soil bacterial communities in Chinese inland wetlands (IW), coastal wetland (CW) and Tibet plateau wetlands (TW) using amplicon sequencing. These wetlands include both saline and non-saline samples. The sample information table have 4 columns: “SampleID,” “Group,” “Type” and “Saline.” The column “SampleID” is same with the rownames. The column “Group” represents the IW, CW and TW. The column “Type” represents the sampling region: northeastern region (NE), northwest region (NW), North China area (NC), middle-lower reaches of the Yangtze River (YML), southern coastal area (SC), upper reaches of the Yangtze River (YU), Qinghai-Tibet Plateau (QTP). The column “Saline” represents the saline soils and non-saline soils. In this dataset, the environmental factor table is separated from the sample information table. library(microeco) # load the example data; 16S rRNA gene amplicon sequencing dataset data(sample_info_16S) data(otu_table_16S) data(taxonomy_table_16S) # we will use phylogenetic tree to calculate phylogeny-based alpha and beta metrics data(phylo_tree_16S) # load the environmental data which is detached from sample table data(env_data_16S) # use pipe operator in magrittr package library(magrittr) # set.seed is used to fix the random number generation to make the results repeatable set.seed(123) # make the plotting background same with the tutorial library(ggplot2) theme_set(theme_bw()) Make sure that the data types of sample_table, otu_table and tax_table are all data.frame as the following part shows. class(otu_table_16S) ## [1] &quot;data.frame&quot; otu_table_16S[1:5, 1:5]   S1 S2 S3 S4 S5 OTU_4272 1 0 1 1 0 OTU_236 1 4 0 2 35 OTU_399 9 2 2 4 4 OTU_1556 5 18 7 3 2 OTU_32 83 9 19 8 102 class(taxonomy_table_16S) ## [1] &quot;data.frame&quot; taxonomy_table_16S[1:5, 1:3]   Kingdom Phylum Class OTU_4272 k__Bacteria p__Firmicutes c__Bacilli OTU_236 k__Bacteria p__Chloroflexi c__ OTU_399 k__Bacteria p__Proteobacteria c__Betaproteobacteria OTU_1556 k__Bacteria p__Acidobacteria c__Acidobacteria OTU_32 k__Archaea p__Miscellaneous Crenarchaeotic Group c__ Sometimes, your taxonomic table may have some chaotic information, such as NA, unidentified and unknown. These information can potentially influence the following taxonomic abundance calculation and other taxonomy-based analysis. So it is generally necessary to clean this file using the tidy_taxonomy function. Another very important result of this operation is to unify the taxonomic prefix automatically, e.g. transforming D_1__ to p__ for phylum level or adding p__ to phylum directly. # make the taxonomic information unified, very important taxonomy_table_16S %&lt;&gt;% tidy_taxonomy The rownames of sample_table in microtable object (i.e. sample names) are used for selecting samples/groups in all the related operations in the package. Before creating microtable object, make sure that the rownames of sample information table are sample names. class(sample_info_16S) ## [1] &quot;data.frame&quot; sample_info_16S[1:5, ]   SampleID Group Type Saline S1 S1 IW NE Non-saline soil S2 S2 IW NE Non-saline soil S3 S3 IW NE Non-saline soil S4 S4 IW NE Non-saline soil S5 S5 IW NE Non-saline soil In this example, the environmental data is stored in the env_data_16S alone. The user can also directly integrate those data into the sample information table. class(env_data_16S) ## [1] &quot;data.frame&quot;   Latitude Longitude Altitude Temperature Precipitation S1 52.96 122.6 432 -4.2 445 S2 52.95 122.6 445 -4.3 449 S3 52.95 122.6 430 -4.3 449 S4 52.95 122.6 430 -4.3 449 S5 52.95 122.6 429 -4.3 449 class(phylo_tree_16S) ## [1] &quot;phylo&quot; Then, we create an object of microtable class. This operation is very similar with the package phyloseq(Mcmurdie and Holmes 2013), but microeco is more brief. The otu_table in the microtable class must be the species-sample format: rownames - OTU names; colnames - sample names. The colnames in otu_table must have overlap with rownames of sample_table. Otherwise, the following check can filter all the samples of otu_table because of no same sample names between otu_table and sample_table. # In R6 class, &#39;$new&#39; is the original method used to create a new object of class # If you only provide abundance table, the class can help you create a sample info table dataset &lt;- microtable$new(otu_table = otu_table_16S) ## No sample_table provided, automatically use colnames in otu_table to create one ... class(dataset) ## [1] &quot;microtable&quot; &quot;R6&quot; # generally add the metadata dataset &lt;- microtable$new(otu_table = otu_table_16S, sample_table = sample_info_16S) dataset ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns # Let&#39;s create a microtable object with more information dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, tax_table = taxonomy_table_16S, phylo_tree = phylo_tree_16S) dataset ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13628 rows and 7 columns ## phylo_tree have 14096 tips If the users want to know more details on microtable class, please see the help document of the class using the following help command. For example, see the phylo_tree parameter of microtable$new() for reading phylogenetic tree. # search the class name, not the function name ?microtable Then, we remove OTUs which are not assigned in the Kingdom \"k__Archaea\" or \"k__Bacteria\". dataset$tax_table %&lt;&gt;% base::subset(Kingdom == &quot;k__Archaea&quot; | Kingdom == &quot;k__Bacteria&quot;) dataset ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13330 rows and 7 columns ## phylo_tree have 14096 tips We also remove OTUs with the taxonomic assignments “mitochondria” or “chloroplast.” # This will remove the lines containing the taxa word regardless of taxonomic ranks and ignoring word case in the tax_table. # So if you want to filter some taxa not considerd pollutions, please use subset like the previous operation to filter tax_table. dataset$filter_pollution(taxa = c(&quot;mitochondria&quot;, &quot;chloroplast&quot;)) ## Total 34 taxa are removed from tax_table ... print(dataset) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13296 rows and 7 columns ## phylo_tree have 14096 tips To make the OTU and sample information consistent across all files in the dataset object, we use function tidy_dataset to trim the dataset. dataset$tidy_dataset() print(dataset) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 13296 rows and 90 columns ## tax_table have 13296 rows and 7 columns ## phylo_tree have 13296 tips Then we use sample_sums() to check the sequence numbers in each sample. dataset$sample_sums() %&gt;% range ## [1] 10316 37087 Sometimes, in order to reduce the effects of sequencing depth on the diversity measurements, it is optional perform the resampling to make the sequence number equal for each sample. The function rarefy_samples can invoke the function tidy_dataset automatically before and after the rarefying. # As an example, we use 10000 sequences in each sample dataset$rarefy_samples(sample.size = 10000) ## 530 OTUs were removed because they are no longer present in any sample after random subsampling ... ## 530 taxa are removed from the otu_table, as the abundance is 0 ... dataset$sample_sums() %&gt;% range ## [1] 10000 10000 Then, we can calculate the taxa abundance at each taxonomic rank using cal_abund(). This function return a list called taxa_abund stored in the microtable object. This list contain several data frame of the abundance information at each taxonomic rank. It’s worth noting that the cal_abund() function can be used to solve more complicated cases with special parameters, such as supporting both the relative and absolute abundance calculation and selecting the partial ‘taxonomic’ columns. Those have been shown in README of file2meco package (https://github.com/ChiLiubio/file2meco) with complex metagenomic dataset. # use default parameters dataset$cal_abund() ## The result is stored in object$taxa_abund ... # return dataset$taxa_abund class(dataset$taxa_abund) ## [1] &quot;list&quot; # show part of the relative abundance at Phylum level dataset$taxa_abund$Phylum[1:5, 1:5]   S1 S2 S3 S4 S5 **k__Bacteria|p__Proteobacteria** 0.2008 0.1996 0.2151 0.261 0.1663 **k__Bacteria|p__Chloroflexi** 0.1215 0.1937 0.1588 0.1471 0.3098 **k__Bacteria|p__Bacteroidetes** 0.1816 0.0359 0.0267 0.0215 0.0266 **k__Bacteria|p__Acidobacteria** 0.1215 0.2467 0.2532 0.262 0.2482 **k__Bacteria|p__Actinobacteria** 0.1182 0.0861 0.0875 0.0954 0.0824 The function save_abund() can be used to save the taxa abundance file to a local place easily. dataset$save_abund(dirpath = &quot;taxa_abund&quot;) Then, let’s calculate the alpha diversity. The result is also stored in the object microtable automatically. For the definition of each alpha diversity index, please see http://scikit-bio.org/docs/latest/generated/skbio.diversity.alpha.html As an example, we do not calculate phylogenetic diversity. # If you want to add Faith&#39;s phylogenetic diversity, use PD = TRUE, this will be a little slow dataset$cal_alphadiv(PD = FALSE) ## The result is stored in object$alpha_diversity ... # return dataset$alpha_diversity class(dataset$alpha_diversity) ## [1] &quot;data.frame&quot; # save dataset$alpha_diversity to a directory dataset$save_alphadiv(dirpath = &quot;alpha_diversity&quot;) Let’s go on to beta diversity with function cal_betadiv(). We provide four most frequently used indexes: Bray-curtis, Jaccard, weighted Unifrac and unweighted unifrac. # If you do not want to calculate unifrac metrics, use unifrac = FALSE # require GUniFrac package installed dataset$cal_betadiv(unifrac = TRUE) # return dataset$beta_diversity class(dataset$beta_diversity) # save dataset$beta_diversity to a directory dataset$save_betadiv(dirpath = &quot;beta_diversity&quot;) 3.1.2 Key points sample_table: rownames of sample_table must be sample names used otu_table: rownames must be feature names; colnames must be sample names microtable class: creating microtable object requires at least one file input (otu_table) tidy_taxonomy(): necessary to make taxonomic table have unified format tidy_dataset(): necessary to clean files in microtable object cal_abund(): powerful and flexible to cope with complex cases in tax_table, see the parameters taxa_abund: taxa_abund is a list stored in microtable object and have several data frame beta_diversity: beta_diversity is also a list stored in microtable object and have several distance matrix 3.1.3 Other functions add_rownames2taxonomy(): add the rownames of tax_table as the last column of tax_table directly; very useful in some analysis, e.g. OTU/ASV biomarker finding. taxa_sums(): sum the abundance for each taxa; very useful for taxa abundance checking and filtering merge_samples(): merge samples according to a specific group of sample_table to generate a new microtable object merge_taxa(): merge taxa according to a specific taxonomic rank level of tax_table to generate a new microtable object rename_taxa(): rename the OTU/ASV names in all the files of microtable object sample_names(): output sample names in microtable object taxa_names(): output taxa names in microtable object References "],["composition-based-class.html", "Chapter 4 Composition-based class 4.1 trans_abund class 4.2 trans_venn class", " Chapter 4 Composition-based class The trans_abund class and trans_venn class are grouped into ‘Composition-based class,’ as they mainly show the composition information of communities. 4.1 trans_abund class The trans_abund class is used to transform taxonomic abundance data to plots with the ggplot2 package. As a premise, the taxa_abund list in the object of microtable class must be first calculated. 4.1.1 Example We first show the bar plot example. # create trans_abund object # use 10 Phyla with the highest abundance in the dataset. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10) # t1 object now include the transformed abundance data t1$abund_data and other elements for the following plotting As the sample number is large, we do not show the sample names in x axis and add the facet to show abundance according to groups. t1$plot_bar(others_color = &quot;grey70&quot;, facet = &quot;Group&quot;, xtext_keep = FALSE, legend_text_italic = FALSE) # return a ggplot2 object # two facets example # require package ggh4x, please run install.packages(&quot;ggh4x&quot;) if not installed t1$plot_bar(others_color = &quot;grey70&quot;, facet = &quot;Group&quot;, facet2 = &quot;Type&quot;, xtext_keep = FALSE, legend_text_italic = FALSE, barwidth = 1) The alluvial plot is also implemented in the plot_bar function with use_alluvium parameter. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Genus&quot;, ntaxa = 8) # require ggalluvial package # use_alluvium = TRUE make the alluvial plot, clustering =TRUE can be used to reorder the samples by clustering # select another color palette t1$plot_bar(use_alluvium = TRUE, clustering = TRUE, xtext_type_hor = FALSE, xtext_size = 6, use_colors = RColorBrewer::brewer.pal(8, &quot;Set2&quot;)) The bar plot can also be performed with group mean values. # The groupmean parameter can be used to obtain the group-mean barplot. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) g1 &lt;- t1$plot_bar(others_color = &quot;grey70&quot;, legend_text_italic = FALSE) g1 + theme_classic() + theme(axis.title.y = element_text(size = 18)) The box plot is an excellent way to intuitionally show data distribution across groups. # show 15 taxa at Class level t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Class&quot;, ntaxa = 15) t1$plot_box(group = &quot;Group&quot;) Then we show the heatmap with the high abundant genera. # show 40 taxa at Genus level t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Genus&quot;, ntaxa = 40) t1$plot_heatmap(facet = &quot;Group&quot;, xtext_keep = FALSE, withmargin = FALSE) Then, we show the pie chart with the group mean values. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 6, groupmean = &quot;Group&quot;) # all pie chart in one row t1$plot_pie(facet_nrow = 1) 4.1.2 Key points trans_abund$new: creating trans_abund object can invoke taxa_abund in microtable for transformation use_colors parameter: use_colors parameter in each function is used for colors selection input_taxaname parameter: input_taxaname parameter in trans_abund$new can be used to select interested customized taxa instead of abundance-based selection use_percentage parameter: use_percentage parameter in trans_abund$new - whether show the abundance percentage 4.2 trans_venn class The trans_venn class is used for venn analysis, i.e. shared and unique taxa. 4.2.1 Example This part can be performed using samples or groups at OTU/ASV level or higher taxonomic level. To analyze the unique and shared OTUs of groups, we first merge samples according to the “Group” column of sample_table. # merge samples as one community for each group dataset1 &lt;- dataset$merge_samples(use_group = &quot;Group&quot;) # dataset1 is a new microtable object # create trans_venn object t1 &lt;- trans_venn$new(dataset1, ratio = NULL) t1$plot_venn() # create venn plot with more information t1 &lt;- trans_venn$new(dataset1, ratio = &quot;seqratio&quot;) t1$plot_venn() # The integer is OTU number # The percentage data is the sequence number/total sequence number When the groups are too many to show with venn plot, using petal plot is better. # use &quot;Type&quot; column in sample_table dataset1 &lt;- dataset$merge_samples(use_group = &quot;Type&quot;) t1 &lt;- trans_venn$new(dataset1) t1$plot_venn(petal_plot = TRUE, petal_center_size = 50, petal_r = 1.5, petal_a = 3, petal_move_xy = 3.8, petal_color_center = &quot;#BEBADA&quot;) Generally, after getting the venn plot, we do not know what those shared or unique taxa are. The composition of the unique or shared species may account for the different and similar parts of ecological characteristics across groups(Mendes et al. 2011). So, it is interesting to further analyze the composition of unique and shared species. For this goal, we first transform the results of venn plot to the traditional species-sample table, that is, another object of microtable class. dataset1 &lt;- dataset$merge_samples(use_group = &quot;Group&quot;) t1 &lt;- trans_venn$new(dataset1) ## The result is stored in object$venn_table and object$venn_count_abund ... # transform venn results to the sample-species table, here do not consider abundance, only use presence/absence. t2 &lt;- t1$trans_venn_com(use_OTUs_frequency = TRUE) # t2 is a new microtable class, each part is considered a sample class(t2) ## [1] &quot;microtable&quot; &quot;R6&quot; We use bar plot to show the composition at the Genus level. # calculate taxa abundance, that is, the frequency t2$cal_abund() # transform and plot t3 &lt;- trans_abund$new(dataset = t2, taxrank = &quot;Genus&quot;, ntaxa = 8) t3$plot_bar(bar_type = &quot;part&quot;, legend_text_italic = T, ylab_title = &quot;Frequency (%)&quot;, xtext_type_hor = FALSE, use_colors = RColorBrewer::brewer.pal(8, &quot;Set2&quot;), order_x = c(&quot;IW&quot;, &quot;CW&quot;, &quot;TW&quot;, &quot;IW-CW&quot;, &quot;IW-TW&quot;, &quot;CW-TW&quot;, &quot;IW-CW-TW&quot;)) We also try to use pie chart to show the compositions at the Phylum level. t3 &lt;- trans_abund$new(dataset = t2, taxrank = &quot;Phylum&quot;, ntaxa = 8) t3$plot_pie(facet_nrow = 3, use_colors = rev(c(RColorBrewer::brewer.pal(8, &quot;Dark2&quot;), &quot;grey50&quot;))) 4.2.2 Key points ratio parameter: ratio parameter in trans_abund$new control whether and what content appear under the taxa number in venn plot returned data: using trans_venn$new() return venn_table and venn_count_abund stored in trans_venn object for further ploting References "],["diversity-based-class.html", "Chapter 5 Diversity-based class 5.1 trans_alpha class 5.2 trans_beta class", " Chapter 5 Diversity-based class Diversity is one of the core topics in community ecology. It refers to alpha diversity, beta diversity and gamma diversity. 5.1 trans_alpha class Alpha diversity can be transformed and plotted using trans_alpha class. Creating the object of trans_alpha class can invoke the alpha_diversity data stored in the microtable object. 5.1.1 Example The trans_alpha object have two data frame: alpha_data and alpha_stat. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) # return t1$alpha_stat t1$alpha_stat[1:5, ] ## The group statistics are stored in object$alpha_stat ... ## The transformed diversity data is stored in object$alpha_data ... Group Measure N Mean SD SE CW Observed 30 1843 220.6 40.27 CW Chao1 30 2553 338.1 61.73 CW ACE 30 2716 367 67.01 CW Shannon 30 6.308 0.5355 0.09777 CW Simpson 30 0.9897 0.01305 0.002382 Then, we test the differences among groups using the KW rank sum test and anova with multiple comparisons. t1$cal_diff(method = &quot;KW&quot;) # return t1$res_alpha_diff t1$res_alpha_diff[1:5, ] ## The result is stored in object$res_alpha_diff ... Groups Measure Test method p.value Significance IW vs CW Observed KW 0.0371 * IW vs TW Observed KW 0.4553 CW vs TW Observed KW 0.3912 IW vs CW vs TW Observed KW 0.155 IW vs CW Chao1 KW 0.002689 ** t1$cal_diff(method = &quot;anova&quot;) # return t1$res_alpha_diff t1$res_alpha_diff ## Registered S3 methods overwritten by &#39;klaR&#39;: ## method from ## predict.rda vegan ## print.rda vegan ## plot.rda vegan ## The result is stored in object$res_alpha_diff ...   Observed Chao1 ACE Shannon Simpson InvSimpson Fisher Coverage IW a a a a a a a b TW a ab b a a a a a CW a b b a a a a a Now, let us plot the mean and se of alpha diversity for each group, and add the duncan.test (agricolae package) result. t1$plot_alpha(add_letter = T, measure = &quot;Chao1&quot;, use_boxplot = FALSE) We can also use the boxplot to show the paired comparisons directly. t1$plot_alpha(pair_compare = TRUE, measure = &quot;Chao1&quot;, shape = &quot;Group&quot;) The multi-factor analysis of variance is also supported. It is notable that the result res_alpha_diff will be a list instead of a data.frame. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) t1$cal_diff(method = &quot;anova&quot;, anova_set = &quot;Group+Type&quot;) # now the result t1$res_alpha_diff is a list # see the help document for the usage of anova_set 5.1.2 Key points trans_alpha$new: creating trans_alpha object can invoke alpha_diversity in microtable for transformation cal_diff: anova_set parameter can be used for multi-factor analysis of variance 5.2 trans_beta class The trans_beta class is developed for the beta diversity analysis, i.e. the dissimilarities among samples. As beta diversity can be defined at different forms(Tuomisto 2010) and can be explored with different ways(Anderson et al. 2011), So we encapsulate some commonly-used approaches according to the research of microbial community ecology(Ramette 2007). Note that the parts related with “Environmental interpretation” are placed into the trans_env class. When needed, the beta_diversity list in microtable object will be invoked for transformation and ploting using trans_beta class. The analysis referred to the beta diversity in this class mainly include ordination, group distance, clustering and manova. 5.2.1 Example We first show the ordination using PCoA. # we first create an trans_beta object # measure parameter can invoke the distance matrix of bray in dataset$beta_diversity t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) # use PCoA as an example, PCA or NMDS is also available t1$cal_ordination(ordination = &quot;PCoA&quot;) # t1$res_ordination is the ordination result list class(t1$res_ordination) # plot the PCoA result t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_group_ellipse = TRUE) Then we plot and compare the group distances. # calculate and plot sample distances within groups t1$cal_group_distance() # return t1$res_group_distance t1$plot_group_distance(distance_pair_stat = TRUE) # calculate and plot sample distances between groups t1$cal_group_distance(within_group = FALSE) t1$plot_group_distance(distance_pair_stat = TRUE) Clustering plot is also a frequently used method. # use replace_name to set the label name, group parameter used to set the color t1$plot_clustering(group = &quot;Group&quot;, replace_name = c(&quot;Saline&quot;, &quot;Type&quot;)) perMANOVA(Anderson 2001) is often used in the differential test of distances among groups. # manova for all groups t1$cal_manova(cal_manova_all = TRUE) t1$res_manova$aov.tab ## The result is stored in object$res_manova ... Permutation: free   Df SumsOfSqs MeanSqs F.Model R2 Pr(&gt;F) Group 2 6.121 3.06 10.57 0.1955 0.001 Residuals 87 25.18 0.2895 NA 0.8045 NA Total 89 31.3 NA NA 1 NA # manova for each paired groups t1$cal_manova(cal_manova_paired = TRUE) t1$res_manova ## The result is stored in object$res_manova ... Groups measure permutations R2 p.value Significance IW vs CW bray 999 0.1595 0.001 *** IW vs TW bray 999 0.147 0.001 *** CW vs TW bray 999 0.1556 0.001 *** # manova for specified group set: here &quot;Group + Type&quot; t1$cal_manova(cal_manova_set = &quot;Group + Type&quot;) t1$res_manova$aov.tab ## The result is stored in object$res_manova ... Permutation: free   Df SumsOfSqs MeanSqs F.Model R2 Pr(&gt;F) Group 2 6.121 3.06 12.01 0.1955 0.001 Type 3 3.783 1.261 4.949 0.1208 0.001 Residuals 84 21.4 0.2548 NA 0.6836 NA Total 89 31.3 NA NA 1 NA PERMDISP(Anderson et al. 2011) is also implemented to check multivariate homogeneity of groups dispersions (variances). # PERMDISP for the whole comparison and for each paired groups t1$cal_betadisper() ## The result is stored in object$res_betadisper ... t1$res_betadisper ## ## Permutation test for homogeneity of multivariate dispersions ## Permutation: free ## Number of permutations: 999 ## ## Response: Distances ## Df Sum Sq Mean Sq F N.Perm Pr(&gt;F) ## Groups 2 0.04131 0.0206545 4.1682 999 0.021 * ## Residuals 87 0.43110 0.0049552 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Pairwise comparisons: ## (Observed p-value below diagonal, permuted p-value above diagonal) ## CW IW TW ## CW 0.4690000 0.063 ## IW 0.4621193 0.005 ## TW 0.0566190 0.0050319 5.2.2 Key points trans_beta$new: creating trans_beta object with measure parameter can invoke beta_diversity in microtable object for transformation cal_ordination(): PCoA, PCA and NMDS approaches are all available cal_manova(): cal_manova function can be used for paired comparisons, holistic test and multi-factor test plot_group_distance(): hide_ns and pair_compare_filter_select parameters can be used to control the significance labels shown in the plot References "],["model-based-class.html", "Chapter 6 Model-based class 6.1 trans_diff class 6.2 trans_network class 6.3 trans_nullmodel class", " Chapter 6 Model-based class We group all the classes with complex models into the type ‘Model-based class.’ 6.1 trans_diff class Differential abundance test is a very important part in the microbial community data analysis. It can be used to find the significant taxa in determining the community differences across groups. With the field development, there are some combined methods to better capture the important biomarker information. Currently, trans_diff class have four famous approaches to perform this analysis: metastat(White, Nagarajan, and Pop 2009), LEfSe(Segata et al. 2011), random forest and metagenomeSeq(Paulson et al. 2013). Metastat depends on the permutations and t-test and performs well on the sparse data. It is used for the comparisons of taxonomic abundance between two groups at any taxonomic level. LEfSe and random forest in this class is mainly used for the identification of biomarkers at all taxonomic levels. metagenomeSeq method is implemented to find significant species between two groups at species level (OTU/ASV). 6.1.1 Example Let’s first run metastat example. # metastat analysis at Genus level t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;metastat&quot;, group = &quot;Group&quot;, metastat_taxa_level = &quot;Genus&quot;) # t1$res_metastat is the result # t1$res_metastat_group_matrix is the group comparisons order for plotting # plot the first paired groups, choose_group = 1 t1$plot_metastat(use_number = 1:10, qvalue = 0.05, choose_group = 1) LEfSe combines the non-parametric test and linear discriminant analysis (Segata et al. 2011). t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;lefse&quot;, group = &quot;Group&quot;, alpha = 0.01, lefse_subgroup = NULL) # t1$res_lefse is the LEfSe result # t1$res_abund is the abundance information t1$plot_lefse_bar(LDA_score = 4) t1$res_lefse[1:5, ] Taxa Group pvalue LDA k__Bacteria|p__Proteobacteria CW 3.21e-11 4.834 k__Bacteria|p__Acidobacteria|c__Acidobacteria IW 8.559e-13 4.787 k__Bacteria|p__Acidobacteria IW 5.749e-12 4.785 k__Bacteria|p__Bacteroidetes TW 1.19e-09 4.776 k__Bacteria|p__Proteobacteria|c__Gammaproteobacteria CW 5.475e-12 4.613 Then, we plot the abundance of biomarkers detected by LEfSe. t1$plot_diff_abund(use_number = 1:30) Then, we show the cladogram of the differential features in the taxonomic tree. There are too many taxa in this dataset. As an example, we only use the highest 200 abundant taxa in the tree and 50 differential features. We only show the full taxonomic label at Phylum level and use letters at other levels to reduce the text overlap. # clade_label_level 5 represent phylum level in this analysis # require ggtree package t1$plot_lefse_cladogram(use_taxa_num = 200, use_feature_num = 50, clade_label_level = 5) There may be a problem related with the taxonomic labels in the plot. When the levels used are too many, the taxonomic labels may have too much overlap. However, if you only indicate the Phylum labels, the taxa in the legend with marked letters are too many. At this time, you can select the taxa that you want to show in the plot manually like the following operation. # choose some taxa according to the positions in the previous picture; those taxa labels have minimum overlap use_labels &lt;- c(&quot;c__Deltaproteobacteria&quot;, &quot;c__Actinobacteria&quot;, &quot;o__Rhizobiales&quot;, &quot;p__Proteobacteria&quot;, &quot;p__Bacteroidetes&quot;, &quot;o__Micrococcales&quot;, &quot;p__Acidobacteria&quot;, &quot;p__Verrucomicrobia&quot;, &quot;p__Firmicutes&quot;, &quot;p__Chloroflexi&quot;, &quot;c__Acidobacteria&quot;, &quot;c__Gammaproteobacteria&quot;, &quot;c__Betaproteobacteria&quot;, &quot;c__KD4-96&quot;, &quot;c__Bacilli&quot;, &quot;o__Gemmatimonadales&quot;, &quot;f__Gemmatimonadaceae&quot;, &quot;o__Bacillales&quot;, &quot;o__Rhodobacterales&quot;) # then use parameter select_show_labels to show t1$plot_lefse_cladogram(use_taxa_num = 200, use_feature_num = 50, select_show_labels = use_labels) # Now we can see that more taxa names appear in the tree If you are interested in taxonomic tree, you can also use metacoder package(Foster, Sharpton, and Grunwald 2017) to plot the taxonomic tree based on the selected taxa. We do not show the usage here. The third approach is rf, which depends on the random forest(Beck and Foster 2014; Yatsunenko et al. 2012) and the non-parametric test. The current method can calculate random forest by bootstrapping like the method in LEfSe and only use the significant features. MeanDecreaseGini is selected as the indicator value in the analysis. # use Genus level for parameter rf_taxa_level, if you want to use all taxa, change to &quot;all&quot; # nresam = 1 and boots = 1 represent no bootstrapping and use all samples directly t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;rf&quot;, group = &quot;Group&quot;, rf_taxa_level = &quot;Genus&quot;) # t1$res_rf is the result stored in the object # plot the result t2 &lt;- t1$plot_diff_abund(use_number = 1:20, only_abund_plot = FALSE) gridExtra::grid.arrange(t2$p1, t2$p2, ncol=2, nrow = 1, widths = c(2,2)) # the middle asterisk represent the significances 6.1.2 Key points trans_diff$new: this class have a strict requirement on the taxonomic information, make sure tidy_taxonomy() function has been performed before the analysis trans_diff$new: creating this class will invoke taxa_abund stored in microtable object 6.2 trans_network class Network is a frequently used approach to study the co-occurrence patterns in microbial ecology (Deng et al. 2012; Faust and Raes 2012; Coyte, Schluter, and Foster 2015). In this part, we describe all the core contents in the trans_network class. The network construction approaches can be classified into two types: correlation-based and non correlation-based. Several approaches can be used to calculate correlations and significances. 6.2.1 Example We first introduce the correlation-based network. The parameter cal_cor in trans_network is used for selecting the correlation calculation method. # Use R base cor.test, a little slow t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;base&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001, cor_method = &quot;spearman&quot;) # return t1$res_cor_p list; one table: correlation; another: p value # SparCC method, require SpiecEasi package, see https://chiliubio.github.io/microeco_tutorial/intro.html#spieceasi for the installation # SparCC is very slow, so consider filtering more species with low abundance t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;SparCC&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.001, SparCC_simu_num = 100) # When the OTU number is large, using R WGCNA package to replace &quot;base&quot; will be faster # require WGCNA package, see https://chiliubio.github.io/microeco_tutorial/intro.html#wgcna for the installation t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;WGCNA&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001, cor_method = &quot;spearman&quot;) The parameter COR_cut can be used to select the correlation threshold. Furthermore, COR_optimization = TRUE represent using RMT theory to find the optimized correlation threshold instead of the COR_cut(Deng et al. 2012). # construct network; require igraph package t1$cal_network(p_thres = 0.01, COR_optimization = TRUE) # return t1$res_network # use arbitrary coefficient threshold to contruct network t1$cal_network(p_thres = 0.01, COR_cut = 0.7) # add modules in the network t1$cal_module() # save network # open the gexf file using Gephi(https://gephi.org/) # require rgexf package t1$save_network(filepath = &quot;network.gexf&quot;) We plot the network and present the node colors according to the calculated modules in Gephi. Now, we show the node colors with the Phylum information and the edges colors with the positive and negative correlations. All the data used has been stored in the network.gexf file, including modules classifications, Phylum information and edges classifications. # calculate network attributes t1$cal_network_attr() # return t1$res_network_attr Property Value Vertex 407 Edge 1989 Average_degree 9.774 Average_path_length 3.878 Network_diameter 9 Clustering_coefficient 0.4698 Density 0.02407 Heterogeneity 1.194 Centralization 0.09908 # classify the node; return t1$res_node_type t1$cal_node_type() # return t1$res_node_type # we retain the file for the following example in trans_func part network_node_type &lt;- t1$res_node_type   z module p taxa_roles OTU_50 -1.305 M2 0 Peripheral nodes OTU_1 -0.04067 M2 0 Peripheral nodes OTU_55 -1.239 M2 0 Peripheral nodes OTU_13824 -0.2403 M2 0 Peripheral nodes OTU_151 -1.372 M2 0.4444 Peripheral nodes # plot node roles in terms of the within-module connectivity and among-module connectivity t1$plot_taxa_roles(use_type = 1) # plot node roles with phylum information t1$plot_taxa_roles(use_type = 2) Now, we show the eigengene analysis of modules. The eigengene of a module, i.e. the first principal component of PCA, represents the main variance of the abundance in the species of the module. t1$cal_eigen() # return t1$res_eigen Then we perform correlation heatmap to show the relationships between eigengenes and environmental factors. # create trans_env object like the above operation t2 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # calculate correlations t2$cal_cor(add_abund_table = t1$res_eigen) # plot the correlation heatmap t2$plot_cor() The subset_network() function can be used to extract a part of nodes and edges among these nodes from the network. In this function, you should provide the nodes you need using the node parameter. # extract a sub network that contains all nodes in module M1 t1$subset_network(node = t1$res_node_type %&gt;% .[.$module == &quot;M1&quot;, ] %&gt;% rownames, rm_single = TRUE) # return a new network with igraph class # extract sub network in which all edge labels are &quot;+&quot;, i.e. positive edges t1$subset_network(edge = &quot;+&quot;) Then let’s show how to extract sub-network for samples and the whole analysis flow. # extract the sub-network of sample &#39;S1&#39; sub1 &lt;- t1$subset_network(node = dataset$otu_table[, &quot;S1&quot;, drop = FALSE] %&gt;% .[.[, 1] !=0, , drop = FALSE] %&gt;% rownames, rm_single = TRUE) # see https://chiliubio.github.io/microeco_tutorial/notes.html#clone for the &#39;clone&#39; function explanation t2 &lt;- clone(t1) t2$res_network &lt;- sub1 # then t2 have a network for &#39;S1&#39; and can be used for further analysis t2$cal_module() t2$save_network(&quot;S1.gexf&quot;) # please use a loop for more samples Then we show the next implemented network construction approach: SPIEC-EASI (SParse InversE Covariance Estimation for Ecological Association Inference) network in SpiecEasi R package (Kurtz et al. 2015). See https://chiliubio.github.io/microeco_tutorial/intro.html#spieceasi for the package installation. # cal_cor select NA t1 &lt;- trans_network$new(dataset = dataset, cal_cor = NA, taxa_level = &quot;OTU&quot;, filter_thres = 0.0005) # require SpiecEasi package https://github.com/zdk123/SpiecEasi t1$cal_network(network_method = &quot;SpiecEasi&quot;) # see t1$res_network We also introduce the third network construction approach: Probabilistic Graphical Models (PGM), which is implemented in julia package FlashWeave(Tackmann, Matias Rodrigues, and Mering 2019). It predicts ecological interactions among microbes from large-scale compositional abundance data (i.e. OTU tables constructed from sequencing data) through statistical co-occurrence. If you want to use this method like the following code, you should first install julia language in your computer and the FlashWeave package, and add the julia in the computer path. download and install julia from https://julialang.org/downloads/ Put julia in the computer env PATH, such as your_directory_path Open terminal or cmd or Powershell, open julia, install FlashWeave following the operation in https://github.com/meringlab/FlashWeave.jl # cal_cor select NA t1 &lt;- trans_network$new(dataset = dataset, cal_cor = NA, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001) # require Julia in the computer path, and the package FlashWeave t1$cal_network(network_method = &quot;PGM&quot;) # see t1$res_network 6.2.2 Key points subset_network(): this function can extract any sub-network according to the input nodes, e.g. sub-network for modules or samples 6.2.3 Other functions get_edge_table(): get the table of edges, including connected nodes, labels and weight. cal_powerlaw_p(): perform a bootstrapping hypothesis test to determine whether degrees follows a power law distribution cal_powerlaw_p(): fit degrees to a power law distribution. 6.3 trans_nullmodel class In recent decades, the integration of phylogenetic analysis and null model promotes the inference of niche and neutral influences on community assembly more powerfully by adding a phylogeny dimension (Webb et al. 2002; Stegen et al. 2013). The trans_nullmodel class provides an encapsulation, including the calculation of the phylogenetic signal, beta mean pairwise phylogenetic distance (betaMPD), beta mean nearest taxon distance (betaMNTD), beta nearest taxon index (betaNTI), beta net relatedness index (betaNRI) and Bray-Curtis-based Raup-Crick (RCbray). The approach for phylogenetic signal analysis is based on the mantel correlogram (Liu et al. 2017), in which the change of phylogenetic signal is intuitional and clear compared to other approaches. The algorithms of betaMNTD and betaMPD have been optimized to be faster than those in the picante package (Kembel et al. 2010). The combinations between RCbray and betaNTI can be used to infer the strength of each ecological process dominating the community assembly under the specific hypothesis (Stegen et al. 2013). This can be achievable by the function cal_process() to parse the percentage of each inferred process. 6.3.1 Example We first check the phylogenetic signal. # generate trans_nullmodel object; use 1000 OTUs as example t1 &lt;- trans_nullmodel$new(dataset, taxa_number = 1000, add_data = env_data_16S) # use pH as the test variable t1$cal_mantel_corr(use_env = &quot;pH&quot;) # return t1$res_mantel_corr # plot the mantel correlogram t1$plot_mantel_corr() betaNRI(ses.betampd) is used to show the ‘basal’ phylogenetic turnover(Liu et al. 2017). Compared to betaNTI, it can capture more turnover information associated with the deep phylogeny. It is noted that there are many null models with the development in the several decades. In the trans_nullmodel class, we randomized the phylogenetic relatedness of species. This shuffling approach fix the observed levels of species α-diversity and β-diversity to explore whether the observed phylogenetic turnover significantly differ from null model that phylogenetic relatedness among species are random. # null model run 500 times t1$cal_ses_betampd(runs=500, abundance.weighted = TRUE) # return t1$res_ses_betampd If we want to plot the betaNRI, we can use plot_group_distance function in trans_beta class. For example, the results showed that the mean betaNRI of TW is extremely and significantly larger that those in CW and IW, revealing that the basal phylogenetic turnover in TW is high. # add betaNRI matrix to beta_diversity list dataset$beta_diversity[[&quot;betaNRI&quot;]] &lt;- t1$res_ses_betampd # create trans_beta class, use measure &quot;betaNRI&quot; t2 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;betaNRI&quot;) # transform the distance for each group t2$cal_group_distance() # plot the results g1 &lt;- t2$plot_group_distance(distance_pair_stat = TRUE) g1 + geom_hline(yintercept = -2, linetype = 2) + geom_hline(yintercept = 2, linetype = 2) Sometimes, if you want to perform null model analysis for each group individually, such as one group as one species pool, you can calculate the results for each group, respectively. The results show that, when we perform betaNRI for each group respectively, mean betaNRI between CW and TW are not significantly different, and they are both significantly higher than that in IW, revealing that the strength of variable selection in CW and TW may be similar under the condition that each area is considered as a specific species pool. # we create a list to store the trans_nullmodel results. sesbeta_each &lt;- list() group_col &lt;- &quot;Group&quot; all_groups &lt;- unique(dataset$sample_table[, group_col]) # calculate for each group, respectively for(i in all_groups){ # like the above operation, but need provide &#39;group&#39; and &#39;select_group&#39; test &lt;- trans_nullmodel$new(dataset, group = group_col, select_group = i, taxa_number = 1000, add_data = env_data_16S) test$cal_ses_betampd(runs = 500, abundance.weighted = TRUE) sesbeta_each[[i]] &lt;- test$res_ses_betampd } # merge and reshape to generate one symmetrical matrix test &lt;- lapply(sesbeta_each, reshape2::melt) %&gt;% do.call(rbind, .) %&gt;% reshape2::dcast(., Var1~Var2, value.var = &quot;value&quot;) rownames(test) &lt;- test[, 1] test &lt;- test[, -1, drop = FALSE] # like the above operation dataset$beta_diversity[[&quot;betaNRI&quot;]] &lt;- test t2 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;betaNRI&quot;) t2$cal_group_distance() g1 &lt;- t2$plot_group_distance(distance_pair_stat = TRUE) g1 + geom_hline(yintercept = -2, linetype = 2) + geom_hline(yintercept = 2, linetype = 2) BetaNTI(ses.betamntd) can be used to indicate the phylogenetic terminal turnover (Stegen et al. 2013). # null model run 500 times t1$cal_ses_betamntd(runs=500, abundance.weighted = TRUE) # return t1$res_ses_betamntd   S1 S2 S3 S4 S5 S1 0 -6.554 -6.563 -6.308 -6.153 S2 -6.554 0 -6.678 -6.675 -6.124 S3 -6.563 -6.678 0 -6.544 -6.46 S4 -6.308 -6.675 -6.544 0 -6.356 S5 -6.153 -6.124 -6.46 -6.356 0 RCbray (Bray-Curtis-based Raup-Crick) can be calculated using function cal_rcbray() to assess whether the compositional turnover was governed primarily by drift (Chase et al. 2011). We applied null model to simulate species distribution by randomly sampling individuals from each species pool with preserving species occurrence frequency and sample species richness (Liu et al. 2017). # result stored in t1$res_rcbray t1$cal_rcbray(runs = 1000) # return t1$res_rcbray As an example, we also calculate the proportion of the inferred processes on the community assembly as shown in the references (Stegen et al. 2013; Liu et al. 2017). In the example, the fraction of pairwise comparisons with significant betaNTI values (|βNTI| &gt; 2) is the estimated influence of Selection; βNTI &gt; 2 represents the heterogeneous selection; βNTI &lt; -2 represents the homogeneous selection. The value of RCbray characterizes the magnitude of deviation between observed Bray–Curtis and Bray–Curtis expected under the randomization; a value of |RCbray| &gt; 0.95 was considered significant. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and RCbray &gt; +0.95 was taken as the influence of Dispersal Limitation combined with Drift. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and RCbray &lt; -0.95 was taken as an estimate for the influence of Homogenizing Dispersal. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and |RCbray| &lt; 0.95 estimates the influence of Drift acting alone. # use betaNTI and rcbray to evaluate processes t1$cal_process(use_betamntd = TRUE) ## The result is stored in object$res_process ... # return t1$res_process t1$res_process process percentage variable selection 3.995 homogeneous selection 48.34 dispersal limitation 0.02497 homogeneous dispersal 8.539 drift 39.1 6.3.2 Key points trans_nullmodel$new: filter_thres parameter for the filtering of taxa with relative low abundance cal_rcbray(): if you just need rcbray, ignore other phylogenetic operations 6.3.3 Other function cal_Cscore(): calculates the (normalised) mean number of checkerboard combinations (C-score) using C.score References "],["explainable-class.html", "Chapter 7 Explainable class 7.1 trans_env class 7.2 trans_func class", " Chapter 7 Explainable class We group trans_env and trans_func classes into ‘Explainable class,’ as the environmental measurements and functional data are generally explainable factors. 7.1 trans_env class The environmental variables are explainable indices in analyzing microbial community structure and assembly mechanisms. 7.1.1 Example We first show the RDA analysis (db-RDA and RDA). # add_data is used to add the environmental data t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use bray-curtis distance to do dbrda t1$cal_rda(use_dbrda = TRUE, use_measure = &quot;bray&quot;) # t1$res_rda is the result list stored in the object t1$trans_rda(adjust_arrow_length = TRUE, max_perc_env = 10) # t1$res_rda_trans is the transformed result for plotting t1$plot_rda(plot_color = &quot;Group&quot;) # use Genus t1$cal_rda(use_dbrda = FALSE, taxa_level = &quot;Genus&quot;) # As the main results of RDA are related with the projection and angles between different arrows, # we adjust the length of the arrow to show them clearly using several parameters. t1$trans_rda(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1500, max_perc_tax = 3000, min_perc_env = 200, min_perc_tax = 300) # t1$res_rda_trans is the transformed result for plotting t1$plot_rda(plot_color = &quot;Group&quot;) Mantel test can be used to check whether there is significant correlations between environmental variables and distance matrix. t1$cal_mantel(use_measure = &quot;bray&quot;) # return t1$res_mantel t1$res_mantel ## The result is stored in object$res_mantel or object$res_mantel_partial ... variable_name cor_method corr_res p_res significance Temperature pearson 0.452 0.001 *** Precipitation pearson 0.2791 0.001 *** TOC pearson 0.13 0.003 ** NH4 pearson -0.05539 0.926 NO3 pearson 0.06758 0.05 * pH pearson 0.4085 0.001 *** Conductivity pearson 0.2643 0.001 *** TN pearson 0.1321 0.002 ** The correlations between environmental variables and taxa are important in analyzing and inferring the factors affecting community structure. Let’s first perform a correlation heatmap using Genus level data. t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) t1$cal_cor(use_data = &quot;Genus&quot;, p_adjust_method = &quot;fdr&quot;) ## The correlation result is stored in object$res_cor ... # return t1$res_cor Then, we can plot the correlation results using plot_cor function. # default ggplot2 method with clustering t1$plot_cor() There are too many genera. We can use the filter_feature parameter in plot_cor to filter some taxa that do not have any significance &lt; 0.001. # filter genera that do not have at least one *** t1$plot_cor(filter_feature = c(&quot;&quot;, &quot;*&quot;, &quot;**&quot;)) Sometimes, if we want to conduct the correlation analysis between the environmental factors and some important taxa which are detected in the biomarker analysis, we can use other_taxa parameter in cal_cor function. # first create trans_diff object as a demonstration t2 &lt;- trans_diff$new(dataset = dataset, method = &quot;rf&quot;, group = &quot;Group&quot;, rf_taxa_level = &quot;Genus&quot;) # then create trans_env object t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use other_taxa to select taxa you need t1$cal_cor(use_data = &quot;other&quot;, p_adjust_method = &quot;fdr&quot;, other_taxa = t2$res_rf$Taxa[1:40]) t1$plot_cor() The pheatmap method is also available. Note that, besides the color_vector parameter, color_palette can also be used to control color palette with customized colors. # clustering heatmap; require pheatmap package # Let&#39;s take another color pallete t1$plot_cor(pheatmap = TRUE, color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = &quot;RdYlBu&quot;))) Sometimes, if it is necessary to study the correlations between environmental variables and taxa for different groups, by_group parameter can be used for this goal. # calculate correlations for different groups using parameter by_group t1$cal_cor(by_group = &quot;Group&quot;, use_data = &quot;other&quot;, p_adjust_method = &quot;fdr&quot;, other_taxa = t2$res_rf$Taxa[1:40]) # return t1$res_cor t1$plot_cor() If you are concerned with the relationship between environmental factors and alpha diversity, you can also use this function. t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use add_abund_table parameter to add the extra data table t1$cal_cor(add_abund_table = dataset$alpha_diversity) t1$plot_cor(pheatmap = TRUE) The function plot_scatterfit() in trans_env class is designed for the scatter plot, adding the fitted line and statistics of correlation or regression. # use pH and bray-curtis distance t1$plot_scatterfit( x = &quot;pH&quot;, y = dataset$beta_diversity$bray[rownames(t1$env_data), rownames(t1$env_data)], use_cor = TRUE, alpha = .1, x_axis_title = &quot;Euclidean distance of pH&quot;, y_axis_title = &quot;Bray-Curtis distance&quot;, text_x_pos = 4, text_y_pos = .4) 7.1.2 Key points add_abund_table parameter in cal_cor: other customized data can be also provided for the correlation analysis. use_cor parameter in plot_scatterfit: both the correlation and regression are available in this function. cal_mantel(): partial_mantel = TRUE can be used for partial mantel test. 7.2 trans_func class Ecological researchers are usually interested in the the funtional profiles of microbial communities, because functional or metabolic data is powerful to explain the structure and dynamics of microbial communities and to infer the underlying mechanisms. As metagenomic sequencing is complicated and expensive, using amplicon sequencing data to predict functional profiles is an alternative choice. Several software are often used for this goal, such as PICRUSt(Langille et al. 2013), Tax4Fun(Aßhauer et al. 2015) and FAPROTAX(Stilianos Louca et al. 2016; S. Louca, Parfrey, and Doebeli 2016). These tools are great to be used for the prediction of functional profiles based on the prokaryotic communities from sequencing results. In addition, it is also important to obtain the functions for each taxa or OTU, not just the whole profile of communities. But it is hard to know exact functions of each OTU. FAPROTAX database is a collection of the traits and functions of prokaryotes based on the known research results published in books and literatures. We match the taxonomic information of prokaryotes against this database to predict the traits of prokaryotes on biogeochemical roles. The NJC19 database(Lim et al. 2020) is also available for animal-associated prokaryotic data, such as human gut microbiota. We also implement the FUNGuild (Nguyen et al. 2016) and FungalTraits (Põlme et al. 2020) databases to predict the fungal traits. 7.2.1 Example We first identify/predict traits of taxa with the prokaryotic example data. # create object of trans_func t2 &lt;- trans_func$new(dataset) # mapping the taxonomy to the database # this can recognize prokaryotes or fungi automatically if the names of taxonomic levels are standard. # default database for prokaryotes is FAPROTAX database t2$cal_spe_func(prok_database = &quot;FAPROTAX&quot;) ## Please also cite the original FAPROTAX paper: Louca et al. (2016). ## Decoupling function and taxonomy in the global ocean microbiome. Science, 353(6305), 1272. ## The functional binary table is stored in object$res_spe_func ... # return t2$res_spe_func, 1 represent trait exists, 0 represent no or cannot confirmed. t2$res_spe_func[1:5, 1:2]   methanotrophy acetoclastic_methanogenesis OTU_4272 0 0 OTU_236 0 0 OTU_399 0 0 OTU_1556 0 0 OTU_32 0 0 The percentages of the OTUs having the same trait can reflect the functional redundancy of this function in the community or the module in the network. # calculate the percentages of OTUs for each trait in each module of network # use_community = TRUE; for community t2$cal_spe_func_perc(use_community = TRUE) # return t2$res_spe_func_perc for each sample # Then, let&#39;s explore network modules; use_community = FALSE # node_type_table is generated in the trans_network part t2$cal_spe_func_perc(use_community = FALSE, node_type_table = network_node_type) # we only plot some important traits, so we use the default group list to filter and show the traits. t2$plot_spe_func_perc(select_samples = paste0(&quot;M&quot;, 1:10)) # M represents module, ordered by the nodes number from high to low # If you want to change the group list, reset the list t2$func_group_list t2$func_group_list # use show_prok_func to see the detailed information of prokaryotic traits t2$show_prok_func(&quot;methanotrophy&quot;) # calculate the percentages for communities t2$cal_spe_func_perc(use_community = TRUE) ## The result table is stored in object$res_spe_func_perc ... # t2$res_spe_func_perc[1:5, 1:2]   methanotrophy acetoclastic_methanogenesis S1 0.39 0.04 S2 0.27 0 S3 0.48 0 S4 0.48 0 S5 0.56 0 # then we try to correlate the res_spe_func_perc of communities to environmental variables t3 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) t3$cal_cor(add_abund_table = t2$res_spe_func_perc, cor_method = &quot;spearman&quot;) t3$plot_cor(pheatmap = TRUE) Tax4Fun requires a strict input file format associated with the taxonomic information. To analyze the trimmed or changed OTU data in R with Tax4Fun, we provide a link to the Tax4Fun functional prediction. Please see https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun for installing Tax4Fun package and download SILVA123 ref data. t1 &lt;- trans_func$new(dataset) # see https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun for the installation # and provide the file path of SILVA123 t1$cal_tax4fun(folderReferenceData = &quot;./SILVA123&quot;) ## Warning in write.table(otu_file, file = output, append = TRUE, quote = FALSE, : ## appending column names to file # return two files: t1$tax4fun_KO: KO file; t1$tax4fun_path: pathway file. # t1$tax4fun_KO$Tax4FunProfile[1:5, 1:2]   K00001; alcohol dehydrogenase [EC:1.1.1.1] K00002; alcohol dehydrogenase (NADP+) [EC:1.1.1.2] S1 0.0004823 5.942e-06 S2 0.0005266 4.017e-06 S3 0.0005054 6.168e-06 S4 0.0005109 5.888e-06 S5 0.0005083 5.547e-06 Now, we use pathway file to analyze the abundance of pathway. # must transpose to taxa row, sample column pathway_file &lt;- t1$tax4fun_path$Tax4FunProfile %&gt;% t %&gt;% as.data.frame # filter rownames, only keep ko+number rownames(pathway_file) %&lt;&gt;% gsub(&quot;(^.*);\\\\s.*&quot;, &quot;\\\\1&quot;, .) # load the pathway hierarchical metadata data(ko_map) # further create a microtable object, familiar? func1 &lt;- microtable$new(otu_table = pathway_file, tax_table = ko_map, sample_table = t1$sample_table) print(func1) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 284 rows and 90 columns ## tax_table have 341 rows and 3 columns Now, we need to trim data and calculate abundance. func1$tidy_dataset() # calculate abundance automatically at three levels: level_1, level_2, level_3 func1$cal_abund() ## The result is stored in object$taxa_abund ... print(func1) ## microtable class: ## sample_table have 90 rows and 4 columns ## otu_table have 284 rows and 90 columns ## tax_table have 284 rows and 3 columns ## Taxa abundance: calculated for level_1,level_2,level_3 Then, we can plot the abundance. # bar plot at level_1 func2 &lt;- trans_abund$new(func1, taxrank = &quot;level_1&quot;, groupmean = &quot;Group&quot;) func2$plot_bar(legend_text_italic = FALSE) We can also do something else. For example, we can use lefse to test the differences of the abundances and find the important enriched pathways across groups. func2 &lt;- trans_diff$new(dataset = func1, method = &quot;lefse&quot;, group = &quot;Group&quot;, alpha = 0.05, lefse_subgroup = NULL) func2$plot_lefse_bar(LDA_score = 3, width = 0.8) Tax4Fun2 (Wemheuer et al. 2020) is another R package for the prediction of functional profiles of prokaryotic communities from 16S rRNA gene sequences. It also provides two indexes for the evaluation of functional gene redundancies. If you want to use Tax4Fun2 method, you must add the representative fasta file to the microtable object. Please see https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun2 for downloading ncbi-blast and Ref99NR/Ref100NR. # create a microtable object with the fasta file data(sample_info_16S) data(otu_table_16S) data(taxonomy_table_16S) # representative sequences are necessary for this analysis data(rep_fasta_16S) use_dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, tax_table = taxonomy_table_16S, rep_fasta = rep_fasta_16S) use_dataset$filter_pollution(taxa = c(&quot;mitochondria&quot;, &quot;chloroplast&quot;)) use_dataset$tidy_dataset() use_dataset t1 &lt;- trans_func$new(use_dataset) # create a directory for result and log files dir.create(&quot;test_prediction&quot;) # see https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun2 for installation # ignore blast_tool_path parameter if blast tools have been in path # the function can search whether blast tool directory is in the path, if not, automatically use provided blast_tool_path parameter t1$cal_tax4fun2(blast_tool_path = &quot;ncbi-blast-2.5.0+/bin&quot;, path_to_reference_data = &quot;Tax4Fun2_ReferenceData_v2&quot;, database_mode = &quot;Ref99NR&quot;, path_to_temp_folder = &quot;test_prediction&quot;) # prepare feature table and metadata tax4fun2_pathway &lt;- t1$res_tax4fun2_pathway rownames(tax4fun2_pathway) &lt;- tax4fun2_pathway[, 1] tax4fun2_pathway &lt;- tax4fun2_pathway[, -1] func_num &lt;- ncol(tax4fun2_pathway): (ncol(tax4fun2_pathway) - 2) func_map &lt;- tax4fun2_pathway[, func_num] colnames(func_map) &lt;- c(&quot;level_1&quot;, &quot;level_2&quot;, &quot;level_3&quot;) tax4fun2_pathway &lt;- tax4fun2_pathway[, -func_num] # create a microtable object for pathways func2 &lt;- microtable$new(otu_table = tax4fun2_pathway, tax_table = func_map, sample_table = use_dataset$sample_table) func2$tidy_dataset() func2 # calculate functional gene redundancies t1$cal_tax4fun2_FRI() 7.2.2 Key points blast_tool_path parameter in cal_tax4fun2: if the blast tool has been in ‘environment variable’ of computer, it is ok to use blast_tool_path = NULL blast version: tax4fun2 require NCBI blast tool. However, some errors can come from the latest versions (https://www.biostars.org/p/413294/). An easy solution is to use previous version (such as 2.5.0). References "],["file2meco-package.html", "Chapter 8 file2meco package 8.1 QIIME 8.2 QIIME2 8.3 HUMAnN metagenomic results 8.4 MetaPhlAn 8.5 Kraken2 8.6 Ncyc 8.7 phyloseq", " Chapter 8 file2meco package In the microtable class part, we show the basic use of the creating of microtable object with the example data. Actually, constructing the basic microtable object from other tools/platforms (e.g. QIIME, QIIME2, HUMAnN, Kraken2 and phyloseq) can be easily achieved with the package file2meco (https://github.com/ChiLiubio/file2meco). 8.1 QIIME The qiime1meco() function can be used to construct the microtable object using the raw OTU file from QIIME1. # see https://github.com/ChiLiubio/file2meco for the installation library(file2meco) # see the help document ?qiime1meco # Let&#39;s run the examples # use the raw data files stored inside the package otu_file_path &lt;- system.file(&quot;extdata&quot;, &quot;otu_table_raw.txt&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample_info.csv&quot;, package=&quot;file2meco&quot;) phylo_file_path &lt;- system.file(&quot;extdata&quot;, &quot;rep_phylo.tre&quot;, package=&quot;file2meco&quot;) # if you want to use Tax4Fun2 approach, you need read the representative sequences and add it to the microtable object. rep_fasta_path &lt;- system.file(&quot;extdata&quot;, &quot;rep.fna&quot;, package=&quot;file2meco&quot;) # contruct microtable object qiime1meco(otu_table = otu_file_path) qiime1meco(otu_table = otu_file_path, sample_data = sample_file_path) qiime1meco(otu_table = otu_file_path, sample_data = sample_file_path, phylo_tree = phylo_file_path) qiime1meco(otu_table = otu_file_path, sample_data = sample_file_path, phylo_tree = phylo_file_path, rep_fasta = rep_fasta_path) 8.2 QIIME2 The qiime2meco() function is designed to create the microtable object using files from QIIME2. library(file2meco) ?qiime2meco # use data files inside the package which were downloaded from (https://docs.qiime2.org/2020.8/tutorials/pd-mice/). abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;dada2_table.qza&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample-metadata.tsv&quot;, package=&quot;file2meco&quot;) taxonomy_file_path &lt;- system.file(&quot;extdata&quot;, &quot;taxonomy.qza&quot;, package=&quot;file2meco&quot;) phylo_file_path &lt;- system.file(&quot;extdata&quot;, &quot;tree.qza&quot;, package=&quot;file2meco&quot;) rep_fasta_path &lt;- system.file(&quot;extdata&quot;, &quot;dada2_rep_set.qza&quot;, package=&quot;file2meco&quot;) # construct microtable object qiime2meco(ASV_data = abund_file_path) qiime2meco(ASV_data = abund_file_path, sample_data = sample_file_path, taxonomy_data = taxonomy_file_path) qiime2meco(ASV_data = abund_file_path, sample_data = sample_file_path, taxonomy_data = taxonomy_file_path, phylo_tree = phylo_file_path, rep_fasta = rep_fasta_path) 8.3 HUMAnN metagenomic results HUMAnN is an excellent tool for functional profiling analysis of metagenomes and metatranscriptomes at species-level (https://doi.org/10.1038/s41592-018-0176-y). The humann2meco() function can be used to create the microtable object using metagenomic analysis files from HUMAnN2 and HUMAnN3 (https://huttenhower.sph.harvard.edu/humann). Currently, it supports both the MetaCyc and KEGG pathway abundance file input directly. library(file2meco) library(microeco) library(magrittr) ?humann2meco sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) # MetaCyc pathway database based analysis # use the raw data files stored inside the package for MetaCyc pathway database based analysis abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_HUMAnN_MetaCyc_abund.tsv&quot;, package=&quot;file2meco&quot;) # the default db is &quot;MetaCyc&quot; humann2meco(abund_table = abund_file_path, db = &quot;MetaCyc&quot;) humann2meco(abund_table = abund_file_path, db = &quot;MetaCyc&quot;, sample_data = sample_file_path, match_table = match_file_path) # Let&#39;s try more interesting usages with microeco test &lt;- humann2meco(abund_table = abund_file_path, db = &quot;MetaCyc&quot;, sample_data = sample_file_path, match_table = match_file_path) test$tidy_dataset() # rel = FALSE donot use relative abundance test$cal_abund(select_cols = 1:3, rel = FALSE) test$taxa_abund$Superclass1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Superclass1&quot;, ntaxa = 10) test1$plot_bar(facet = &quot;Group&quot;, ylab_title = &quot;Abundance (RPK)&quot;) # select both function and taxa test$cal_abund(select_cols = c(&quot;Superclass1&quot;, &quot;Phylum&quot;, &quot;Genus&quot;), rel = TRUE) test1 &lt;- trans_abund$new(test, taxrank = &quot;Phylum&quot;, ntaxa = 10, delete_part_prefix = T) test1$plot_bar(facet = &quot;Group&quot;) # functional biomarker test$cal_abund(select_cols = 1:3, rel = TRUE) test$taxa_abund$Superclass1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;) test1$plot_lefse_bar(use_number = 1:20) # taxa biomarker test$cal_abund(select_cols = 4:9, rel = TRUE) test$taxa_abund$Phylum %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;) test1$plot_lefse_bar(LDA_score = 2) # use KEGG pathway based HUMAnN result abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_HUMAnN_KEGG_abund.tsv&quot;, package=&quot;file2meco&quot;) test &lt;- humann2meco(abund_table = abund_file_path, db = &quot;KEGG&quot;, sample_data = sample_file_path, match_table = match_file_path) test$tax_table %&lt;&gt;% subset(level1 != &quot;unclassified&quot;) test$tidy_dataset() # rel = FALSE donot use relative abundance test$cal_abund(select_cols = 1:3, rel = FALSE) test1 &lt;- trans_abund$new(test, taxrank = &quot;level2&quot;, ntaxa = 10) test1$plot_bar(facet = &quot;Group&quot;, ylab_title = &quot;Abundance (RPK)&quot;) # select both function and taxa test$cal_abund(select_cols = c(&quot;level1&quot;, &quot;Phylum&quot;, &quot;Genus&quot;), rel = TRUE) test$taxa_abund$level1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test$taxa_abund$Phylum %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Phylum&quot;, ntaxa = 10, delete_part_prefix = T) test1$plot_bar(facet = &quot;Group&quot;) # functional biomarker test$cal_abund(select_cols = 1:3, rel = TRUE) test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;) test1$plot_lefse_bar(LDA_score = 3) 8.4 MetaPhlAn MetaPhlAn is an software used for metagenomic taxonomic profiling (https://doi.org/10.1038/nmeth.3589). The format of MetaPhlAn classification results is usually called ‘mpa’ format. The mpa2meco function is developed for this format conversion to microtable object. See the following example of Kraken2 part. 8.5 Kraken2 Kraken is a taxonomic sequence classifier that assigns taxonomic labels to DNA sequences. Kraken examines the k-mers within a query sequence and uses the information within those k-mers to query a database. That database maps k-mers to the lowest common ancestor (LCA) of all genomes known to contain a given k-mer. Kraken2 is the newest version (https://doi.org/10.1186/s13059-019-1891-0). The merged Kraken2 results can be obtained by merge_metaphlan_tables.py from MetaPhlAn or combine_mpa.py from KrakenTools (https://ccb.jhu.edu/software/krakentools/). # the example is metagenomic classification result # use the raw data files stored inside the package abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_kraken2_merge.txt&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) mpa2meco(abund_table = abund_file_path) test &lt;- mpa2meco(abund_table = abund_file_path, sample_data = sample_file_path, match_table = match_file_path) test$tidy_dataset() 8.6 Ncyc Ncyc database is a curated integrative database for fast and accurate metagenomic profiling of nitrogen cycling genes (https://doi.org/10.1093/bioinformatics/bty741). The ncyc2meco() function is designed for construct the microtable object using gene abundance files from Ncyc (https://github.com/qichao1984/NCyc). library(file2meco) library(microeco) library(magrittr) ?ncyc2meco # use the raw data files stored inside the package abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_Ncyc_table.tsv&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) ncyc2meco(abund_table = abund_file_path) ncyc2meco(abund_table = abund_file_path, sample_data = sample_file_path, match_table = match_file_path) # Let&#39;s try more interesting usages with microeco test &lt;- ncyc2meco(abund_table = abund_file_path, sample_data = sample_file_path, match_table = match_file_path) test$tidy_dataset() # use split_group = TRUE to calculate the pathway abundance with multipe map correspondance test$cal_abund(select_cols = 1:2, rel = TRUE, split_group = TRUE, split_column = &quot;Pathway&quot;) test$taxa_abund$Pathway %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Pathway&quot;) test1$plot_bar(bar_type = &quot;notfull&quot;) # for gene abundance, no splitting on the pathways test$cal_abund(select_cols = 1:2, rel = TRUE, split_group = FALSE) test$taxa_abund$Gene %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Gene&quot;) test1$plot_bar(bar_type = &quot;notfull&quot;) 8.7 phyloseq Two functions meco2phyloseq() and phyloseq2meco() were provided for the conversion between microtable object and phyloseq object (phyloseq package). # Please first install phyloseq if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;phyloseq&quot;) library(phyloseq) # from microtable to phyloseq object data(&quot;dataset&quot;) physeq &lt;- meco2phyloseq(dataset) physeq # from phyloseq to microtable object data(&quot;GlobalPatterns&quot;) meco_dataset &lt;- phyloseq2meco(GlobalPatterns) meco_dataset "],["other-dataset.html", "Chapter 9 Other dataset 9.1 Fungi data 9.2 Metagenomic data 9.3 Gut microbiome", " Chapter 9 Other dataset 9.1 Fungi data Another ITS sequencing dataset (Gao et al. 2019) is also stored in the example data of the package. Here, we use it as an example to show the use of FUNGuild database(Nguyen et al. 2016). FungalTraits (Põlme et al. 2020) database is also available for identifying fungal traits. # load ITS data data(sample_info_ITS) data(otu_table_ITS) data(taxonomy_table_ITS) # create microtable object dataset &lt;- microtable$new(sample_table = sample_info_ITS, otu_table = otu_table_ITS, tax_table = taxonomy_table_ITS) # remove the taxa not assigned in the Kingdom &quot;k__Fungi&quot; dataset$tax_table %&lt;&gt;% base::subset(Kingdom == &quot;k__Fungi&quot;) # use tidy_dataset() to make OTUs and samples information consistent across files dataset$tidy_dataset() # create trans_network object t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;WGCNA&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.000001, cor_method = &quot;spearman&quot;) # create correlation network t1$cal_network(p_thres = 0.05, COR_cut = 0.6) # add modules t1$cal_module() # calculate node topological properties t1$cal_node_type() node_type_table &lt;- t1$res_node_type # create trans_func object t2 &lt;- trans_func$new(dataset) # identify species traits, automatically select database for prokaryotes or fungi # fungi_database = &quot;FungalTraits&quot; for the FungalTraits database t2$cal_spe_func(fungi_database = &quot;FUNGuild&quot;) # calculate abundance-unweighted functional redundancy of each trait for each network module t2$cal_spe_func_perc(use_community = FALSE, node_type_table = node_type_table) # plot the functional redundancy of network modules t2$plot_spe_func_perc(select_samples = paste0(&quot;M&quot;, 1:10)) 9.2 Metagenomic data Many methods in microeco package can be used not only for the traditional species abundance data, i.e. species-sample table, but also for other data, such as metagenomic and metabolomic data. In the file2meco package (https://github.com/ChiLiubio/file2meco), we provide several functions to transform the output files of some famous metagenomic tools (e.g. HUMAnN and kraken) to the microtable object directly. HUMAnN(Franzosa et al. 2018) is an excellent tool for functional profiling analysis of metagenomes and metatranscriptomes at species-level. Certainly, it can also be used for the whole community profile of metabolic pathways if you do not need something at species-level. The humann2meco() function can be used to creat the microtable object using metagenomic analysis files from HUMAnN3 (https://huttenhower.sph.harvard.edu/humann). Currently, it supports both the MetaCyc (https://metacyc.org/) and KEGG pathway abundance file input. Here, we show the example of KEGG pathway results. library(microeco) library(file2meco) library(magrittr) ?humann2meco sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) # use KEGG pathway based HUMAnN result abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_HUMAnN_KEGG_abund.tsv&quot;, package=&quot;file2meco&quot;) # match_table parameter can be used to replace sample names test &lt;- humann2meco(abund_table = abund_file_path, db = &quot;KEGG&quot;, sample_data = sample_file_path, match_table = match_file_path) # remove the unclassified pathway in the top level test$tax_table %&lt;&gt;% subset(level1 != &quot;unclassified&quot;) test$tidy_dataset() # rel = FALSE donot use relative abundance, use the raw RPK test$cal_abund(select_cols = 1:3, rel = FALSE) test1 &lt;- trans_abund$new(test, taxrank = &quot;level2&quot;, ntaxa = 10) test1$plot_bar(facet = &quot;Group&quot;, ylab_title = &quot;Abundance (RPK)&quot;, use_colors = RColorBrewer::brewer.pal(12, &quot;Set3&quot;)) Then, we select both function and taxa to see which taxa those high abundant pathways come from. # This operation is more flexible test$cal_abund(select_cols = c(&quot;level1&quot;, &quot;Phylum&quot;, &quot;Genus&quot;), rel = FALSE) test$taxa_abund$level1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test$taxa_abund$Phylum %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Phylum&quot;, ntaxa = 10, delete_part_prefix = T) test1$plot_bar(facet = &quot;Group&quot;, ylab_title = &quot;Abundance (RPK)&quot;, use_colors = RColorBrewer::brewer.pal(12, &quot;Set3&quot;)) Let’s run LEfSe to find some functional biomarkers to differentiate two groups. # functional biomarker test$cal_abund(select_cols = 1:3, rel = TRUE) test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;) test1$plot_lefse_bar(LDA_score = 3) 9.3 Gut microbiome We use mouse gut data stored in file2meco package to show the input of QIIME2 file and the use of metabolic trait database NJC19 database(Lim et al. 2020). library(microeco) library(file2meco) library(ggplot2) # use data files inside the file2meco package. abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;dada2_table.qza&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample-metadata.tsv&quot;, package=&quot;file2meco&quot;) taxonomy_file_path &lt;- system.file(&quot;extdata&quot;, &quot;taxonomy.qza&quot;, package=&quot;file2meco&quot;) # construct microtable object data1 &lt;- qiime2meco(ASV_data = abund_file_path, sample_data = sample_file_path, taxonomy_data = taxonomy_file_path) data1$tidy_dataset() # revise the species names in tax_table as the information in the example file is not standard select_rows &lt;- data1$tax_table$Species != &quot;s__&quot; data1$tax_table$Species[select_rows] &lt;- paste0(&quot;s__&quot;, gsub(&quot;g__&quot;, &quot;&quot;, data1$tax_table$Genus[select_rows]), &quot; &quot;, gsub(&quot;s__&quot;, &quot;&quot;, data1$tax_table$Species[select_rows])) # taxonomic abundance data1$cal_abund() # create object of trans_func data2 &lt;- trans_func$new(data1) # Select NJC19 database data2$cal_spe_func(prok_database = &quot;NJC19&quot;) # get the trait percentage data data2$cal_spe_func_perc(use_community = TRUE) # inset the trait percentage result into taxa_abund of microtable object data1$taxa_abund$Trait &lt;- as.data.frame(t(data2$res_spe_func_perc)) # use trans_abund to plot t1 &lt;- trans_abund$new(dataset = data1, taxrank = &quot;Trait&quot;, ntaxa = 10, use_percentage = FALSE) t1$plot_box(group = &quot;donor_status&quot;) + ylab(&quot;Relative population abundance (%)&quot;) + theme(axis.text.x = element_text(size = 13)) References "],["notes.html", "Chapter 10 Notes 10.1 clone 10.2 save() function 10.3 subset of samples 10.4 change object 10.5 group order 10.6 add layers to plot", " Chapter 10 Notes We show some important things here. 10.1 clone R6 class has a special copy mechanism which is different from S3 and S4. If you want to copy an object completely, you should use the function clone() instead of direct assignment. # use clone to copy completely t1 &lt;- clone(dataset) t2 &lt;- clone(t1) t2$sample_table &lt;- NULL identical(t2, t1) ## [1] FALSE # this operation is usually unuseful, because changing t2 will also affect t1 t2 &lt;- t1 t2$sample_table &lt;- NULL identical(t2, t1) ## [1] TRUE 10.2 save() function As an R6 object is an encapsulated environment, there is also another very useful advantage, i.e. the data repeatability and communication. By applying R6 classes, the analyzed data in ‘R Environment’ can have minimum numbers of the intermediate files and can reduce memory spending. It is also very convenient to save the analyzed data (i.e. object) to local computer with save() function for back-up and communication with others. This is also the recommended way to send data for testing in ‘Github Issues.’ # save &#39;dataset&#39; to local computer save(dataset, file = &quot;dataset.RData&quot;) # dataset.RData can be compressed into zip format for the upload in &#39;Github Issues&#39; # load the data by others in their R project load(&quot;dataset.RData&quot;) The saved object is only related with the package version when you save it and has no matter with the updated package when you load it again. So it is repeatable. 10.3 subset of samples We donnot provide the special function to filter samples in microtable class, as we think it is redundant. We recommend user to directly manipulate the sample_table in microtable object. For example, if we want to analyze samples from ‘CW’ and ‘IW,’ respectively, we can operate like this: # remember first clone the full dataset group1 &lt;- clone(dataset) group1$sample_table &lt;- subset(group1$sample_table, Group == &quot;CW&quot;) # this is necessary to make files in group1 corresponding group1$tidy_dataset() group1 ## microtable class: ## sample_table have 30 rows and 4 columns ## otu_table have 9727 rows and 30 columns ## tax_table have 9727 rows and 7 columns ## phylo_tree have 9727 tips ## Taxa abundance: calculated for Kingdom,Phylum,Class,Order,Family,Genus,Species ## Alpha diversity: calculated for Observed,Chao1,se.chao1,ACE,se.ACE,Shannon,Simpson,InvSimpson,Fisher,Coverage ## Beta diversity: calculated for bray,jaccard # similar with obove operation group2 &lt;- clone(dataset) group2$sample_table &lt;- subset(group2$sample_table, Group == &quot;IW&quot;) group2$tidy_dataset() # now we get two microtable objects: group1 for CW and group2 for IW 10.4 change object All the classes are set public, meaning that you can change, add or remove the objects stored in them as you want. # add a matrix you think useful dataset$my_matrix &lt;- matrix(1, nrow = 4, ncol = 4) # change the information dataset$sample_table %&lt;&gt;% .[, -2] 10.5 group order If you want to reorder the groups, assign the factors may be the most simplest way. data(dataset) t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) t1$cal_ordination(ordination = &quot;PCoA&quot;) ## The ordination result is stored in object$res_ordination ... t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_group_ellipse = TRUE) Then we assign factors to the ‘Group’ in sample_table of dataset. We can find the changed group order in the legend and colors in the plot. dataset$sample_table$Group %&lt;&gt;% factor(., levels = c(&quot;IW&quot;, &quot;TW&quot;, &quot;CW&quot;)) str(dataset$sample_table) ## &#39;data.frame&#39;: 90 obs. of 4 variables: ## $ SampleID: chr &quot;S1&quot; &quot;S2&quot; &quot;S3&quot; &quot;S4&quot; ... ## $ Group : Factor w/ 3 levels &quot;IW&quot;,&quot;TW&quot;,&quot;CW&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Type : chr &quot;NE&quot; &quot;NE&quot; &quot;NE&quot; &quot;NE&quot; ... ## $ Saline : chr &quot;Non-saline soil&quot; &quot;Non-saline soil&quot; &quot;Non-saline soil&quot; &quot;Non-saline soil&quot; ... t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) t1$cal_ordination(ordination = &quot;PCoA&quot;) ## The ordination result is stored in object$res_ordination ... t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_group_ellipse = TRUE) 10.6 add layers to plot Most of the plots are generated by applying the ggplot2 package. The important parameters in the plotting functions are configured according to our experience. If the inner parameters can not enough, the user can add the layers to the plot like the following operation or make the plot using the data (generally data.frame class) stored in the object. # The groupmean parameter can be used to obtain the group-mean barplot. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) g1 &lt;- t1$plot_bar(others_color = &quot;grey70&quot;, legend_text_italic = FALSE) g1 + theme_classic() + theme(axis.title.y = element_text(size = 18)) "],["mecodev-package.html", "Chapter 11 mecodev package 11.1 trans_rarefy 11.2 trans_convert 11.3 trans_netchord 11.4 trans_ts 11.5 trans_gamma", " Chapter 11 mecodev package The mecodev package (https://github.com/ChiLiubio/mecodev/) is designed to develop more classes for data analysis based on the microeco package. 11.1 trans_rarefy The class trans_rarefy in mecodev package can be used for the rarefaction and the following plotting to see whether the sequencing depth is enough to cover all the so-called species in the microbial community. library(microeco) library(mecodev) data(sample_info_16S) data(otu_table_16S) # set.seed is used to fix the random number generation to make the results repeatable set.seed(123) dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S) dataset$tidy_dataset() # trans_rarefy class t1 &lt;- trans_rarefy$new(dataset, alphadiv = &quot;Shannon&quot;, depth = c(0, 10, 50, 500, 2000, 4000, 6000, 8000)) t1$plot_rarefy(color_values = rep(&quot;grey&quot;, 100), show_point = TRUE, add_fitting = FALSE, show_legend = FALSE) 11.2 trans_convert The class trans_convert provide several data transformation approaches for the microtable object. The output is also a microtable object. data(dataset) test1 &lt;- trans_convert$new(dataset = dataset) test2 &lt;- test1$convert(method = &quot;log&quot;) # returned test2 is another transformed microtable object 11.3 trans_netchord The class trans_netchord is developed to sum and plot the links number from one taxa to another or in the same taxa in the network. The input dataset must be a trans_network object. Creating the trans_netchord object can sum the links (edge) number from one taxa to another or in the same taxa. The function plot_sum_links() is used to show the result from the function cal_sum_links(). This is very useful to fast see how many nodes are connected between different taxa or within one taxa. In terms of “Phylum” level in the tutorial, the function cal_sum_links() sum the linkages number from one Phylum to another Phylum or the linkages in the same Phylum. So the numbers along the outside of the circular plot represent how many edges or linkages are related with the Phylum. For example, in terms of Proteobacteria, there are roughly total 900 edges associated with the OTUs in Proteobacteria, in which roughly 200 edges connect both OTUs in Proteobacteria and roughly 150 edges connect the OTUs from Proteobacteria with the OTUs from Chloroflexi. # Let&#39;s first create a network data(sample_info_16S) data(otu_table_16S) data(taxonomy_table_16S) dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, tax_table = taxonomy_table_16S) dataset$tidy_dataset() t1 &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;WGCNA&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001, cor_method = &quot;spearman&quot;) t1$cal_network(p_thres = 0.01, COR_cut = 0.7) # trans_netchord test1 &lt;- trans_netchord$new(dataset = t1, taxa_level = &quot;Phylum&quot;) # require chorddiag package (https://github.com/mattflor/chorddiag) test1$plot_sum_links(plot_pos = TRUE, plot_num = 10) 11.4 trans_ts The class trans_ts is designed for the time series data analysis. A commonly used approach for modeling microbial ecology for time series data is the generalized Lotka-Volterra (gLV) model, the classical predator-prey systems. gLV models are based on ordinary differential equations that model the logistic growth of species; naturally capture predator-prey, amensalistic, and competitive interactions; and have been applied to study dynamics of microbial ecosystems. More importantly, from a practical perspective, gLV models have been used for a range of applications including identifying potential probiotics against pathogens, forecasting changes in microbial density, characterizing important community members (e.g., keystone species), and analyzing community stability (see (Li et al. 2019) and the references therein). Currently, the biomass estimation and biological interaction prediction approaches are implemented based on the beem package (Li et al. 2019). The example data ‘gut_microb_ts’ comes from the article (Gibbons et al. 2017). # R package beem should be first installed; see https://github.com/ChiLiubio/mecodev for installation steps library(mecodev) # load the example data in mecodev package; the input must be a microtable object # There are several strict requirements on the sample_table; see the document of the class. data(&quot;gut_microb_ts&quot;) # generally, using filter_thres to filter the taxa with low abundance is crutial # there are only 22 taxa in the example data, we use 0 t1 &lt;- trans_ts$new(dataset = gut_microb_ts, filter_thres = 0) # we use minimal 50 times for iteration t1$cal_biomass(min_iter = 50) # return t1$res_biomass and t1$res_param # generate the inferred biological network t1$cal_network() # Now let&#39;s use trans_network class to add the modules library(microeco) t2 &lt;- trans_network$new(dataset = gut_microb_ts, cal_cor = NA) t2$res_network &lt;- t1$res_network # use cluster_optimal; as the default cluster_fast_greedy can not be used for the directed network t2$cal_module(method = &quot;cluster_optimal&quot;) plot(t2$res_network) 11.5 trans_gamma The class trans_gamma is developed to explore the relationship between gamma diversity and beta diversity based on the methods from biogeographic studies(Zhang et al. 2020). Currently, the contents include the observed beta-gamma diversity relationship, simulated beta-gamma diversity relationship and the following plotting. If the observed gamma diversity and beta diversity are significantly correlated, species pool at regional scale (or maybe your defined scale, e.g., different treatments in the lab) can have large effect on the beta diversity. Thus, species pool should be first considered to explain beta diversity patterns. This class also provide simulation function to explore the relation between gamma diversity and beta diversity in the absence of any process other than random sampling based on the species log-normal distribution. We use the wetland data to show the observed beta-gamma diversity relationship. library(microeco) library(mecodev) # load the example data data(sample_info_16S) data(otu_table_16S) test &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S) test$tidy_dataset() test$rarefy_samples(sample.size = 10000) # then create trans_gamma object test1 &lt;- trans_gamma$new(dataset = test, group = &quot;Type&quot;, method = &quot;bray&quot;) test1$cal_observed(sample_size = NULL) test1$res_observed # use Spearman correlation test1$plot_observed(cor_method = &quot;spearman&quot;) Let’s simulate the relation between gamma diversity and beta diversity in the absence of any process other than random sampling based on the species log-normal distribution. # if you only run the simulation, dataset parameter is not necessary test1 &lt;- trans_gamma$new(method = &quot;bray&quot;) # use individul numbers at 200, 1000 and 2000, and hypothesize each species pool have 20 samples. test1$cal_simulation(ncom = 20, ind_vect = c(200, 1000, 2000)) test1$plot_simulation(add_fitting = FALSE) References "],["other-examples.html", "Chapter 12 Other examples 12.1 Custom taxa order in bar plot 12.2 The importance of tidy_taxonomy function 12.3 Question of prefix in the taxa 12.4 The use of phylogenetic tree", " Chapter 12 Other examples We’ve gathered a few ways to make your analyses easier. We encourage users to contribute some unique, special or helpful examples inspired by the microeco, file2meco and mecodev package. 12.1 Custom taxa order in bar plot Jarrod J. Scott contribute a cool answer to the question that how to use custom taxa and the order in bar plot. This is a discussion topic in microeco Discussions part. Here is the link (https://github.com/ChiLiubio/microeco/discussions/45). 12.2 The importance of tidy_taxonomy function The taxonomic classification with standard prefix is very important for some analyses, e.g. taxonomic abundance plotting and biomarker finding. The tidy_taxonomy function in microeco package is designed to make the taxa having standard prefix. See those Issues for the detailed examples: (https://github.com/ChiLiubio/microeco/issues/32) and (https://github.com/ChiLiubio/microeco/issues/22). 12.3 Question of prefix in the taxa The prefix of taxa in taxonomic table may affect the following performance of plotting, e.g. text in legend. Please see those Issues (https://github.com/ChiLiubio/microeco/issues/32), (https://github.com/ChiLiubio/microeco/issues/7) and (https://github.com/ChiLiubio/microeco/issues/15). 12.4 The use of phylogenetic tree One of Issues referred to the basic use of phylogenetic tree in the microeco package (https://github.com/ChiLiubio/microeco/issues/33). "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
