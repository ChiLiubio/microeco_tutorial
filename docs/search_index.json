[["index.html", "Tutorial for R microeco package (v1.5.0) Chapter 1 Background", " Tutorial for R microeco package (v1.5.0) 2024-03-07 Chapter 1 Background  R language (R Core Team 2016) and its packages ecosystem are wonderful tools for data analysis. In community ecology, a series of packages are available for statistical analysis, such as vegan (Oksanen et al. 2019), ape (Paradis and Schliep 2018) and picante (Kembel et al. 2010). However, with the development of the high-throughput sequencing techniques, the increasing data amount and complexity of studies make the data mining in microbiome a challenge. There have been some R packages created specifically for the statistics and visualization of microbiome data, such as phyloseq (Mcmurdie and Holmes 2013), microbiome (https://github.com/microbiome/microbiome), microbiomeSeq (http://www.github.com/umerijaz/microbiomeSeq), ampvis2 (https://github.com/KasperSkytte/ampvis2), MicrobiomeR(https://github.com/vallenderlab/MicrobiomeR), theseus (Price et al. 2018), rANOMALY (Theil and Rifa 2021), tidyMicro (Carpenter et al. 2021), microbial (https://github.com/guokai8/microbial), amplicon (https://github.com/microbiota/amplicon), MicrobiotaProcess (https://github.com/YuLab-SMU/MicrobiotaProcess) and so on. In addition, some web tools associated with R language are also useful for microbiome data analysis, such as Shiny-phyloseq (McMurdie and Holmes 2015), MicrobiomeExplorer (Reeder et al. 2021), animalcules (Zhao et al. 2021) and Namco (Dietrich et al. 2022). Even so, researchers still lack a flexible, comprehensive and modularized R package to analyze and manage the data fast and easily. Based on this background, we created the R microeco package (C. Liu et al. 2021) (https://github.com/ChiLiubio/microeco). Besides, we also developed the file2meco package (https://github.com/ChiLiubio/file2meco) for the data input from some famous tools easily. References "],["intro.html", "Chapter 2 Introduction 2.1 Framework 2.2 R6 Class 2.3 Help 2.4 RTools 2.5 Dependence 2.6 Plot 2.7 Rstudio", " Chapter 2 Introduction The microeco package has several advantages compared to other packages in R. The primary objective behind the development of this package is to assist users in rapidly analyzing microbiome data, utilizing a range of cutting-edge and commonly adopted methodologies. To facilitate data mining, every component of the microeco package has been modularized to ensure that users can easily recall, search, and employ classes. It is important to note that, in addition to being demonstrated in the tutorial, users can also save intermediate files within each object and utilize them with other tools according to formatting necessities. Main data stored in the object of each class are the frequently-used data.frame format, thereby making it effortless to save, modify, and employ intermediate and outcome files with other microbial ecology tools. Prior to exploring the specific utilization of each class, we shall first introduce a few critical points. 2.1 Framework This is a rough framework for users to fast understand the design of microeco package. The stored ‘Functions’ and ‘Files’ represent that the user can access those functions or files in R6 object using $ operator as shown in the figure. An example is the function dataset$cal_alphadiv() and its return result dataset$alpha_diversity. The dataset is a microtable object. Generally, the return files of functions are named with the prefix ‘res_’ to make users easily find them when using Rstudio and the keyboard shortcuts (Tab). Except for microtable class, the transformed data in created object is generally named with the prefix ‘data_’. 2.2 R6 Class All the main classes in microeco package depend on the R6 class (Chang 2020). R6 uses the encapsulated object-oriented (OO) programming paradigm, which means that R6 is a profoundly different OO system from S3 and S4 because it is built on encapsulated objects, rather than generic functions. If the user is interested in the class features, read more from ‘Advanced R’ book (https://adv-r.hadley.nz/). A generic is a regular function, so it lives in the global namespace. An R6 method belongs to an object so it lives in a local namespace. This influences how we think about naming. The methods belong to objects, not generics, and the user can call them like object$method(). R6’s reference semantics allow methods to simultaneously return a value and modify an object. Every R6 object has an S3 class that reflects its hierarchy of R6 class. 2.3 Help The usage of help documents in the microeco package may be a little different from other packages we often used. If the user wish to see the help document of a function, please search the name of the class it belongs to (not the name of the function) and click the link of the function. # first install microeco, see https://github.com/ChiLiubio/microeco # load package microeco library(microeco) # show all the classes and tutorial links ?microeco # show the detailed description of the class microtable # same with: help(microtable) ?microtable 2.4 RTools For Windows system, RTools (https://cran.r-project.org/bin/windows/Rtools/) is necessary to install some R packages from source, such as R packages deposited in GitHub. 2.5 Dependence 2.5.1 Description To keep the start and use of microeco package simplified, the installation of microeco only depend on several packages, which are compulsory-installed from CRAN and frequently used in the data analysis. So the question is that the user may encounter an error when using a class or function that invoke an additional package like this: library(microeco) data(dataset) test &lt;- trans_network$new(dataset = dataset, filter_thres = 0.001) test$cal_network(network_method = &quot;SpiecEasi&quot;) Error in test$cal_network(network_method = &quot;SpiecEasi&quot;): SpiecEasi package is not installed! The reason is that network construction with ‘SpiecEasi’ method requires SpiecEasi package to be installed. This package is deposited in GitHub and can not be installed automatically. In addition, we donot put some packages released in CRAN and Bioconductor on the “Imports” part of microeco package. The solutions: Install the missing package when encounter such an error. Actually, it’s very easy to install the packages from CRAN or Bioconductor or Github. Just have a try. Install all the packages in advance. This is recommended if the user is interested in most of the methods and want to run a large number of examples in this tutorial. If so, please read all of the following sections and install these packages. 2.5.2 CRAN packages Some packages released in CRAN can not be installed automatically. These packages are necessary to reproduce some parts of the tutorial. If you want to install all of these packages or some of them, please run this: # allow more waiting time to download each package options(timeout = 1000) # If a package is not installed, it will be installed from CRAN # First select the packages of interest tmp &lt;- c(&quot;microeco&quot;, &quot;mecoturn&quot;, &quot;MASS&quot;, &quot;GUniFrac&quot;, &quot;ggpubr&quot;, &quot;randomForest&quot;, &quot;ggdendro&quot;, &quot;ggrepel&quot;, &quot;agricolae&quot;, &quot;igraph&quot;, &quot;picante&quot;, &quot;pheatmap&quot;, &quot;rgexf&quot;, &quot;ggalluvial&quot;, &quot;ggh4x&quot;, &quot;rcompanion&quot;, &quot;FSA&quot;, &quot;gridExtra&quot;, &quot;aplot&quot;, &quot;NST&quot;, &quot;GGally&quot;, &quot;ggraph&quot;, &quot;networkD3&quot;, &quot;poweRlaw&quot;, &quot;ggtern&quot;, &quot;SRS&quot;, &quot;performance&quot;) # Now check or install for(x in tmp){ if(!require(x, character.only = TRUE)) { install.packages(x, dependencies = TRUE) } } 2.5.3 Bioconductor packages Some dependent packages are deposited in bioconductor (https://bioconductor.org). Please run the following commands to install them one by one. Several packages may be installed from source. So, for the Windows system, please make sure RTools has been installed (https://chiliubio.github.io/microeco_tutorial/intro.html#rtools). install.packages(&quot;BiocManager&quot;) install.packages(&quot;file2meco&quot;, repos = BiocManager::repositories()) install.packages(&quot;MicrobiomeStat&quot;, repos = BiocManager::repositories()) install.packages(&quot;WGCNA&quot;, repos = BiocManager::repositories()) BiocManager::install(&quot;ggtree&quot;) BiocManager::install(&quot;metagenomeSeq&quot;) BiocManager::install(&quot;ALDEx2&quot;) BiocManager::install(&quot;ANCOMBC&quot;) 2.5.4 Github packages A part of dependent packages in some methods comes from Github (https://github.com/). Each package from the GitHub platform is accompanied by installation instructions. However, due to the network instability of the platform, certain packages may fail to install online. As a result, in order to facilitate quick and convenient installation, we have collected these GitHub-dependent packages and consolidated them within a dedicated project repository (https://github.com/ChiLiubio/microeco_dependence). Please run the following commands to install them. For the Windows system, first make sure RTools has been installed (https://chiliubio.github.io/microeco_tutorial/intro.html#rtools). # download link of the compressed packages archive # Alternative from Gitee &quot;https://gitee.com/chiliubio/microeco_dependence/releases/download/v0.20.0/microeco_dependence.zip&quot; url &lt;- &quot;https://github.com/ChiLiubio/microeco_dependence/releases/download/v0.20.0/microeco_dependence.zip&quot; # allow more time to download the zip file in R options(timeout = 2000) # Another way is to open the upper url in browser to download the zip file and move it to the current R working directory download.file(url = url, destfile = &quot;microeco_dependence.zip&quot;) # uncompress the file in R tmp &lt;- &quot;microeco_dependence&quot; unzip(paste0(tmp, &quot;.zip&quot;)) # install devtools if(!require(&quot;devtools&quot;, character.only = TRUE)){install.packages(&quot;devtools&quot;, dependencies = TRUE)} # run these one by one devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;SpiecEasi-master.zip&quot;), dependencies = TRUE) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;mixedCCA-master.zip&quot;), dependencies = TRUE) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;SPRING-master.zip&quot;), dependencies = TRUE) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;NetCoMi-main.zip&quot;), repos = BiocManager::repositories()) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;beem-static-master.zip&quot;), dependencies = TRUE) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;chorddiag-master.zip&quot;), dependencies = TRUE) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;ggradar-master.zip&quot;), dependencies = TRUE) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;ggnested-main.zip&quot;), dependencies = TRUE) devtools::install_local(paste0(tmp, &quot;/&quot;, &quot;ggcor-1-master.zip&quot;), dependencies = TRUE) 2.5.5 Gephi Gephi is an excellent network visualization tool and used to open the saved network file, i.e. network.gexf in the tutorial. You can download Gephi and learn how to use it from https://gephi.org/users/download/ 2.5.6 Tax4Fun Tax4Fun is an R package used for predicting the functional potential of prokaryotic communities. install Tax4Fun package install.packages(&quot;RJSONIO&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;biom_0.3.12.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;qiimer_0.9.4.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) install.packages(system.file(&quot;extdata&quot;, &quot;Tax4Fun_0.3.1.tar.gz&quot;, package=&quot;microeco&quot;), repos = NULL, type = &quot;source&quot;) download SILVA123 reference data from http://tax4fun.gobics.de/  unzip SILVA123.zip and provide this path to the folderReferenceData parameter of cal_tax4fun function in trans_func class. 2.5.7 Tax4Fun2 Tax4Fun2 is another R package for the the prediction of functional profiles and functional gene redundancies of prokaryotic communities (Wemheuer et al. 2020). It has higher accuracies than PICRUSt and Tax4Fun. The Tax4Fun2 approach implemented in microeco is a little different from the original package. Using Tax4Fun2 approach require the representative fasta file. The user do not need to install Tax4Fun2 R package again. The only thing need to do is to download the blast tool (ignore this if the blast tool has been in the path) and Ref99NR/Ref100NR database (select one). Download blast tools from “https://ftp.ncbi.nlm.nih.gov/blast/executables/blast+” ; e.g. ncbi-blast-****-x64-win64.tar.gz for windows system. Note that some errors can come from the latest versions because of memory issue (https://www.biostars.org/p/413294/). An easy solution is to use previous version (such as 2.5.0). Download Ref99NR.zip from “https://cloudstor.aarnet.edu.au/plus/s/DkoZIyZpMNbrzSw/download” or Ref100NR.zip from “https://cloudstor.aarnet.edu.au/plus/s/jIByczak9ZAFUB4/download”. The alternative of the download link is “https://github.com/ChiLiubio/microeco_extra_data/releases/download/v1.0.0/Tax4Fun2_ReferenceData_v2.zip” or “https://gitee.com/chiliubio/microeco_extra_data/releases/download/v1.0.0/Tax4Fun2_ReferenceData_v2.zip”. Uncompress all the folders. The final folders should be like these structures: blast tools:  |– ncbi-blast-2.5.0+   |—- bin    |—— blastn.exe    |—— makeblastdb.exe    |—— …… Ref99NR:  |– Tax4Fun2_ReferenceData_v2   |—- Ref99NR    |—— otu000001.tbl.gz    |—— ……    |—— Ref99NR.fasta    |—— Ref99NR.tre The path “Tax4Fun2_ReferenceData_v2” will be required in the trans_func$cal_tax4fun2() function. The blast tool path “ncbi-blast-2.5.0+/bin” is also required if it is not added to the system env path (environmental variable). # Either seqinr or Biostrings package should be installed for reading and writing fasta file install.packages(&quot;seqinr&quot;, dependencies = TRUE) # or install Biostrings from bioconductor https://bioconductor.org/packages/release/bioc/html/Biostrings.html # Now we show how to read the fasta file # see https://github.com/ChiLiubio/file2meco to install file2meco rep_fasta_path &lt;- system.file(&quot;extdata&quot;, &quot;rep.fna&quot;, package=&quot;file2meco&quot;) rep_fasta &lt;- seqinr::read.fasta(rep_fasta_path) # or use Biostrings package rep_fasta &lt;- Biostrings::readDNAStringSet(rep_fasta_path) # try to create a microtable object with rep_fasta data(&quot;otu_table_16S&quot;) # In microtable class, all the taxa names should be necessarily included in rep_fasta otu_table_16S &lt;- otu_table_16S[rownames(otu_table_16S) %in% names(rep_fasta), ] test &lt;- microtable$new(otu_table = otu_table_16S, rep_fasta = rep_fasta) test 2.6 Plot Most of the plots in the package rely on the ggplot2 package system. We provide some parameters to optimize the corresponding plot, but it may be far from enough. The user can also assign the output a name and use the ggplot2-style grammers to modify it. Each data table used for visualization is stored in the object and can be saved for the customized analysis. Of course, the user can also directly modify the class and reload them to use. Any contribution of a modified class is appreciated via Github-Pull requests (https://github.com/ChiLiubio/microeco_tutorial/pulls) or Email (liuchi0426@126.com). 2.7 Rstudio The modular design of help documentation can facilitate the document viewing. However, in Rtudio, there may be instances where the links fail to navigate properly. In such cases, the issue can be resolved by reopening a document window, as illustrated in the figure below. References "],["basic-class.html", "Chapter 3 Basic class 3.1 microtable class", " Chapter 3 Basic class The microtable class is the basic class. All the other classes depend on the microtable class. The objects inside the rectangle with full line represent functions. The red rectangle means it is extremely important function. The dashed line denotes the key objects (input or output of functions) that deserve more attention. 3.1 microtable class  Many tools can be used for the bioinformatic analysis of amplicon sequencing data, such as QIIME (Caporaso et al. 2010), QIIME2 (Bolyen et al. 2019), usearch (https://www.drive5.com/usearch/), mothur (Schloss et al. 2009), SILVAngs (https://ngs.arb-silva.de/silvangs/), LotuS2 (Ozkurt et al. 2022), and RDP (http://rdp.cme.msu.edu/). Although the formats of result files may vary across tools, the main contents can be generally classified into the following parts: (1) OTU/ASV table, i.e. the feature-sample abundance table; (2) taxonomic assignment table; (3) representative sequences; (4) phylogenetic tree; (5) metadata. It is generally useful to create a detailed sample metadata table to store all the sample information (including the environmental data).  The microtable class is the basic class and designed to store the basic data for all the downstream analysis in the microeco package. At least, the OTU table (i.e. feature-sample abundance table) should be provided to create microtable object. Thus, the microtable class can determine that the sample information table is missing and create a default sample table according to sample names in otu_table. To make the file input more convenient, we also build another R package file2meco (https://github.com/ChiLiubio/file2meco) to read the output files of some tools into microtable object. Currently, those tools/softwares include not only commonly-used QIIME (Caporaso et al. 2010) and QIIME2(Bolyen et al. 2019), but also several metagenomic tools, such as HUMAnN (Franzosa et al. 2018) and kraken2 (Wood, Lu, and Langmead 2019). In this tutorial, the data inside the package was employed to show some basic operations. 3.1.1 Prepare the example data  The example data inside the microeco package is used to show the main part of the tutorial. This dataset arose from 16S rRNA gene Miseq sequencing results of wetland soils in China published by An et al. (An et al. 2019), who surveyed soil prokaryotic communities in Chinese inland wetlands (IW), coastal wetland (CW) and Tibet plateau wetlands (TW) using amplicon sequencing. These wetlands include both saline and non-saline samples (classified for the tutorial). The sample information table has 4 columns: “SampleID”, “Group”, “Type” and “Saline”. The column “SampleID” is same with the rownames. The column “Group” represents the IW, CW and TW. The column “Type” means the sampling region: northeastern region (NE), northwest region (NW), North China area (NC), middle-lower reaches of the Yangtze River (YML), southern coastal area (SC), upper reaches of the Yangtze River (YU), Qinghai-Tibet Plateau (QTP). The column “Saline” denotes the saline soils and non-saline soils. In this dataset, the environmental factor table is separated from the sample information table. It is also recommended to put all the environmental data into sample information table. library(microeco) # load the example data; 16S rRNA gene amplicon sequencing dataset # metadata table; data.frame data(sample_info_16S) # feature table; data.frame data(otu_table_16S) # taxonomic assignment table; data.frame data(taxonomy_table_16S) # phylogenetic tree; not necessary; use for the phylogenetic analysis # Newick format; use read.tree function of ape package to read a tree data(phylo_tree_16S) # load the environmental data table if it is not in sample table data(env_data_16S) # use pipe operator in magrittr package library(magrittr) # fix the random number generation to make the results repeatable set.seed(123) # make the plotting background same with the tutorial library(ggplot2) theme_set(theme_bw()) Make sure that the data types of sample_table, otu_table and tax_table are all data.frame format as the following part shows. class(otu_table_16S) ## [1] &quot;data.frame&quot; otu_table_16S[1:5, 1:5]   S1 S2 S3 S4 S5 OTU_4272 1 0 1 1 0 OTU_236 1 4 0 2 35 OTU_399 9 2 2 4 4 OTU_1556 5 18 7 3 2 OTU_32 83 9 19 8 102 class(taxonomy_table_16S) ## [1] &quot;data.frame&quot; taxonomy_table_16S[1:5, 1:3]   Kingdom Phylum Class OTU_4272 k__Bacteria p__Firmicutes c__Bacilli OTU_236 k__Bacteria p__Chloroflexi c__ OTU_399 k__Bacteria p__Proteobacteria c__Betaproteobacteria OTU_1556 k__Bacteria p__Acidobacteria c__Acidobacteria OTU_32 k__Archaea p__Miscellaneous Crenarchaeotic Group c__ Generally, users’ taxonomic table has some messy information, such as NA, unidentified and unknown. These information can potentially influence the following taxonomic abundance calculation and other taxonomy-based analysis. So it is usually necessary to clean this data using the tidy_taxonomy function. Another very important result of this operation is to unify the taxonomic prefix automatically, e.g., converting D_1__ to p__ for Phylum level or adding p__ to Phylum directly if no prefix is found. # make the taxonomic information unified, very important taxonomy_table_16S %&lt;&gt;% tidy_taxonomy The rownames of sample_table in microtable object (i.e. sample names) are used for selecting samples/groups in all the related operations in the package. Using pure number as sample names is not recommended in case of unknown disorder or man-made mistake. Before creating microtable object, make sure that the rownames of sample information table are sample names. class(sample_info_16S) ## [1] &quot;data.frame&quot; sample_info_16S[1:5, ]   SampleID Group Type Saline S1 S1 IW NE Non-saline soil S2 S2 IW NE Non-saline soil S3 S3 IW NE Non-saline soil S4 S4 IW NE Non-saline soil S5 S5 IW NE Non-saline soil In this example, the environmental data is stored in the env_data_16S alone. The user can also directly integrate those data into the sample information table. class(env_data_16S) ## [1] &quot;data.frame&quot;   Latitude Longitude Altitude Temperature Precipitation S1 52.96 122.6 432 -4.2 445 S2 52.95 122.6 445 -4.3 449 S3 52.95 122.6 430 -4.3 449 S4 52.95 122.6 430 -4.3 449 S5 52.95 122.6 429 -4.3 449 class(phylo_tree_16S) ## [1] &quot;phylo&quot; Then, we create an object of microtable class. This operation is very similar with the package phyloseq(Mcmurdie and Holmes 2013), but in microeco it is more brief. The otu_table in the microtable class must be the feature-sample format: rownames - OTU/ASV/pathway/other names; colnames - sample names. The colnames in otu_table must have overlap with rownames of sample_table. Otherwise, the following check can filter all the samples of otu_table because of no same sample names between otu_table and sample_table. # In R6 class, &#39;$new&#39; is the original method used to create a new object of class # If you only provide abundance table, the class can help you create a sample info table dataset &lt;- microtable$new(otu_table = otu_table_16S) ## No sample_table provided, automatically use colnames in otu_table to create one ... class(dataset) ## [1] &quot;microtable&quot; &quot;R6&quot; # generally add the metadata dataset &lt;- microtable$new(otu_table = otu_table_16S, sample_table = sample_info_16S) dataset ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns # Let&#39;s create a microtable object with more information dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, tax_table = taxonomy_table_16S, phylo_tree = phylo_tree_16S) dataset ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13628 rows and 7 columns ## phylo_tree have 14096 tips 3.1.2 How to read your files to microtable object? The above-mentioned example data are directly loaded from microeco package. So the question is how to read your data to create a microtable object? There are two ways: ▲ 1. Use file2meco package R package file2meco (https://chiliubio.github.io/microeco_tutorial/file2meco-package.html) is designed to directly read the output files of some famous tools into microtable object. Currently, it supports QIIME (Caporaso et al. 2010), QIIME2(Bolyen et al. 2019), HUMAnN (Franzosa et al. 2018), MetaPhlAn (Truong et al. 2015), kraken2 (Wood, Lu, and Langmead 2019), phyloseq (Mcmurdie and Holmes 2013), etc. Please read the tutorial of file2meco package for more detailed information (https://chiliubio.github.io/microeco_tutorial/file2meco-package.html). ▲ 2. Other cases To transform customized files to microtable object, there should be two steps: I) read files to R The required format of microtable$new parameters, otu_table, sample_table and tax_table, are all the data.frame, which is the most frequently-used data format in R. So no matter what the format the files are, they should be first read into R with some functions, such as read.table and read.csv. If the user want to perform phylogenetic analysis, please also read your phylogenetic tree using read.tree function of ape package and provide the tree to the phylo_tree parameter of microtable$new function like the above example. II) create the microtable object Then the user can create the microtable object like the operation in the last section. Please also see the help document of the microtable class for detailed descriptions using the following help command. # search the class name, not the function name ?microtable # then see microtable$new() 3.1.3 Functions in microtable class Then, we remove OTUs which are not assigned in the Kingdom “k__Archaea” or “k__Bacteria”. # use R subset function to filter taxa in tax_table dataset$tax_table %&lt;&gt;% base::subset(Kingdom == &quot;k__Archaea&quot; | Kingdom == &quot;k__Bacteria&quot;) # another way with grepl function dataset$tax_table %&lt;&gt;% .[grepl(&quot;Bacteria|Archaea&quot;, .$Kingdom), ] dataset ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13330 rows and 7 columns ## phylo_tree have 14096 tips We also remove OTUs with the taxonomic assignments “mitochondria” or “chloroplast”. # This will remove the lines containing the taxa word regardless of taxonomic ranks and ignoring word case in the tax_table. # So if you want to filter some taxa not considerd pollutions, please use subset like the previous operation to filter tax_table. dataset$filter_pollution(taxa = c(&quot;mitochondria&quot;, &quot;chloroplast&quot;)) ## Total 34 features are removed from tax_table ... dataset ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 13628 rows and 90 columns ## tax_table have 13296 rows and 7 columns ## phylo_tree have 14096 tips To make the OTU and sample information consistent across all files in the dataset object, we use function tidy_dataset to trim the dataset. dataset$tidy_dataset() print(dataset) ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 13296 rows and 90 columns ## tax_table have 13296 rows and 7 columns ## phylo_tree have 13296 tips Then let’s use sample_sums() to check the sequence numbers in each sample. dataset$sample_sums() %&gt;% range ## [1] 10316 37087 Sometimes, in order to reduce the effects of sequencing depth on the diversity measurements, it is optional to perform the resampling to make the sequence number equal for each sample. The function rarefy_samples can invoke the function tidy_dataset automatically before and after the rarefying. In v0.19.0, method = 'SRS' is available to perfom normalization by scaling with ranked subsampling (Beule and Karlovsky 2020). The default method is method = 'rarefying'. # As an example, use 10000 sequences in each sample dataset$rarefy_samples(sample.size = 10000) ## 530 features are removed because they are no longer present in any sample after random subsampling ... ## 530 taxa with 0 abundance are removed from the otu_table ... dataset$sample_sums() %&gt;% range ## [1] 10000 10000 For v0.17.0, the function save_table can be performed to save all the basic data in microtable object to local files, including feature abundance, metadata, taxonomic table, phylogenetic tree and representative sequences. dataset$save_table(dirpath = &quot;basic_files&quot;, sep = &quot;,&quot;) Then, let’s calculate the taxa abundance at each taxonomic rank using cal_abund(). This function generate a list called taxa_abund stored in the microtable object. This list contain several data frame of the abundance information at each taxonomic rank. It’s worth noting that the cal_abund() function can be used to solve more complicated cases with special parameters, such as supporting both the relative and absolute abundance calculation and selecting the partial ‘taxonomic’ columns. Those have been shown in file2meco package part (https://chiliubio.github.io/microeco_tutorial/file2meco-package.html#humann-metagenomic-results) with complex metagenomic dataset. # use default parameters dataset$cal_abund() ## The result is stored in object$taxa_abund ... # return dataset$taxa_abund class(dataset$taxa_abund) ## [1] &quot;list&quot; # show part of the relative abundance at Phylum level dataset$taxa_abund$Phylum[1:5, 1:5]   S1 S2 S3 S4 S5 **k__Bacteria|p__Proteobacteria** 0.2008 0.1996 0.2151 0.261 0.1663 **k__Bacteria|p__Chloroflexi** 0.1215 0.1937 0.1588 0.1471 0.3098 **k__Bacteria|p__Bacteroidetes** 0.1816 0.0359 0.0267 0.0215 0.0266 **k__Bacteria|p__Acidobacteria** 0.1215 0.2467 0.2532 0.262 0.2482 **k__Bacteria|p__Actinobacteria** 0.1182 0.0861 0.0875 0.0954 0.0824 The function save_abund() can be used to save the taxa abundance file to a local place easily. dataset$save_abund(dirpath = &quot;taxa_abund&quot;) All the abundance tables can also be merged into one to save from v0.15.0. This type of file format can be opened directly by other software, such as STAMP. # tab-delimited, i.e. mpa format dataset$save_abund(merge_all = TRUE, sep = &quot;\\t&quot;, quote = FALSE) # remove those unclassified dataset$save_abund(merge_all = TRUE, sep = &quot;\\t&quot;, rm_un = TRUE, rm_pattern = &quot;__$|Sedis$&quot;, quote = FALSE) Then, let’s calculate the alpha diversity. The result is also stored in the object microtable automatically. # If you want to add Faith&#39;s phylogenetic diversity, use PD = TRUE, this will be a little slow dataset$cal_alphadiv(PD = FALSE) ## The result is stored in object$alpha_diversity ... # return dataset$alpha_diversity class(dataset$alpha_diversity) ## [1] &quot;data.frame&quot; # save dataset$alpha_diversity to a directory dataset$save_alphadiv(dirpath = &quot;alpha_diversity&quot;) Let’s go on to beta diversity with function cal_betadiv(). If method parameter is not provided, the function automatically calculates Bray-curtis, Jaccard, weighted Unifrac and unweighted unifrac matrixes (Lozupone and Knight 2005). # unifrac = FALSE means do not calculate unifrac metric # require GUniFrac package installed dataset$cal_betadiv(unifrac = TRUE) # return dataset$beta_diversity class(dataset$beta_diversity) # save dataset$beta_diversity to a directory dataset$save_betadiv(dirpath = &quot;beta_diversity&quot;) 3.1.4 merge taxa or samples Merging taxa according to a specific taxonomic rank level of tax_table can generate a new microtable object. In the new microtable object, each feature in otu_table represents one taxon at the output level. test &lt;- dataset$merge_taxa(taxa = &quot;Genus&quot;) test ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 1245 rows and 90 columns ## tax_table have 1245 rows and 6 columns Similarly, merging samples according to a specific group of sample_table can also generate a new microtable object. test &lt;- dataset$merge_samples(use_group = &quot;Group&quot;) test ## microtable-class object: ## sample_table have 3 rows and 1 columns ## otu_table have 12766 rows and 3 columns ## tax_table have 12766 rows and 7 columns ## phylo_tree have 12766 tips 3.1.5 subset of samples We donnot provide a special function to filter samples in microtable object, as we think it is redundant. We recommend manipulating the sample_table in microtable object directly. For example, if you want to extract samples of ‘CW’ group, please do like this: # remember first clone the whole dataset # see https://chiliubio.github.io/microeco_tutorial/notes.html#clone-function group_CW &lt;- clone(dataset) # select &#39;CW&#39; group_CW$sample_table &lt;- subset(group_CW$sample_table, Group == &quot;CW&quot;) # or: group_CW$sample_table &lt;- subset(group_CW$sample_table, grepl(&quot;CW&quot;, Group)) # use tidy_dataset to trim all the basic files group_CW$tidy_dataset() group_CW ## microtable-class object: ## sample_table have 30 rows and 4 columns ## otu_table have 9727 rows and 30 columns ## tax_table have 9727 rows and 7 columns ## phylo_tree have 9727 tips ## Taxa abundance: calculated for Kingdom,Phylum,Class,Order,Family,Genus,Species ## Alpha diversity: calculated for Observed,Chao1,se.chao1,ACE,se.ACE,Shannon,Simpson,InvSimpson,Fisher,Pielou,Coverage ## Beta diversity: calculated for bray,jaccard 3.1.6 subset of taxa Similar with above operation, subset of features can be achieved by manipulating the tax_table in microtable object directly. proteo &lt;- clone(dataset) proteo$tax_table &lt;- subset(proteo$tax_table, Phylum == &quot;p__Proteobacteria&quot;) # or: proteo$tax_table &lt;- subset(proteo$tax_table, grepl(&quot;Proteobacteria&quot;, Phylum)) proteo$tidy_dataset() proteo ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 3052 rows and 90 columns ## tax_table have 3052 rows and 7 columns ## phylo_tree have 3052 tips ## Taxa abundance: calculated for Kingdom,Phylum,Class,Order,Family,Genus,Species ## Alpha diversity: calculated for Observed,Chao1,se.chao1,ACE,se.ACE,Shannon,Simpson,InvSimpson,Fisher,Pielou,Coverage ## Beta diversity: calculated for bray,jaccard # proteo is a new microtable object with all OTUs coming from phylum Proteobacteria # beta diversity dissimilarity for Proteobacteria proteo$cal_betadiv() ## The result is stored in object$beta_diversity ... 3.1.7 Other examples The function add_rownames2taxonomy can add the rownames of tax_table as the last column of tax_table directly. This operation is very useful in some analysis, e.g. biomarker finding at OTU/ASV level with the relative abundance. test &lt;- clone(dataset) ncol(test$tax_table) test$add_rownames2taxonomy(use_name = &quot;OTU&quot;) ncol(test$tax_table) The filter_taxa function can be applied to filter the features with low abundance or occurrence frequency when needed. For other operations on the features, please directly manipulate the otu_table of your microtable object. # It is better to have a backup before filtering features dataset_filter &lt;- clone(dataset) dataset_filter # In this example, mean relative abundance threshold 0.0001 # occurrence frequency 0.1; 10% samples have the target features dataset_filter$filter_taxa(rel_abund = 0.0001, freq = 0.1) dataset_filter In microtable$new, if auto_tidy = TRUE, the function can automatically use tidy_dataset to make all files uniform. Then, all other functions in microtable will also do this. But if the user changes the file in microtable object, the class can not recognize this modification, the user should use tidy_dataset function to manually trim the microtable object. test &lt;- microtable$new(sample_table = sample_info_16S[1:40, ], otu_table = otu_table_16S, auto_tidy = FALSE) test ## microtable-class object: ## sample_table have 40 rows and 4 columns ## otu_table have 13628 rows and 90 columns test1 &lt;- microtable$new(sample_table = sample_info_16S[1:40, ], otu_table = otu_table_16S, auto_tidy = TRUE) test1 ## microtable-class object: ## sample_table have 40 rows and 4 columns ## otu_table have 12747 rows and 40 columns test1$sample_table %&lt;&gt;% .[1:10, ] test1 ## microtable-class object: ## sample_table have 10 rows and 4 columns ## otu_table have 12747 rows and 40 columns test1$tidy_dataset() test1 ## microtable-class object: ## sample_table have 10 rows and 4 columns ## otu_table have 8864 rows and 10 columns The phylogenetic tree can be read with read.tree function in ape package. # use the example data rep_phylo.tre in file2meco package https://chiliubio.github.io/microeco_tutorial/file2meco-package.html#qiime phylo_file_path &lt;- system.file(&quot;extdata&quot;, &quot;rep_phylo.tre&quot;, package=&quot;file2meco&quot;) tree &lt;- ape::read.tree(phylo_file_path) Other functions and examples are listed here. # clone a complete dataset named test test &lt;- clone(dataset) # rename features in all the files of microtable object test$rename_taxa(newname_prefix = &quot;new_name_&quot;) rownames(test$otu_table)[1:5] rownames(test$tax_table)[1:5] # sum the abundance for each taxon test$taxa_sums() # output sample names of microtable object test$sample_names()[1:5] # output taxa names of microtable object test$taxa_names()[1:5] 3.1.8 Key points sample_table: rownames of sample_table must be sample names used otu_table: rownames must be feature names; colnames must be sample names microtable class: creating microtable object requires at least one file input (otu_table) tidy_taxonomy(): necessary to make taxonomic table have unified format tidy_dataset(): necessary to trim files in microtable object add_rownames2taxonomy(): add the rownames of tax_table as the last column of tax_table cal_abund(): powerful and flexible to cope with complex cases in tax_table, see the parameters taxa_abund: taxa_abund is a list stored in microtable object and have several data frame beta_diversity: beta_diversity is a list stored in microtable object and have several distance matrix References "],["composition-based-class.html", "Chapter 4 Composition-based class 4.1 trans_abund class 4.2 trans_venn class", " Chapter 4 Composition-based class The trans_abund class and trans_venn class are organised into the section ‘Composition-based class’, since they are mainly used to show the composition information of communities. 4.1 trans_abund class  The trans_abund class has several functions to visualize taxonomic abundance based on the ggplot2 package. 4.1.1 Example We first show the bar plot example. # create trans_abund object # select top 8 abundant Phyla. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 8) ## The transformed abundance data is stored in object$data_abund ... # t1 object now include the transformed abundance data t1$abund_data and other elements for the following plotting As the sample number is large, we do not show the sample names in x axis and add the facet to show abundance according to groups. t1$plot_bar(others_color = &quot;grey70&quot;, facet = &quot;Group&quot;, xtext_keep = FALSE, legend_text_italic = FALSE) # return a ggplot2 object Two or more facets are supported with the facet parameter from v0.14.0 by providing a vector with multiple elements. # require package ggh4x, first run install.packages(&quot;ggh4x&quot;) if not installed t1$plot_bar(others_color = &quot;grey70&quot;, facet = c(&quot;Group&quot;, &quot;Type&quot;), xtext_keep = FALSE, legend_text_italic = FALSE, barwidth = 1) The default operation can filter all the unclassified taxa (i.e. p__ or g__ in tax_table that has been processed by tidy_taxonomy function), as those unknown taxa are generally meaningless. However sometimes, these unknown taxa may be meaningful for users. For example, if one want to isolate some unknown species, it is valuable to check the abundance of those unknown taxa. At this time, please see this topic (https://github.com/ChiLiubio/microeco/issues/165) to resolve the issue that how to show unknown taxa with hierarchical taxonomy classification. The alluvial plot is also implemented in the plot_bar function with use_alluvium parameter. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Genus&quot;, ntaxa = 8) # require ggalluvial package # use_alluvium = TRUE make the alluvial plot, clustering =TRUE can be used to reorder the samples by clustering # bar_type = &quot;notfull&quot; can discard &#39;others&#39;; select another color palette p &lt;- t1$plot_bar(bar_type = &quot;notfull&quot;, use_alluvium = TRUE, clustering = TRUE, xtext_angle = 30, xtext_size = 3, color_values = RColorBrewer::brewer.pal(8, &quot;Set2&quot;)) The bar plot can also be performed with group mean values. Note that, from v0.16.0, the parameter group_morestats = TRUE can be used to add more summary statistics in the return data_abund when groupmean parameter is provided. # The groupmean parameter can be used to obtain the group-mean barplot. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) g1 &lt;- t1$plot_bar(others_color = &quot;grey70&quot;, legend_text_italic = FALSE) g1 + theme_classic() + theme(axis.title.y = element_text(size = 18)) The box plot is an excellent way to intuitionally show abundance distribution across groups. # show 15 taxa at Class level t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Class&quot;, ntaxa = 15) t1$plot_box(group = &quot;Group&quot;, xtext_angle = 30) Then we show the heatmap with the high abundant genera. # show 40 taxa at Genus level t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Genus&quot;, ntaxa = 40) t1$plot_heatmap(facet = &quot;Group&quot;, xtext_keep = FALSE, withmargin = FALSE) Line chart is very useful to show the abundance change of taxa along time, space or other gradients. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 5) t1$plot_line() t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Genus&quot;, ntaxa = 5, groupmean = &quot;Type&quot;) t1$plot_line(position = position_dodge(0.3), xtext_angle = 0) Then, we show the pie chart with the group mean values. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 6, groupmean = &quot;Group&quot;) # all pie chart in one row t1$plot_pie(facet_nrow = 1) t1$plot_pie(facet_nrow = 1, add_label = TRUE) The donut and radar charts are implemented from v0.17.0. Please install the dependent packages according to the steps (https://chiliubio.github.io/microeco_tutorial/intro.html#dependence). t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 8, groupmean = &quot;Group&quot;) t1$plot_donut(label = FALSE) t1$plot_donut(label = TRUE) t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 8, groupmean = &quot;Group&quot;) t1$plot_radar(values.radar = c(&quot;0%&quot;, &quot;25%&quot;, &quot;50%&quot;), grid.min = 0, grid.mid = 0.25, grid.max = 0.5) t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 8, groupmean = &quot;Type&quot;) t1$plot_radar(values.radar = c(&quot;0%&quot;, &quot;25%&quot;, &quot;50%&quot;), grid.min = 0, grid.mid = 0.25, grid.max = 0.5) The ternary plot can be used for the case with three samples/groups. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 8, groupmean = &quot;Group&quot;) t1$plot_tern() When the hierarchical abundance data of two levels is needed to be shown in bar plot, the nested legend can be used. # require ggnested package; see https://chiliubio.github.io/microeco_tutorial/intro.html#dependence test1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Class&quot;, ntaxa = 10, high_level = &quot;Phylum&quot;, prefix = &quot;\\\\|&quot;) test1$plot_bar(ggnested = TRUE, facet = c(&quot;Group&quot;, &quot;Type&quot;), xtext_angle = 30) # fixed number in each phylum test1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Class&quot;, ntaxa = 30, show = 0, high_level = &quot;Phylum&quot;, high_level_fix_nsub = 4) test1$plot_bar(ggnested = TRUE, xtext_angle = 30, facet = c(&quot;Group&quot;, &quot;Type&quot;)) # sum others in each phylum test1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Class&quot;, ntaxa = 20, show = 0, high_level = &quot;Phylum&quot;, high_level_fix_nsub = 3, prefix = &quot;\\\\|&quot;) test1$plot_bar(ggnested = TRUE, high_level_add_other = TRUE, xtext_angle = 30, facet = c(&quot;Group&quot;, &quot;Type&quot;)) The coord_flip parameter in plot_bar function can be changed to make the coordinate axis flipped. The clustering plot can also be added in the bar plot. In this case, the coordinate axis will be flipped automatically for better visualization. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) g1 &lt;- t1$plot_bar(coord_flip = TRUE) g1 &lt;- g1 + theme_classic() + theme(axis.title.x = element_text(size = 16), axis.ticks.y = element_blank(), axis.line.y = element_blank()) g1 g1 &lt;- t1$plot_bar(clustering_plot = TRUE) # In this case, g1 (aplot object) is the combination of different ggplot objects # to adjust the main plot, please select g1[[1]] g1[[1]] &lt;- g1[[1]] + theme_classic() + theme(axis.title.x = element_text(size = 16), axis.ticks.y = element_blank(), axis.line.y = element_blank()) g1 # save the figure ggsave(&quot;test.png&quot;, g1, width = 8, height = 5) 4.1.2 Key points trans_abund$new: creating trans_abund object can invoke taxa_abund in microtable for transformation color_values parameter: color_values parameter in each function is used for colors selection input_taxaname parameter: input_taxaname parameter in trans_abund$new can be used to select interested customized taxa instead of abundance-based selection use_percentage parameter: use_percentage parameter in trans_abund$new - whether show the abundance percentage 4.2 trans_venn class The trans_venn class is developed for venn analysis, i.e. shared and unique taxa across samples/groups. 4.2.1 Example This part can be performed using samples or groups at OTU/ASV level or higher taxonomic level. To analyze the unique and shared OTUs of groups, we first merge samples according to the “Group” column of sample_table. # merge samples as one community for each group dataset1 &lt;- dataset$merge_samples(use_group = &quot;Group&quot;) # dataset1 is a new microtable object # create trans_venn object t1 &lt;- trans_venn$new(dataset1, ratio = NULL) t1$plot_venn() # create venn plot with more information t1 &lt;- trans_venn$new(dataset1, ratio = &quot;seqratio&quot;) t1$plot_venn() # The integer is OTU number # The percentage data is the sequence number/total sequence number When the groups are too many to show with venn plot, using petal plot is better. To assign different colors in petals, please provide multiple colors to petal_color parameter. # use &quot;Type&quot; column in sample_table dataset1 &lt;- dataset$merge_samples(use_group = &quot;Type&quot;) t1 &lt;- trans_venn$new(dataset1) t1$plot_venn(petal_plot = TRUE, petal_color = RColorBrewer::brewer.pal(8, &quot;Dark2&quot;)) t1$plot_venn(petal_plot = TRUE, petal_center_size = 50, petal_r = 1.5, petal_a = 3, petal_move_xy = 3.8, petal_color_center = &quot;#BEBADA&quot;) Another way to plot the results is to use plot_bar function, which is especially useful for a large number of samples/groups. This way is generally called UpSet plot. Please see the help document for more parameters to adjust the plot. tmp &lt;- dataset$merge_samples(use_group = &quot;Type&quot;) tmp t1 &lt;- trans_venn$new(dataset = tmp) # only show some sets with large intersection numbers t1$data_summary %&lt;&gt;% .[.[, 1] &gt; 20, ] g1 &lt;- t1$plot_bar(left_plot = TRUE, bottom_height = 0.5, left_width = 0.15, up_bar_fill = &quot;grey50&quot;, left_bar_fill = &quot;grey50&quot;, bottom_point_color = &quot;black&quot;) g1 # g1 is aplot class and can be saved with ggplot2::ggsave, aplot::ggsave or cowplot::save_plot function # as g1 is comprised of several sub-plots, please adjust the details for each sub-plot g1[[1]] g1[[2]] Generally, after getting the intersection results, we do not know who those shared or unique taxa are. The composition of the unique or shared species may account for the different and similar parts of ecological characteristics across groups(Mendes et al. 2011). So, it is interesting to further analyze the composition of unique and shared species. For this goal, we first transform the results of venn plot to the traditional feature-sample table, that is, another object of microtable class. dataset1 &lt;- dataset$merge_samples(use_group = &quot;Group&quot;) t1 &lt;- trans_venn$new(dataset1) ## The details of each venn part is stored in object$data_details ... ## The venn summary table used for plot is stored in object$data_summary ... # transform venn results to the sample-species table, here do not consider abundance, only use presence/absence. t2 &lt;- t1$trans_comm(use_frequency = TRUE) # t2 is a new microtable class, each part is considered a sample class(t2) ## [1] &quot;microtable&quot; &quot;R6&quot; We use bar plot to show the composition at the Genus level. # calculate taxa abundance, that is, the frequency t2$cal_abund() # transform and plot t3 &lt;- trans_abund$new(dataset = t2, taxrank = &quot;Genus&quot;, ntaxa = 8) t3$plot_bar(bar_type = &quot;part&quot;, legend_text_italic = T, xtext_angle = 30, color_values = RColorBrewer::brewer.pal(8, &quot;Set2&quot;), order_x = c(&quot;IW&quot;, &quot;CW&quot;, &quot;TW&quot;, &quot;IW&amp;CW&quot;, &quot;IW&amp;TW&quot;, &quot;CW&amp;TW&quot;, &quot;IW&amp;CW&amp;TW&quot;)) + ylab(&quot;Frequency (%)&quot;) We also try to use pie chart to show the compositions at the Phylum level. t3 &lt;- trans_abund$new(dataset = t2, taxrank = &quot;Phylum&quot;, ntaxa = 8) t3$data_abund$Sample %&lt;&gt;% factor(., levels = unique(.)) t3$plot_pie(facet_nrow = 3, color_values = c(RColorBrewer::brewer.pal(8, &quot;Dark2&quot;), &quot;grey50&quot;)) Other examples: To reorder samples in the plots, please manipulate the sample_table in the object to adjust the orders. test &lt;- dataset$merge_samples(use_group = &quot;Type&quot;) test$sample_table %&lt;&gt;% .[c(&quot;YML&quot;, &quot;NE&quot;, &quot;NW&quot;, &quot;NC&quot;, &quot;QTP&quot;, &quot;SC&quot;), , drop = FALSE] test$tidy_dataset() # The columns of otu_table can also be reordered according to the sample_table after running tidy_dataset function t1 &lt;- trans_venn$new(test) t1$plot_bar(sort_samples = FALSE) The parameter sort_samples = TRUE in plot_bar function can be applied to sort samples in the y axis according to the number of features. The left bar plot can be removed when the parameter left_plot = FALSE. test &lt;- dataset$merge_samples(use_group = &quot;Type&quot;) t1 &lt;- trans_venn$new(test) # remove left bar in the UpSet plot t1$plot_bar(left_plot = FALSE) # sort samples in the axis according to the number of features t1$plot_bar(sort_samples = TRUE) # original orders in test$sample_table t1$plot_bar(sort_samples = FALSE) 4.2.2 Key points ratio parameter: ratio parameter in trans_abund$new control whether and what content appear below the taxa number in venn plot return data: using trans_venn$new() return data_details and data_summary stored in trans_venn object for further ploting References "],["diversity-based-class.html", "Chapter 5 Diversity-based class 5.1 trans_alpha class 5.2 trans_beta class", " Chapter 5 Diversity-based class Diversity is one of the core topics in community ecology. It refers to alpha diversity, beta diversity and gamma diversity. 5.1 trans_alpha class  Alpha diversity can be transformed and visualized using trans_alpha class. Creating the object of trans_alpha class can invoke the alpha_diversity data stored in the microtable object. 5.1.1 Example Creating trans_alpha object can return two data.frame with prefix ‘data_’: data_alpha and data_stat. The data_alpha is used for the following differential test and visualization. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) # return t1$data_stat head(t1$data_stat) ## The transformed diversity data is stored in object$data_alpha ... ## The group statistics are stored in object$data_stat ... Group Measure N Mean SD SE CW Observed 30 1843 220.6 40.27 CW Chao1 30 2553 338.1 61.73 CW ACE 30 2716 367 67.01 CW Shannon 30 6.308 0.5355 0.09777 CW Simpson 30 0.9897 0.01305 0.002382 CW InvSimpson 30 198.8 108.4 19.8 Then, we test the differences among groups using Kruskal-Wallis Rank Sum Test (overall test when groups &gt; 2), Wilcoxon Rank Sum Tests (for paired groups), Dunn’s Kruskal-Wallis Multiple Comparisons (for paired groups when groups &gt; 2) and anova with multiple comparisons. t1$cal_diff(method = &quot;KW&quot;) # return t1$res_diff head(t1$res_diff) ## The result is stored in object$res_diff ... Comparison Measure Group P.unadj P.adj Significance IW - CW - TW Observed IW 0.155 0.2791 ns IW - CW - TW Chao1 IW 0.01696 0.05088 ns IW - CW - TW ACE IW 0.01333 0.05088 ns IW - CW - TW Shannon IW 0.5319 0.7978 ns IW - CW - TW Simpson CW 0.8083 0.9094 ns IW - CW - TW InvSimpson CW 0.8083 0.9094 ns t1$cal_diff(method = &quot;KW_dunn&quot;) # return t1$res_diff head(t1$res_diff) ## P value adjustment method: holm ... ## The result is stored in object$res_diff ... Measure Test_method Group Letter MonoLetter Observed Dunn’s Kruskal-Wallis Multiple Comparisons IW a a Observed Dunn’s Kruskal-Wallis Multiple Comparisons TW a a Observed Dunn’s Kruskal-Wallis Multiple Comparisons CW a a Chao1 Dunn’s Kruskal-Wallis Multiple Comparisons IW a a Chao1 Dunn’s Kruskal-Wallis Multiple Comparisons TW ab ab Chao1 Dunn’s Kruskal-Wallis Multiple Comparisons CW b b # more options t1$cal_diff(method = &quot;KW_dunn&quot;, KW_dunn_letter = FALSE) head(t1$res_diff) t1$cal_diff(method = &quot;wilcox&quot;) head(t1$res_diff) t1$cal_diff(method = &quot;t.test&quot;) Then, let’s try to use anova. From v1.0.0, the alpha parameter can be used to adjust the significance threshold (default: 0.05) of multiple comparisons when method is ‘anova’ or ‘KW_dunn’. t1$cal_diff(method = &quot;anova&quot;) # return t1$res_diff head(t1$res_diff) ## Perform post hoc test with the method: duncan.test ... ## The result is stored in object$res_diff ... Measure Test_method Group Letter Observed anova IW a Observed anova TW a Observed anova CW a Chao1 anova IW a Chao1 anova TW ab Chao1 anova CW b The multi-factor analysis of variance is also supported with the formula parameter, such as two-way anova. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) t1$cal_diff(method = &quot;anova&quot;, formula = &quot;Group+Type&quot;) head(t1$res_diff) # see the help document for the usage of formula The plot_alpha function add the significance label by searching the results in object$res_diff instead of calculating the significance again. Now, let’s plot the alpha diversity for each group, and add the anova result. t1$cal_diff(method = &quot;anova&quot;) # y_increase can adjust the distance from the letters to the highest point t1$plot_alpha(measure = &quot;Chao1&quot;, y_increase = 0.3) t1$plot_alpha(measure = &quot;Chao1&quot;, y_increase = 0.1) # add_sig_text_size: letter size adjustment t1$plot_alpha(measure = &quot;Chao1&quot;, add_sig_text_size = 6, boxplot_add = &quot;jitter&quot;, order_x_mean = TRUE) t1$cal_diff(method = &quot;wilcox&quot;) t1$plot_alpha(measure = &quot;Chao1&quot;, shape = &quot;Group&quot;) # y_start: starting height for the first label # y_increase: increased height for each label t1$plot_alpha(measure = &quot;Chao1&quot;, shape = &quot;Group&quot;, y_start = 0.1, y_increase = 0.1) Let’s try to remove the ‘ns’ in the label by manipulating the object$res_diff. t1$res_diff %&lt;&gt;% base::subset(Significance != &quot;ns&quot;) t1$plot_alpha(measure = &quot;Chao1&quot;, boxplot_add = &quot;dotplot&quot;, xtext_size = 15) The trans_alpha class supports the differential test of groups within each group by using the by_group parameter. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Type&quot;, by_group = &quot;Group&quot;) t1$cal_diff(method = &quot;wilcox&quot;) t1$plot_alpha(measure = &quot;Shannon&quot;) Scheirer Ray Hare test is a nonparametric test that is suitable for a two-way factorial experiment. # require rcompanion package to be installed t1$cal_diff(method = &quot;scheirerRayHare&quot;, formula = &quot;Group+Type&quot;) Linear mixed-effects model can be selected with the method = \"lme\". This model is implemented based on the lmerTest package. For more parameters, please see lmerTest::lmer function. Please use parameter passing when more parameters are needed. For the formula usage, please follow this (https://mspeekenbrink.github.io/sdam-r-companion/linear-mixed-effects-models.html). In the return table, conditional R2 is the total variance explained by fixed and random effects, and marginal R2 is the variance explained by fixed effects. if(!require(&quot;lmerTest&quot;)) install.packages(&quot;lmerTest&quot;) t1 &lt;- trans_alpha$new(dataset = dataset) # just using (1|Type) as an example to show the random effect t1$cal_diff(method = &quot;lme&quot;, formula = &quot;Group + (1|Type)&quot;) View(t1$res_diff) # return_model = TRUE can return original models, i.e. object$res_model t1$cal_diff(method = &quot;lme&quot;, formula = &quot;Group + (1|Type)&quot;, return_model = TRUE) Note that from v1.2.0, the parameter use_boxplot = FALSE in plot_alpha will invoke the data_stat instead of data_alpha for the Mean±SE (or SD) plot. The line is optional to be added between points (Mean) for the case with a gradient. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) t1$cal_diff(method = &quot;KW_dunn&quot;, measure = &quot;PD&quot;, KW_dunn_letter = TRUE) t1$plot_alpha(measure = &quot;PD&quot;) t1$plot_alpha(use_boxplot = FALSE, measure = &quot;PD&quot;) t1$plot_alpha(use_boxplot = FALSE, measure = &quot;PD&quot;, y_increase = -0.2) t1$plot_alpha(use_boxplot = FALSE, measure = &quot;PD&quot;, y_increase = -0.2, add_line = TRUE, line_type = 2, line_alpha = 0.5, errorbar_width = 0.1) t1$plot_alpha(use_boxplot = FALSE, plot_SE = FALSE, measure = &quot;PD&quot;, y_increase = 0.2, add_line = TRUE, line_type = 2, line_alpha = 0.5, errorbar_width = 0.1) # by_group example # use example data in mecoturn package library(microeco) library(mecoturn) library(magrittr) data(wheat_16S) wheat_16S$sample_table$Type %&lt;&gt;% factor(., levels = unique(.)) t1 &lt;- trans_alpha$new(dataset = wheat_16S, group = &quot;Region&quot;, by_group = &quot;Type&quot;) t1$cal_diff(method = &quot;KW_dunn&quot;, measure = &quot;Shannon&quot;, KW_dunn_letter = TRUE) View(t1$res_diff) t1$plot_alpha(use_boxplot = FALSE, measure = &quot;Shannon&quot;) t1$plot_alpha(use_boxplot = FALSE, measure = &quot;Shannon&quot;, add_line = TRUE, line_type = 2) t1$plot_alpha(use_boxplot = FALSE, plot_SE = FALSE, measure = &quot;Shannon&quot;, add_line = TRUE, line_type = 2) From v1.4.0, the heatmap can be used to visualize the significances for the case with multiple factors in the formula. t1 &lt;- trans_alpha$new(dataset = dataset, group = &quot;Group&quot;) t1$cal_diff(method = &quot;anova&quot;, formula = &quot;Group+Type+Group:Type&quot;) t1$plot_alpha(color_palette = rev(RColorBrewer::brewer.pal(n = 11, name = &quot;RdYlBu&quot;)), trans = &quot;log10&quot;) t1$plot_alpha(color_palette = c(&quot;#053061&quot;, &quot;white&quot;, &quot;#A50026&quot;), trans = &quot;log10&quot;) t1$plot_alpha(color_values = c(&quot;#053061&quot;, &quot;white&quot;, &quot;#A50026&quot;), trans = &quot;log10&quot;) t1$plot_alpha(color_values = c(&quot;#053061&quot;, &quot;white&quot;, &quot;#A50026&quot;), trans = &quot;log10&quot;, filter_feature = &quot;&quot;, text_y_position = &quot;left&quot;) t1$plot_alpha(color_values = c(&quot;#053061&quot;, &quot;white&quot;, &quot;#A50026&quot;), trans = &quot;log10&quot;, filter_feature = &quot;&quot;, text_y_position = &quot;left&quot;, cluster_ggplot = &quot;row&quot;) 5.1.2 Key points trans_alpha$new: creating trans_alpha object can invoke alpha_diversity in microtable for transformation cal_diff: formula parameter applies to multi-factor analysis of variance. cal_diff: From v1.2.0, anova_post_test can be used to change default post test method of anova. plot_alpha: the significance label comes from the results in object$res_diff 5.2 trans_beta class  The trans_beta class is specifically designed for the beta diversity analysis, i.e. the dissimilarities among samples. Beta diversity can be defined at different forms(Tuomisto 2010) and can be explored with different ways(Anderson et al. 2011). We encapsulate some commonly-used approaches in microbial ecology(Ramette 2007). Note that the part of beta diversity related with environmental factors are placed into the trans_env class. The distance matrix in beta_diversity list of microtable object will be invoked for transformation and ploting using trans_beta class when needed. The analysis referred to the beta diversity in this class mainly include ordination, group distance, clustering and manova. 5.2.1 Example We first show the ordination using PCoA (principal coordinates analysis). # create an trans_beta object # measure parameter must be one of names(dataset$beta_diversity) t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) # PCoA, PCA, DCA and NMDS are available t1$cal_ordination(ordination = &quot;PCoA&quot;) # t1$res_ordination is the ordination result list class(t1$res_ordination) # plot the PCoA result with confidence ellipse t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;ellipse&quot;)) More examples on different options. t1$plot_ordination(plot_color = &quot;Type&quot;, plot_type = &quot;point&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;, point_size = 5, point_alpha = .2, plot_type = c(&quot;point&quot;, &quot;ellipse&quot;), ellipse_chull_fill = FALSE) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;centroid&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;ellipse&quot;, &quot;centroid&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;chull&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;chull&quot;, &quot;centroid&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;chull&quot;, &quot;centroid&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;chull&quot;, &quot;centroid&quot;), add_sample_label = &quot;SampleID&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = &quot;centroid&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = &quot;centroid&quot;, centroid_segment_alpha = 0.9, centroid_segment_size = 1, centroid_segment_linetype = 1) t1$plot_ordination(plot_type = c(&quot;point&quot;, &quot;centroid&quot;), plot_color = &quot;Type&quot;, centroid_segment_linetype = 1) t1$plot_ordination(plot_color = &quot;Saline&quot;, point_size = 5, point_alpha = .2, plot_type = c(&quot;point&quot;, &quot;chull&quot;), ellipse_chull_fill = FALSE, ellipse_chull_alpha = 0.1) t1$plot_ordination(plot_color = &quot;Group&quot;) + theme(panel.grid = element_blank()) + geom_vline(xintercept = 0, linetype = 2) + geom_hline(yintercept = 0, linetype = 2) One example for PCA or DCA with Genus data and loading arrow. d1 &lt;- dataset$merge_taxa(taxa = &quot;Genus&quot;) d1$tax_table %&lt;&gt;% .[.$Genus != &quot;g__&quot;, ] d1$tidy_dataset() rownames(d1$otu_table) &lt;- d1$tax_table[rownames(d1$otu_table), &quot;Genus&quot;] rownames(d1$tax_table) &lt;- d1$tax_table[, &quot;Genus&quot;] t1 &lt;- trans_beta$new(dataset = d1) t1$cal_ordination(ordination = &quot;PCA&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;, loading_arrow = TRUE, loading_text_italic = TRUE) t1$cal_ordination(ordination = &quot;DCA&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;, loading_arrow = TRUE, loading_text_italic = TRUE) Then we plot and compare the group distances. # calculate and plot sample distances within groups t1$cal_group_distance(within_group = TRUE) # return t1$res_group_distance # perform Wilcoxon Rank Sum and Signed Rank Tests t1$cal_group_distance_diff(method = &quot;wilcox&quot;) # plot_group_order parameter can be used to adjust orders in x axis t1$plot_group_distance(boxplot_add = &quot;mean&quot;) # calculate and plot sample distances between groups t1$cal_group_distance(within_group = FALSE) t1$cal_group_distance_diff(method = &quot;wilcox&quot;) t1$plot_group_distance(boxplot_add = &quot;mean&quot;) Clustering plot is also a frequently used method. # extract a part of data d1 &lt;- clone(dataset) d1$sample_table %&lt;&gt;% subset(Group %in% c(&quot;CW&quot;, &quot;TW&quot;)) d1$tidy_dataset() t1 &lt;- trans_beta$new(dataset = d1, group = &quot;Group&quot;) # use replace_name to set the label name, group parameter used to set the color t1$plot_clustering(group = &quot;Type&quot;, replace_name = c(&quot;Type&quot;)) PerMANOVA(Anderson 2001) can be applied to the differential test of distances among groups via the cal_manova function developed based on the adonis2 function of vegan package. # manova for all groups when manova_all = TRUE t1$cal_manova(manova_all = TRUE) t1$res_manova ## The result is stored in object$res_manova ... Permutation test for adonis under reduced model   Df SumOfSqs R2 F Pr(&gt;F) Group 2 6.121 0.1955 10.57 0.001 Residual 87 25.18 0.8045 NA NA Total 89 31.3 1 NA NA The parameter manova_all = FALSE can make the test switch to paired group comparison. # manova for each paired groups t1$cal_manova(manova_all = FALSE) t1$res_manova ## The result is stored in object$res_manova ... Groups measure F R2 p.value p.adjusted Significance IW vs CW bray 11.01 0.1595 0.001 0.001 *** IW vs TW bray 9.992 0.147 0.001 0.001 *** CW vs TW bray 10.69 0.1556 0.001 0.001 *** The parameter manova_set has higher priority than manova_all. If manova_set is provided, manova_all parameter will be disabled. # manova for specified group set: such as &quot;Group + Type&quot; t1$cal_manova(manova_set = &quot;Group + Type&quot;) t1$res_manova ## The result is stored in object$res_manova ... Permutation test for adonis under reduced model   Df SumOfSqs R2 F Pr(&gt;F) Group 2 6.121 0.1955 12.01 0.001 Type 3 3.783 0.1208 4.949 0.001 Residual 84 21.4 0.6836 NA NA Total 89 31.3 1 NA NA From v1.0.0, ANOSIM method is also available. # the group parameter is not necessary when it is provided in creating the object t1$cal_anosim(group = &quot;Group&quot;) t1$res_anosim t1$cal_anosim(group = &quot;Group&quot;, paired = TRUE) t1$res_anosim PERMDISP(Anderson et al. 2011) is implemented to test multivariate homogeneity of groups dispersions (variances) based on the betadisper function of vegan package. # for the whole comparison and for each paired groups t1$cal_betadisper() ## The result is stored in object$res_betadisper ... t1$res_betadisper ## ## Permutation test for homogeneity of multivariate dispersions ## Permutation: free ## Number of permutations: 999 ## ## Response: Distances ## Df Sum Sq Mean Sq F N.Perm Pr(&gt;F) ## Groups 2 0.04131 0.0206545 4.1682 999 0.021 * ## Residuals 87 0.43110 0.0049552 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Pairwise comparisons: ## (Observed p-value below diagonal, permuted p-value above diagonal) ## CW IW TW ## CW 0.4690000 0.063 ## IW 0.4621193 0.005 ## TW 0.0566190 0.0050319 For the explanation of statistical methods in microbial ecology, please read the references (Ramette 2007; Buttigieg and Ramette 2014). 5.2.2 Key points trans_beta$new: creating trans_beta object with measure parameter can invoke beta_diversity in microtable object for transformation cal_ordination(): PCoA, PCA and NMDS approaches are all available cal_manova(): cal_manova function can be used for paired comparisons, overall test and multi-factors test plot_group_distance(): manipulating object$res_group_distance_diff can control what statistical results are presented in the plot. References "],["model-based-class.html", "Chapter 6 Model-based class 6.1 trans_diff class 6.2 trans_network class 6.3 trans_nullmodel class 6.4 trans_classifier class", " Chapter 6 Model-based class All the classes with complex models are grouped into this section. 6.1 trans_diff class  Differential abundance test is an important part in the microbiome profiling analysis. It can find the significant taxa in determining community differences across groups. Different approaches may produce inconsistent results since the underlying models/hypothesis are different (Nearing et al. 2022). Currently, trans_diff class has multiple famous differential test approaches or wrapped methods to better capture the important biomarkers: Kruskal-Wallis Rank Sum Test (for groups &gt; 2), Wilcoxon Rank Sum Tests (for each paired group), Dunn’s Kruskal-Wallis Multiple Comparisons (for paired group in cases groups &gt; 2), t-test, ANOVA, Scheirer Ray Hare test, linear regression, metastat(White, Nagarajan, and Pop 2009), LEfSe(Segata et al. 2011), RF (random forest + differential test), metagenomeSeq(Paulson et al. 2013), DESeq2 (Love, Huber, and Anders 2014), ALDEx2 (Fernandes et al. 2014), ANCOM-BC2 (Lin and Peddada 2020), LinDA (Zhou et al. 2022), beta regression (Cribari-Neto and Zeileis 2010), linear mixed-effects model and generalized linear mixed model. Given that multiple approaches are available, it is feasible to compare the results from different approaches and extract a part of biomarkers with high confidence for a specific dataset. 6.1.1 Example All the differential test result is stored in the object$res_diff. LEfSe combines the non-parametric test and linear discriminant analysis (Segata et al. 2011). t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;lefse&quot;, group = &quot;Group&quot;, alpha = 0.01, lefse_subgroup = NULL) # see t1$res_diff for the result # From v0.8.0, threshold is used for the LDA score selection. t1$plot_diff_bar(threshold = 4) # we show 20 taxa with the highest LDA (log10) t1$plot_diff_bar(use_number = 1:30, width = 0.8, group_order = c(&quot;CW&quot;, &quot;IW&quot;, &quot;TW&quot;)) # show part of the table t1$res_diff[1:5, c(1, 3, 4, 6)] Taxa Group LDA P.adj k__Bacteria|p__Proteobacteria CW 4.837 1.076e-09 k__Bacteria|p__Acidobacteria IW 4.797 2.955e-10 k__Bacteria|p__Acidobacteria|c__Acidobacteria IW 4.797 6.946e-11 k__Bacteria|p__Bacteroidetes TW 4.782 1.529e-08 k__Bacteria|p__Proteobacteria|c__Gammaproteobacteria CW 4.613 2.911e-10 Then, the abundance of biomarkers detected by LEfSe can be visualized easily. t1$plot_diff_abund(use_number = 1:30, group_order = c(&quot;CW&quot;, &quot;IW&quot;, &quot;TW&quot;)) Then, we show the cladogram of the differential features in the taxonomic tree. There are too many taxa in this dataset. As an example, we only select the highest 200 abundant taxa in the tree and 50 differential features. We only show the full taxonomic label at Phylum level and use letters at other levels to reduce the text overlap. Note that if an error occurs in this function, the reason with a high probability is the chaotic taxonomy in the user’s data. Please see the tidy_taxonomy function of microtable class part to solve this issue. # clade_label_level 5 represent phylum level in this analysis # require ggtree package t1$plot_diff_cladogram(use_taxa_num = 200, use_feature_num = 50, clade_label_level = 5, group_order = c(&quot;CW&quot;, &quot;IW&quot;, &quot;TW&quot;)) There may be a problem related with the taxonomic labels in the plot. When there are too many levels shown, the taxonomic labels can have too much overlap. However, if only Phylum labels are indicated, the taxa in the legend with marked letters are too many. At this time, taxa can be manually choosed to show like the following operation. # choose some taxa according to the positions in the previous picture; those taxa labels have minimum overlap use_labels &lt;- c(&quot;c__Deltaproteobacteria&quot;, &quot;c__Actinobacteria&quot;, &quot;o__Rhizobiales&quot;, &quot;p__Proteobacteria&quot;, &quot;p__Bacteroidetes&quot;, &quot;o__Micrococcales&quot;, &quot;p__Acidobacteria&quot;, &quot;p__Verrucomicrobia&quot;, &quot;p__Firmicutes&quot;, &quot;p__Chloroflexi&quot;, &quot;c__Acidobacteria&quot;, &quot;c__Gammaproteobacteria&quot;, &quot;c__Betaproteobacteria&quot;, &quot;c__KD4-96&quot;, &quot;c__Bacilli&quot;, &quot;o__Gemmatimonadales&quot;, &quot;f__Gemmatimonadaceae&quot;, &quot;o__Bacillales&quot;, &quot;o__Rhodobacterales&quot;) # then use parameter select_show_labels to show t1$plot_diff_cladogram(use_taxa_num = 200, use_feature_num = 50, select_show_labels = use_labels) # Now we can see that more taxa names appear in the tree The ‘rf’ method depends on the random forest(Beck and Foster 2014; Yatsunenko et al. 2012) and the non-parametric test. The current method implements random forest by bootstrapping like the operation in LEfSe and employs the significant features as input. MeanDecreaseGini is selected as the indicator value in the analysis. # use Genus level for parameter taxa_level, if you want to use all taxa, change to &quot;all&quot; # nresam = 1 and boots = 1 represent no bootstrapping and use all samples directly t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;rf&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;) # plot the MeanDecreaseGini bar # group_order is designed to sort the groups g1 &lt;- t1$plot_diff_bar(use_number = 1:20, group_order = c(&quot;TW&quot;, &quot;CW&quot;, &quot;IW&quot;)) # plot the abundance using same taxa in g1 g2 &lt;- t1$plot_diff_abund(group_order = c(&quot;TW&quot;, &quot;CW&quot;, &quot;IW&quot;), select_taxa = t1$plot_diff_bar_taxa) # now the y axis in g1 and g2 is same, so we can merge them # remove g1 legend; remove g2 y axis text and ticks g1 &lt;- g1 + theme(legend.position = &quot;none&quot;) g2 &lt;- g2 + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) gridExtra::grid.arrange(g1, g2, ncol = 2, nrow = 1, widths = c(2, 1.7)) The significance label can also be added in the abundance plot controlled by add_sig parameter and other related parameters. Now adding labels supports all the differential test methods. t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;wilcox&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;, filter_thres = 0.001) # filter something not needed to show t1$res_diff %&lt;&gt;% subset(Significance %in% &quot;***&quot;) t1$plot_diff_abund(use_number = 1:10, add_sig = T, add_sig_label = &quot;Significance&quot;) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;anova&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;, filter_thres = 0.001) t1$plot_diff_abund(use_number = 1:10, add_sig = T, coord_flip = F) Metastat depends on the permutations and t-test and performs well on the sparse data for paired groups test. # metastat analysis at Genus level t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;metastat&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;) # t1$res_diff is the differential test result Because the example ‘Group’ in sample_table has three groups, the metastat can run the comparisons for each paired group. So there are three pairs in t1$res_diff$Comparison. For the abundance plotting, the user should use select_group parameter to select the specific pair. # select_group should be one of groups in t1$res_diff$Comparison t1$plot_diff_abund(use_number = 1:20, select_group = &quot;CW - TW&quot;, coord_flip = F) The following are some examples for the methods ‘KW’, ‘KW_dunn’, ‘wilcox’, ‘t.test’ and ‘anova’. # Kruskal-Wallis Rank Sum Test for all groups (&gt;= 2) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;KW&quot;, group = &quot;Group&quot;, taxa_level = &quot;all&quot;, filter_thres = 0.001) t1$plot_diff_abund(use_number = 1:20) # Dunn&#39;s Kruskal-Wallis Multiple Comparisons when group number &gt; 2; require FSA package t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;KW_dunn&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;, filter_thres = 0.0001) t1$plot_diff_abund(use_number = 1:10, add_sig = T, coord_flip = F) # Wilcoxon Rank Sum and Signed Rank Tests for all paired groups t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;wilcox&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;, filter_thres = 0.001) t1$plot_diff_bar(use_number = 1:20, select_group = &quot;CW - TW&quot;) t1$plot_diff_abund(use_number = 1:20, select_group = &quot;CW - TW&quot;, group_order = c(&quot;TW&quot;, &quot;CW&quot;)) # t.test t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;t.test&quot;, group = &quot;Group&quot;, taxa_level = &quot;all&quot;, filter_thres = 0.001) # anova t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;anova&quot;, group = &quot;Group&quot;, taxa_level = &quot;Phylum&quot;, filter_thres = 0.001) head(t1$res_diff) The method ‘metagenomeSeq’ (Paulson et al. 2013) and ‘ancombc2’ (Lin and Peddada 2020) depend on the metagenomeSeq package and ANCOMBC package, respectively. The method ‘ALDEx2_t’ and ‘ALDEx2_kw’ depend on the ALDEx2 package (Fernandes et al. 2014). These three packages are all deposited on the Bioconductor. # zero-inflated log-normal model-based differential test method from metagenomeSeq package # If metagenomeSeq package is not installed, please first run: BiocManager::install(&quot;metagenomeSeq&quot;) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;metagenomeSeq&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;metagenomeSeq&quot;, group = &quot;Group&quot;, taxa_level = &quot;OTU&quot;) t1$plot_diff_abund(use_number = 1:30, group_order = c(&quot;TW&quot;, &quot;CW&quot;, &quot;IW&quot;)) t1$plot_diff_bar(use_number = 1:20) # &#39;ALDEx2_t&#39; and &#39;ALDEx2_kw&#39; methods; use ?trans_diff to see detailed description of the methods # If ALDEx2 package is not installed, please first run: BiocManager::install(&quot;ALDEx2&quot;) # &#39;ALDEx2_t&#39; t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;ALDEx2_t&quot;, group = &quot;Group&quot;, taxa_level = &quot;Phylum&quot;) t1$plot_diff_abund(use_number = 1:20, group_order = c(&quot;TW&quot;, &quot;CW&quot;, &quot;IW&quot;)) t1$plot_diff_abund(use_number = 1:20, select_group = &quot;CW - TW&quot;) t1$plot_diff_abund(use_number = 1:20, select_group = &quot;CW - TW&quot;, add_sig = TRUE) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;ALDEx2_t&quot;, group = &quot;Group&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0005) # ALDEx2_kw t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;ALDEx2_kw&quot;, group = &quot;Group&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.001) t1$plot_diff_abund(use_number = 1:30, group_order = c(&quot;TW&quot;, &quot;CW&quot;, &quot;IW&quot;)) t1$plot_diff_bar(use_number = 1:20) t1$plot_diff_abund(use_number = 1:30, group_order = c(&quot;TW&quot;, &quot;CW&quot;, &quot;IW&quot;), add_sig = TRUE) # ANCOMBC2 method # when fix_formula is not provided (necessary in the ancombc2 function of ANCOMBC package), it will be assigned automatically by using group parameter t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;ancombc2&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;, filter_thres = 0.01) t1$plot_diff_bar(keep_full_name = TRUE, heatmap_cell = &quot;P.adj&quot;, heatmap_sig = &quot;Significance&quot;, heatmap_x = &quot;Factors&quot;, heatmap_y = &quot;Taxa&quot;) # add a continuous variable dataset$sample_table &lt;- data.frame(dataset$sample_table, env_data_16S[rownames(dataset$sample_table), ]) t2 &lt;- trans_diff$new(dataset = dataset, method = &quot;ancombc2&quot;, group = NULL, fix_formula = &quot;pH+Group&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.005) # original results t2$res_diff_raw # converted result t2$res_diff View(t2$res_diff) The method linda (Zhou et al. 2022) depends on the MicrobiomeStat package. # LinDA method. If MicrobiomeStat package is not installed, please first run: install.packages(&quot;MicrobiomeStat&quot;) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;linda&quot;, group = &quot;Group&quot;, taxa_level = &quot;OTU&quot;) t1$plot_diff_abund(use_number = 1:30, group_order = c(&quot;TW&quot;, &quot;CW&quot;, &quot;IW&quot;), add_sig = TRUE) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;linda&quot;, group = &quot;Group+Type&quot;, taxa_level = &quot;Genus&quot;) View(t1$res_diff) t1$plot_diff_bar(keep_full_name = TRUE) # Either group or formula parameter should be provided in v1.5.0. Then are same for linda method. dataset$sample_table &lt;- data.frame(dataset$sample_table, env_data_16S[rownames(dataset$sample_table), ]) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;linda&quot;, group = &quot;pH + Group&quot;, taxa_level = &quot;OTU&quot;) t2 &lt;- trans_diff$new(dataset = dataset, method = &quot;linda&quot;, formula = &quot;~pH + Group&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.005) t2$plot_diff_bar(keep_full_name = FALSE, color_values = c(&quot;#053061&quot;, &quot;white&quot;, &quot;#A50026&quot;), trans = &quot;log10&quot;, filter_feature = &quot;&quot;, text_y_position = &quot;left&quot;) 6.1.2 More options The dependence packages in the following examples are not mentioned in the previous package dependence part (https://chiliubio.github.io/microeco_tutorial/intro.html#dependence). The method DESeq2 from DESeq2 package is also supported in the trans_diff class and no longer demonstrated here. The linear regression from lm function and linear mixed-effects models from lmerTest package can be fitted with the option method = 'lm' and method = 'lme', respectively. # AST: arc sine square root transformation if(!require(&quot;lmerTest&quot;)) install.packages(&quot;lmerTest&quot;) t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;lme&quot;, formula = &quot;Group+(1|Type)&quot;, taxa_level = &quot;Phylum&quot;, transformation = &quot;AST&quot;, filter_thres = 0.001) View(t1$res_diff) The generalized linear mixed model (GLMM) is implemented based on the glmmTMB package. In this example, we use beta distribution function as the family function, because beta distribution is especially appropriate to fit the proportional data (relative abundance here). if(!require(&quot;glmmTMB&quot;)) install.packages(&quot;glmmTMB&quot;) d1 &lt;- clone(dataset) t1 &lt;- trans_diff$new(dataset = d1, taxa_level = &quot;Phylum&quot;, method = &quot;glmm_beta&quot;, formula = &quot;Group + (1|Type)&quot;, filter_thres = 0.001) View(t1$res_diff) From v1.2.0, the heatmap can be used in the plot_diff_bar function instead of bar plot for the case with multiple factors or formula. # heatmap for the previous GLMM result # default no significance label in the res_diff for this method t1$res_diff$Significance &lt;- cut(t1$res_diff$P.unadj, breaks = c(-Inf, 0.001, 0.01, 0.05, Inf), label = c(&quot;***&quot;, &quot;**&quot;, &quot;*&quot;, &quot;&quot;)) t1$plot_diff_bar(heatmap_cell = &quot;Estimate&quot;, heatmap_sig = &quot;Significance&quot;, heatmap_lab_fill = &quot;Coefficient&quot;) # two-way anova for more usages of heatmap t1 &lt;- trans_diff$new(dataset = dataset, method = &quot;anova&quot;, formula = &quot;Group + Type&quot;, taxa_level = &quot;Phylum&quot;, filter_thres = 0.001, transformation = &quot;AST&quot;) t1$plot_diff_bar() t1$plot_diff_bar(color_palette = rev(RColorBrewer::brewer.pal(n = 11, name = &quot;RdYlBu&quot;)), trans = &quot;log10&quot;) t1$plot_diff_bar(color_values = c(&quot;#053061&quot;, &quot;white&quot;, &quot;#A50026&quot;), trans = &quot;log10&quot;) t1$plot_diff_bar(color_values = c(&quot;#053061&quot;, &quot;white&quot;, &quot;#A50026&quot;), trans = &quot;log10&quot;, filter_feature = &quot;&quot;, text_y_position = &quot;right&quot;, cluster_ggplot = &quot;row&quot;) 6.1.3 Key points trans_diff$new: In trans_diff$new, p_adjust_method = “none” can close the p value adjustment. This is useful in cases where very few significant taxa are found (generally no significant feature found after adjustment) and where LEfSe result is needed to be compared with that from Galaxy server or other LEfSe python version. trans_diff$new: this class has a strict requirement on the taxonomic information, make sure tidy_taxonomy() function has been performed for the tax_table in microtable object. trans_diff$new: creating this class invokes one or more tables in taxa_abund list, which is stored in microtable object. trans_diff$plot_diff_cladogram: clade_label_size, clade_label_size_add and clade_label_size_log can control the text size all together in the cladogram. trans_diff$new: from v0.19.0, transformation parameter can be employed to transform or normalize relative abundance data based on the mecodev package for those methods coming from trans_alpha class (“KW”, “KW_dunn”, “wilcox”, “t.test”, “anova”, “scheirerRayHare”, “betareg”, “lme”, “glmm”). For example, transformation = 'AST' represents the arc sine square root transformation. trans_diff$plot_diff_bar: from v0.19.0, color_group_map = TRUE can be added in plot_diff_bar function to fix the color in each group when part of groups are not shown in the plot, which is especially useful when multiple approaches or data are needed to run the same step. 6.2 trans_network class  Network analysis has been frequently used to study microbial co-occurrence patterns (Deng et al. 2012; Faust and Raes 2012; Coyte, Schluter, and Foster 2015). In this part, we describe part of the implemented methods in the trans_network class. The objects inside the rectangle with full line represent functions. The dashed line denotes the key objects (input or output). The res_network inside the ellipse with dashed line means it is a hub object for other analysis. 6.2.1 Example The correlation-based network is selected to show the main operations. This is only intended to show some operations conveniently. Do not mean we are suggesting this approach in any case. Please check the final part for other network construction methods. # The parameter cor_method in trans_network is used to select correlation calculation method. # default pearson or spearman correlation invoke R base cor.test, a little slow t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;spearman&quot;, filter_thres = 0.001) # return t1$res_cor_p list, containing two tables: correlation coefficient table and p value table Spearman correlation based on WGCNA package is applied to show all the following operations. # require WGCNA package if(!require(&quot;WGCNA&quot;)) install.packages(&quot;WGCNA&quot;, repos = BiocManager::repositories()) t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;spearman&quot;, use_WGCNA_pearson_spearman = TRUE, filter_thres = 0.0001) The parameter COR_cut can be used to select the correlation threshold. Furthermore, COR_optimization = TRUE can be used to find the optimized coefficient threshold (potential transition point of network eigenvalues) instead of the COR_cut based on the RMT theory (Deng et al. 2012). # construct network; require igraph package t1$cal_network(COR_p_thres = 0.01, COR_optimization = TRUE) # use arbitrary coefficient threshold to contruct network t1$cal_network(COR_p_thres = 0.01, COR_cut = 0.7) # return t1$res_network Then, let’s partition modules for the network. # invoke igraph cluster_fast_greedy function for this undirected network t1$cal_module(method = &quot;cluster_fast_greedy&quot;) The following operation is to save network to gexf format for the visualization with Gephi(https://gephi.org/). The file ‘network.gexf’ can be directly opened by Gephi. # require rgexf package to be installed t1$save_network(filepath = &quot;network.gexf&quot;) Then, we plot the network in Gephi and present the node colors according to the partitioned modules. Now, we show the node colors with the Phylum information and the edges colors with the positive and negative correlations. All the data used has been stored in the network.gexf file, including modules classifications, Phylum information and edge labels. # calculate network attributes t1$cal_network_attr() t1$res_network_attr Property Value Vertex 407 Edge 1989 Average_degree 9.774 Average_path_length 3.878 Network_diameter 9 Clustering_coefficient 0.4698 Density 0.02407 Heterogeneity 1.194 Centralization 0.09908 The function get_node_table, get_edge_table and get_adjacency_matrix are designed to get node properties table, edge properties table and adjacency matrix from network, respectively. # get node properties t1$get_node_table(node_roles = TRUE) # return t1$res_node_table   name degree betweenness Abundance module z OTU_50 OTU_50 2 0 0.2301 M2 -1.305 OTU_305 OTU_305 3 4 0.1394 M8 1.118 OTU_1 OTU_1 21 2 1.409 M2 -0.04067 OTU_41 OTU_41 1 0 0.1603 M14 -0.5774 OTU_59 OTU_59 3 2306 0.5588 M6 0.7771 # get edge properties t1$get_edge_table() # return t1$res_edge_table t1$get_adjacency_matrix() # return t1$res_adjacency_matrix Then, let’s plot the node classification in terms of the within-module connectivity and among-module connectivity. # add_label = TRUE can be used to directly add text label for points t1$plot_taxa_roles(use_type = 1) # plot node roles with phylum information t1$plot_taxa_roles(use_type = 2) Now, we show the eigengene analysis of modules. The eigengene of a module, i.e. the first principal component of PCA, represents the main variance of the abundance in the species of the module. t1$cal_eigen() # return t1$res_eigen Then we perform correlation heatmap to show the associations between eigengenes and environmental factors. # create trans_env object t2 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # calculate correlations t2$cal_cor(add_abund_table = t1$res_eigen) # plot the correlation heatmap t2$plot_cor() The subset_network function can be applied to extract a part of nodes and edges among these nodes from the network. In this function, you should provide the nodes you need using the node parameter. # extract a sub network that contains all nodes in module M1 t1$subset_network(node = t1$res_node_table %&gt;% base::subset(module == &quot;M1&quot;) %&gt;% rownames, rm_single = TRUE) # return a new network with igraph class # extract sub network in which all edge labels are &quot;+&quot;, i.e. positive edges t1$subset_network(edge = &quot;+&quot;) Then let’s show how to extract sub-network for samples (Ma et al. 2016). # extract the sub-network of sample &#39;S1&#39; sub1 &lt;- t1$subset_network(node = dataset$otu_table %&gt;% .[.[, &quot;S1&quot;] != 0, ] %&gt;% rownames, rm_single = TRUE) # see https://chiliubio.github.io/microeco_tutorial/notes.html#clone for the &#39;clone&#39; function explanation t2 &lt;- clone(t1) t2$res_network &lt;- sub1 # then t2 have a network for &#39;S1&#39; and can be used for further analysis t2$cal_module() t2$save_network(&quot;S1.gexf&quot;) # please use a loop for all samples We also add the function plot_network to directly plot the network in R, including the static network and dynamic network. The static network is suitable for the case with relatively few nodes, while dynamic network can be better applied to a large network. See https://yunranchen.github.io/intro-net-r/advanced-network-visualization.html and https://kateto.net/network-visualization for more details on the network visualization in R. # default parameter represents using igraph plot.igraph function t2$plot_network() # use ggraph method; require ggraph package # If ggraph is not installed; first install it with command: install.packages(&quot;ggraph&quot;) t2$plot_network(method = &quot;ggraph&quot;, node_color = &quot;Phylum&quot;) # use networkD3 package method for the dynamic network visualization in R # If networkD3 is not installed; first install it with command: install.packages(&quot;networkD3&quot;) t1$plot_network(method = &quot;networkD3&quot;, node_color = &quot;module&quot;) t1$plot_network(method = &quot;networkD3&quot;, node_color = &quot;Phylum&quot;) The trans_comm function can be used to convert the node classification to a new microtable object for other analysis. # use_col is used to select a column of t1$res_node_table tmp &lt;- t1$trans_comm(use_col = &quot;module&quot;, abundance = FALSE) tmp tmp$otu_table[tmp$otu_table &gt; 0] &lt;- 1 tmp$tidy_dataset() tmp$cal_abund() tmp2 &lt;- trans_abund$new(tmp, taxrank = &quot;Phylum&quot;, ntaxa = 10) tmp2$data_abund$Sample %&lt;&gt;% factor(., levels = rownames(tmp$sample_table)) tmp2$plot_line(xtext_angle = 30, color_values = RColorBrewer::brewer.pal(12, &quot;Paired&quot;)) + ylab(&quot;OTUs ratio (%)&quot;) The function cal_sum_links can sum the links (edge) number from one taxa to another or within the same taxa. The function plot_sum_links is used to show the result from the function cal_sum_links. This is very useful to fast see how many nodes are connected between different taxa or within one taxa. In terms of ‘Phylum’ level in the tutorial, the function cal_sum_links() sum the linkages number from one Phylum to another Phylum or the linkages in the same Phylum. So the numbers along the outside of the circular plot represent how many edges or linkages are related with the Phylum. For example, in terms of Proteobacteria, there are roughly total 900 edges associated with the OTUs in Proteobacteria, in which roughly 200 edges connect both OTUs in Proteobacteria and roughly 150 edges connect the OTUs from Proteobacteria with the OTUs from Chloroflexi. t1$cal_sum_links(taxa_level = &quot;Phylum&quot;) # interactive visualization; require chorddiag package; see https://github.com/mattflor/chorddiag t1$plot_sum_links(plot_pos = TRUE, plot_num = 10, color_values = RColorBrewer::brewer.pal(10, &quot;Paired&quot;)) # From v1.2.0, method = &quot;circlize&quot; is available for conveniently saving the static plot # If circlize package is not installed, first run: install.packages(&quot;circlize&quot;) t1$plot_sum_links(method = &quot;circlize&quot;, transparency = 0.2, annotationTrackHeight = circlize::mm_h(c(5, 5))) For the correlation network, there are also other available correlation/association calculation options, such as Bray–Curtis (1-dissimilarity), SparCC (Friedman and Alm 2012), CCLasso (Fang et al. 2015), Pearson or Spearman with data normalization based on NetCoMi package (Peschel et al. 2021). # use Bray–Curtis index (1-dissimilarity) t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;bray&quot;, filter_thres = 0.001) # Pearson correlation t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;pearson&quot;, filter_thres = 0.001) # Pearson correlation using WGCNA package # install WGCNA package if(!require(&quot;WGCNA&quot;)) install.packages(&quot;WGCNA&quot;, repos = BiocManager::repositories()) t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;pearson&quot;, use_WGCNA_pearson_spearman = TRUE, filter_thres = 0.001) # Pearson correlation using NetCoMi package; install it from https://github.com/stefpeschel/NetCoMi t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;pearson&quot;, use_NetCoMi_pearson_spearman = TRUE, filter_thres = 0.001) # Spearman correlation using WGCNA package t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;spearman&quot;, use_WGCNA_pearson_spearman = TRUE, filter_thres = 0.001) # Spearman correlation using NetCoMi package t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;spearman&quot;, use_NetCoMi_pearson_spearman = TRUE, filter_thres = 0.001) # SparCC method, from SpiecEasi package, see https://github.com/zdk123/SpiecEasi for the installation t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;sparcc&quot;, use_sparcc_method = &quot;SpiecEasi&quot;, filter_thres = 0.003) # SparCC method, from NetCoMi package; https://github.com/stefpeschel/NetCoMi t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;sparcc&quot;, use_sparcc_method = &quot;NetCoMi&quot;, filter_thres = 0.001) # CCLasso method based on NetCoMi package t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;cclasso&quot;, filter_thres = 0.001) # CCREPE method based on NetCoMi package t1 &lt;- trans_network$new(dataset = dataset, cor_method = &quot;ccrepe&quot;, filter_thres = 0.001) Then let’s show other implemented network construction approaches: SPIEC-EASI (SParse InversE Covariance Estimation for Ecological Association Inference) approach of SpiecEasi R package (Kurtz et al. 2015) has two network construction approaches based on graph model, which relies on algorithms for sparse neighborhood and inverse covariance selection. See https://github.com/zdk123/SpiecEasi for the package installation. It is very slow for SpiecEasi_method = ‘glasso’ when there is a large number (such as hundreds to thousands) according to our test experience. t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, taxa_level = &quot;OTU&quot;, filter_thres = 0.001) # require SpiecEasi package installed https://github.com/zdk123/SpiecEasi # also see SpiecEasi::spiec.easi for available model parameters t1$cal_network(network_method = &quot;SpiecEasi&quot;, SpiecEasi_method = &quot;mb&quot;) # see t1$res_network Another network construction approach comes from julia package FlashWeave (Tackmann, Matias Rodrigues, and Mering 2019). This is a probabilistic graph-based method to obtain the conditional independence. It predicts direct associations among microbes from large-scale compositional abundance data through statistical co-occurrence. To repeat the following code, please first install julia language in your computer and the FlashWeave package, and add the julia in the computer path. download and install julia from https://julialang.org/downloads/ Put julia in the computer env PATH, such as your_directory_path Open terminal or cmd or Powershell, open julia, install FlashWeave following the operation in https://github.com/meringlab/FlashWeave.jl t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, taxa_level = &quot;OTU&quot;, filter_thres = 0) # require Julia in the computer path, and the package FlashWeave # different with the direct parameter passing of &#39;SpiecEasi&#39; network_method, FlashWeave_other_para is used to pass parameters to Julia FlashWeave # assign FlashWeave_tempdir parameter can change the temporary working directory t1$cal_network(network_method = &quot;FlashWeave&quot;, FlashWeave_other_para = &quot;alpha=0.01,sensitive=true,heterogeneous=true&quot;) # see t1$res_network The final method we want to show comes from beemStatic package (Li et al. 2021). This method can be applied to cross-sectional datasets to infer interaction network based on the generalized Lotka-Volterra model, which is typically used in the microbial time-series data. So the network from this approach is a directed network. Please see https://github.com/CSB5/BEEM-static for installing the R beemStatic package. t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, taxa_level = &quot;OTU&quot;, filter_thres = 0.001) # require beemStatic package installed t1$cal_network(network_method = &quot;beemStatic&quot;) # use cluster_walktrap method for the directed network t1$cal_module(method = &quot;cluster_walktrap&quot;) 6.2.2 Network comparison To compare different networks from trans_network class, please see the meconetcomp package chapter (https://chiliubio.github.io/microeco_tutorial/meconetcomp-package.html). 6.2.3 Key points cal_network(): get a network named res_network based on different methods get_node_table(): get node properties table subset_network(): this function can extract any sub-network according to the input nodes, e.g. sub-network for modules or samples 6.2.4 Other functions cal_powerlaw(): perform bootstrapping hypothesis test to determine whether degrees follow a power law distribution and fit degrees to a power law distribution. random_network(): generate random networks, compare them with the empirical network and get the p value of topological properties. 6.3 trans_nullmodel class In recent decades, the integration of phylogenetic analysis and null model promotes the inference of niche and neutral influences on community assembly more powerfully by adding a phylogeny dimension (Webb et al. 2002; Kembel et al. 2010; Stegen et al. 2013). The trans_nullmodel class provides an encapsulation, including the calculation of the phylogenetic signal, beta mean pairwise phylogenetic distance (betaMPD), beta mean nearest taxon distance (betaMNTD), beta nearest taxon index (betaNTI), beta net relatedness index (betaNRI) and Bray-Curtis-based Raup-Crick (RCbray). The approach for phylogenetic signal analysis is based on the mantel correlogram (C. Liu et al. 2017), in which the change of phylogenetic signal is intuitional and clear compared to other approaches. The combinations between RCbray and betaNTI can be used to infer the strength of each ecological process dominating the community assembly under the specific hypothesis (Stegen et al. 2013). 6.3.1 Example We first check the phylogenetic signal. # generate trans_nullmodel object # as an example, we only use high abundance OTU with mean relative abundance &gt; 0.0005 t1 &lt;- trans_nullmodel$new(dataset, filter_thres = 0.0005, add_data = env_data_16S) # use pH as the test variable t1$cal_mantel_corr(use_env = &quot;pH&quot;) # return t1$res_mantel_corr # plot the mantel correlogram t1$plot_mantel_corr() betaNRI(ses.betampd) is used to show the ‘basal’ phylogenetic turnover. Compared to betaNTI, it can capture more turnover information associated with the deep phylogeny. It is noted that there are many null models with the development in the several decades of community ecology. In the trans_nullmodel class, the default null mode of betaNTI and betaNRI is the randomization of the phylogenetic relatedness among species. This shuffling approach fix the observed levels of species α-diversity and β-diversity to explore whether the observed phylogenetic turnover significantly differ from null model that phylogenetic relatedness among species are random. # see null.model parameter for other null models # null model run 500 times for the example t1$cal_ses_betampd(runs = 500, abundance.weighted = TRUE) # return t1$res_ses_betampd If we want to plot the betaNRI, we can use plot_group_distance function in trans_beta class. For example, the results showed that the mean betaNRI of TW is extremely and significantly larger that those in CW and IW, revealing that the basal phylogenetic turnover in TW is high. # add betaNRI matrix to beta_diversity list dataset$beta_diversity[[&quot;betaNRI&quot;]] &lt;- t1$res_ses_betampd # create trans_beta class, use measure &quot;betaNRI&quot; t2 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;betaNRI&quot;) # transform the distance for each group t2$cal_group_distance() # see the help document for more methods, e.g. &quot;anova&quot; and &quot;KW_dunn&quot; t2$cal_group_distance_diff(method = &quot;wilcox&quot;) # plot the results g1 &lt;- t2$plot_group_distance(boxplot_add = &quot;mean&quot;) g1 + geom_hline(yintercept = -2, linetype = 2) + geom_hline(yintercept = 2, linetype = 2) Sometimes, if you want to perform null model analysis for each group individually, such as one group as one species pool, you should calculate the results for each group, respectively. The results show that, when we perform betaNRI for each group respectively, mean betaNRI between CW and TW are not significantly different, and they are both significantly higher than that in IW, revealing that the strength of variable selection in CW and TW may be similar under the condition that each area is considered as a specific species pool. # we create a list to store the trans_nullmodel results. sesbeta_each &lt;- list() group_col &lt;- &quot;Group&quot; all_groups &lt;- unique(dataset$sample_table[, group_col]) # calculate for each group, respectively for(i in all_groups){ # like the above operation, but need provide &#39;group&#39; and &#39;select_group&#39; test &lt;- trans_nullmodel$new(dataset, group = group_col, select_group = i, filter_thres = 0.0005) test$cal_ses_betampd(runs = 500, abundance.weighted = TRUE) sesbeta_each[[i]] &lt;- test$res_ses_betampd } # merge and reshape to generate one symmetrical matrix test &lt;- lapply(sesbeta_each, reshape2::melt) %&gt;% do.call(rbind, .) %&gt;% reshape2::dcast(., Var1~Var2, value.var = &quot;value&quot;) rownames(test) &lt;- test[, 1] test &lt;- test[, -1, drop = FALSE] # like the above operation dataset$beta_diversity[[&quot;betaNRI&quot;]] &lt;- test t2 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;betaNRI&quot;) t2$cal_group_distance() # statistical analysis t2$cal_group_distance_diff(method = &quot;wilcox&quot;) g1 &lt;- t2$plot_group_distance(boxplot_add = &quot;mean&quot;) g1 + geom_hline(yintercept = -2, linetype = 2) + geom_hline(yintercept = 2, linetype = 2) BetaNTI(ses.betamntd) can be used to indicate the phylogenetic terminal turnover (Stegen et al. 2013). # null model run 500 times t1$cal_ses_betamntd(runs = 500, abundance.weighted = TRUE, null.model = &quot;taxa.labels&quot;) # return t1$res_ses_betamntd   S1 S2 S3 S4 S5 S1 0 -0.432 -0.7318 0.6482 1.236 S2 -0.432 0 -0.9817 0.1372 0.8991 S3 -0.7318 -0.9817 0 1.098 0.02069 S4 0.6482 0.1372 1.098 0 -1.085 S5 1.236 0.8991 0.02069 -1.085 0 If the dataset is large, it is faster with use_iCAMP = TRUE for betaNTI. tmp &lt;- &quot;./test1&quot;; dir.create(tmp) t1$cal_ses_betamntd(runs = 1000, abundance.weighted = TRUE, use_iCAMP = TRUE, iCAMP_tempdir = tmp) RCbray (Bray-Curtis-based Raup-Crick) can be calculated using function cal_rcbray() to assess whether the compositional turnover was governed primarily by drift (Chase et al. 2011). We applied null model to simulate species distribution by randomly sampling individuals from each species pool with preserving species occurrence frequency and sample species richness (C. Liu et al. 2017). # result stored in t1$res_rcbray t1$cal_rcbray(runs = 1000) # return t1$res_rcbray As an example, we also calculate the proportion of the inferred processes on the community assembly as shown in the references (Stegen et al. 2013; C. Liu et al. 2017). In the example, the fraction of pairwise comparisons with significant betaNTI values (|βNTI| &gt; 2) is the estimated influence of Selection; βNTI &gt; 2 represents the heterogeneous selection; βNTI &lt; -2 represents the homogeneous selection. The value of RCbray characterizes the magnitude of deviation between observed Bray–Curtis and Bray–Curtis expected under the randomization; a value of |RCbray| &gt; 0.95 was considered significant. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and RCbray &gt; +0.95 was taken as the influence of Dispersal Limitation combined with Drift. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and RCbray &lt; -0.95 was taken as an estimate for the influence of Homogenizing Dispersal. The fraction of all pairwise comparisons with |βNTI| &lt; 2 and |RCbray| &lt; 0.95 estimates the influence of Drift acting alone. # use betaNTI and rcbray to evaluate processes t1$cal_process(use_betamntd = TRUE, group = &quot;Group&quot;) ## The result is stored in object$res_process ... t1$cal_process(use_betamntd = TRUE) ## The result is stored in object$res_process ... # return t1$res_process t1$res_process process percentage variable selection 9.238 homogeneous selection 0 dispersal limitation 8.964 homogeneous dispersal 11.54 drift 70.26 The cal_NST function can be used to calculate normalized stochasticity ratio based on the NST package (Ning et al. 2019), including ‘tNST’ and ‘pNST’ methods. # require NST package to be installed t1$cal_NST(method = &quot;tNST&quot;, group = &quot;Group&quot;, dist.method = &quot;bray&quot;, abundance.weighted = TRUE, output.rand = TRUE, SES = TRUE) t1$res_NST$index.grp ## Perform tNST analysis ... ## All match very well. ## Now randomizing by parallel computing. Begin at Thu Mar 7 10:33:38 2024. Please wait... ## The result is stored in object$res_NST ... group size ST.i.bray NST.i.bray MST.i.bray SES.i.bray IW 435 0.6541 0.3872 0.3641 9.115 CW 435 0.5632 0.2958 0.2867 14.27 TW 435 0.6244 0.4155 0.3999 9.867 # test the NST difference between each pair of groups t1$cal_NST_test(method = &quot;nst.boot&quot;) # convert long format table to square matrix # the 10th column: MST.ij.bray in t1$res_NST$index.pair test &lt;- t1$cal_NST_convert(10) # for pNST method, phylogenetic tree is needed t1$cal_NST(method = &quot;pNST&quot;, group = &quot;Group&quot;, output.rand = TRUE, SES = TRUE) t1$cal_NST_test(method = &quot;nst.boot&quot;) For nearest Taxon Index (NTI) and nearest Relative Index (NRI), please use cal_NTI and cal_NRI, respectively. t1$cal_NRI(null.model = &quot;taxa.labels&quot;, abundance.weighted = FALSE, runs = 999) t1$cal_NTI(null.model = &quot;taxa.labels&quot;, abundance.weighted = TRUE, runs = 999) 6.3.2 Key points trans_nullmodel$new: filter_thres parameter for the filtering of taxa with relative low abundance cal_rcbray(): if only need rcbray, ignore other phylogenetic operations 6.3.3 Other function cal_Cscore(): calculates the (normalised) mean number of checkerboard combinations (C-score) using C.score 6.4 trans_classifier class The trans_classifier class is a wrapper for methods of machine-learning-based classification models. Microbiome-based supervised machine-learning has been successful in predicting human health status (Poore et al. 2020) and soil categories (Wilhelm, Es, and Buckley 2021). 6.4.1 Dependencies Before starting the examples, make sure those packages have been installed. packages &lt;- c(&quot;Boruta&quot;, &quot;parallel&quot;, &quot;rsample&quot;, &quot;randomForest&quot;, &quot;caret&quot;, &quot;gridExtra&quot;, &quot;multiROC&quot;) # Now check or install for(x in packages){ if(!require(x, character.only = TRUE)) { install.packages(x, dependencies = TRUE) } } 6.4.2 Examples In this section, we use the example data in file2meco package (https://chiliubio.github.io/microeco_tutorial/file2meco-package.html) to demonstrate the feature selection, data training and prediction with random forest algorithm. library(file2meco) abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;dada2_table.qza&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample-metadata.tsv&quot;, package=&quot;file2meco&quot;) taxonomy_file_path &lt;- system.file(&quot;extdata&quot;, &quot;taxonomy.qza&quot;, package=&quot;file2meco&quot;) # construct microtable object d1 &lt;- qiime2meco(feature_table = abund_file_path, sample_table = sample_file_path, taxonomy_table = taxonomy_file_path) d1$cal_abund() # initialize: use &quot;genotype&quot; as response variable # x.predictors parameter is used to select the taxa; here we use all the taxa data in d1$taxa_abund t1 &lt;- trans_classifier$new(dataset = d1, y.response = &quot;genotype&quot;, x.predictors = &quot;All&quot;) We silit the data into training and testing set. # generate train and test set t1$cal_split(prop.train = 3/4) Before training the model, we run the set_trainControl to invoke the trainControl function of caret package to generate the parameters used for training. Here we use the default parameters in trainControl function. # require caret package t1$set_trainControl() Now let’s start model training with rf method. # use default parameter method = &quot;rf&quot; t1$cal_train(max.ntree = 500) We can use cal_predict function to predict the testing data set. t1$cal_predict() # plot the confusionMatrix to check out the performance t1$plot_confusionMatrix() Using cal_ROC and plot_ROC can get the ROC (Receiver Operator Characteristic) curve. t1$cal_ROC() t1$plot_ROC(size = 0.5, alpha = 0.7) While building a machine learning model for microbiome data, the huge diversity of microbial community and/or associated relationships among taxa accross phylogeny can lead to a large number of unnecessary features, which can reduce the overall accuracy, increase the complexity and overfit of the model and decrease the generalization capability of the model. So, feature selection is one important step in building machine-learning model. Then, we attempt to use Boruta package (Kursa and Rudnicki 2010) to do feature selection. # require Boruta package t1$cal_feature_sel(boruta.maxRuns = 300, boruta.pValue = 0.01) To compare the results between the procedure with feature selection and that without feature selection, we also perfom all the analysis with feature selection to show the whole results. t2 &lt;- trans_classifier$new(dataset = d1, y.response = &quot;genotype&quot;, x.predictors = &quot;All&quot;) t2$cal_feature_sel(boruta.maxRuns = 300, boruta.pValue = 0.01) t2$cal_split(prop.train = 3/4) t2$set_trainControl() t2$cal_train(max.ntree = 500) t2$cal_predict() t2$plot_confusionMatrix() t2$cal_ROC() t2$plot_ROC(size = 0.5, alpha = 0.7) To plot the Precision-Recall curve (PR curve), please make plot_type = “PR” in plot_ROC function. t2$plot_ROC(plot_type = &quot;PR&quot;, size = 0.5, alpha = 0.7) To show the ROC curve or PR curve of the training result, please make input = “train” in plot_ROC function. t2$cal_ROC(input = &quot;train&quot;) t2$plot_ROC(plot_type = &quot;ROC&quot;, size = 0.5, alpha = 0.7) For other machine-learning models, please use method parameter in cal_train function. # use SVM method t2$al_train(method = &quot;svmRadial&quot;, tuneLength = 15) The regression is supported from v0.15.0. # prepare data data(env_data_16S) new_test &lt;- clone(dataset) new_test$sample_table &lt;- data.frame(new_test$sample_table, env_data_16S[rownames(new_test$sample_table), ]) # pH response variable t1 &lt;- trans_classifier$new(dataset = new_test, y.response = &quot;pH&quot;, x.predictors = &quot;Genus&quot;) t1$cal_split(prop.train = 3/4) t1$set_trainControl() t1$cal_train() t1$res_train t1$cal_predict() t1$res_predict # feature importance t1$cal_feature_imp() head(t1$res_feature_imp) t1$plot_feature_imp(use_number = 1:20) + ylab(&quot;IncNodePurity&quot;) 6.4.3 Key points cal_feature_sel(): perform feature selection 6.4.4 Other function cal_feature_imp(): get feature importance from the training model when method is “rf” cal_preProcess(): Pre-process (centering, scaling etc.) of the feature data based on the caret::preProcess function. References "],["explainable-class.html", "Chapter 7 Explainable class 7.1 trans_env class 7.2 trans_func class", " Chapter 7 Explainable class The trans_env and trans_func classes are placed into the section ‘Explainable class’, as environmental factors and microbial functions can be generally applied to explain microbial community structure and assembly. 7.1 trans_env class There may be some NA (missing value) in the user’s env data. If so, please add complete_na = TRUE for the interpolation when creating a trans_env object. 7.1.1 Example Creating trans_env object has at least two ways. The following is using additional environmental data which is not in the microtable object. # add_data is used to add the environmental data t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) ## Env data is stored in object$data_env ... Maybe a more general way is to directly use the data from sample_table of your microtable object. To show this operation, we first merge additional table into sample_table to generate a new microtable object. new_test &lt;- clone(dataset) new_test$sample_table &lt;- data.frame(new_test$sample_table, env_data_16S[rownames(new_test$sample_table), ]) # now new_test$sample_table has the whole data new_test ## microtable-class object: ## sample_table have 90 rows and 15 columns ## otu_table have 12766 rows and 90 columns ## tax_table have 12766 rows and 7 columns ## phylo_tree have 12766 tips ## Taxa abundance: calculated for Kingdom,Phylum,Class,Order,Family,Genus,Species ## Alpha diversity: calculated for Observed,Chao1,se.chao1,ACE,se.ACE,Shannon,Simpson,InvSimpson,Fisher,Pielou,Coverage ## Beta diversity: calculated for bray,jaccard Now let’s use env_cols to select the required columns from sample_table in the microtable object. From v1.0.0, the parameter standardize = TRUE is available to standardize each variable. t1 &lt;- trans_env$new(dataset = new_test, env_cols = 8:15) ## Env data is stored in object$data_env ... Generally, it is beneficial to analyze environmental variables in order to better use more methods. The cal_diff function is used to test the significance of variables across groups like we have shown in trans_alpha and trans_diff class parts. # use Wilcoxon Rank Sum Test as an example t1$cal_diff(group = &quot;Group&quot;, method = &quot;wilcox&quot;) head(t1$res_diff) ## The result is stored in object$res_diff ... Comparison Measure Group P.adj Significance IW - CW Temperature CW 3.283e-10 *** IW - TW Temperature TW 0.0001958 *** CW - TW Temperature CW 3.283e-10 *** IW - CW Precipitation CW 5.239e-09 *** IW - TW Precipitation IW 0.07758 ns CW - TW Precipitation CW 4.002e-07 *** IW - CW TOC IW 0.4687 ns Let’s perform the ANOVA and show the letters in the box plot. We use list to store all the plots for each factor and plot them together. t1$cal_diff(method = &quot;anova&quot;, group = &quot;Group&quot;) # place all the plots into a list tmp &lt;- list() for(i in colnames(t1$data_env)){ tmp[[i]] &lt;- t1$plot_diff(measure = i, add_sig_text_size = 5, xtext_size = 12) + theme(plot.margin = unit(c(0.1, 0, 0, 1), &quot;cm&quot;)) } plot(gridExtra::arrangeGrob(grobs = tmp, ncol = 3)) From v0.12.0, trans_env class supports the differential test of groups within each group by using the by_group parameter in cal_diff function. t1$cal_diff(group = &quot;Type&quot;, by_group = &quot;Group&quot;, method = &quot;anova&quot;) t1$plot_diff(measure = &quot;pH&quot;, add_sig_text_size = 5) Then we show the autocorrelations among variables. # require GGally package to be installed t1$cal_autocor() For different groups, please use group parameter to show the distributions of variables and the autocorrelations across groups. t1$cal_autocor(group = &quot;Group&quot;) Then let’s show the RDA analysis (db-RDA and RDA). # use bray-curtis distance for dbRDA t1$cal_ordination(method = &quot;dbRDA&quot;, use_measure = &quot;bray&quot;) # show the orginal results t1$trans_ordination() t1$plot_ordination(plot_color = &quot;Group&quot;) # the main results of RDA are related with the projection and angles between arrows # adjust the length of the arrows to show them better t1$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5) # t1$res_rda_trans is the transformed result for plotting t1$plot_ordination(plot_color = &quot;Group&quot;) From v0.14.0, the function cal_ordination_anova is implemented to check the significance of the ordination model instead of the encapsulation in cal_ordination. Furthermore, the function cal_ordination_envfit can be used to get the contribution of each variables to the model. t1$cal_ordination_anova() t1$cal_ordination_envfit() Then, let’s try to do RDA at the Genus level. # use Genus t1$cal_ordination(method = &quot;RDA&quot;, taxa_level = &quot;Genus&quot;) # select 10 features and adjust the arrow length t1$trans_ordination(show_taxa = 10, adjust_arrow_length = TRUE, max_perc_env = 1.5, max_perc_tax = 1.5, min_perc_env = 0.2, min_perc_tax = 0.2) # t1$res_rda_trans is the transformed result for plot t1$plot_ordination(plot_color = &quot;Group&quot;) For more visualization styles, run the following examples. t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;ellipse&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;centroid&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;chull&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;ellipse&quot;, &quot;centroid&quot;)) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;chull&quot;, &quot;centroid&quot;), add_sample_label = &quot;SampleID&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = &quot;centroid&quot;, centroid_segment_alpha = 0.9, centroid_segment_size = 1, centroid_segment_linetype = 1) t1$plot_ordination(plot_color = &quot;Type&quot;, plot_type = c(&quot;point&quot;, &quot;centroid&quot;), centroid_segment_linetype = 1) Mantel test can be used to check whether there is significant correlations between environmental variables and distance matrix. t1$cal_mantel(use_measure = &quot;bray&quot;) # return t1$res_mantel head(t1$res_mantel) ## The result is stored in object$res_mantel ... Variables Correlation coefficient p.value p.adjusted Significance Temperature 0.452 0.001 0.002 ** Precipitation 0.2791 0.001 0.002 ** TOC 0.13 0.003 0.004 ** NH4 -0.05539 0.926 0.926 NO3 0.06758 0.05 0.05714 pH 0.4085 0.001 0.002 ** Conductivity 0.2643 0.001 0.002 ** TN 0.1321 0.002 0.0032 ** # mantel test for different groups t1$cal_mantel(by_group = &quot;Group&quot;, use_measure = &quot;bray&quot;) # partial mantel test t1$cal_mantel(partial_mantel = TRUE) For the combination of mantel test and correlation heatmap, please see another example (https://chiliubio.github.io/microeco_tutorial/other-examples-1.html#mantel-test-correlation-heatmap). The correlations between environmental variables and taxa are important in analyzing and inferring the factors affecting community structure. Let’s first perform a correlation heatmap using relative abundance data at Genus level with the cal_cor function. The parameter p_adjust_type can control the p value adjustment type. t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) ## Env data is stored in object$data_env ... # &#39;p_adjust_type = &quot;Env&quot;&#39; means p adjustment is performed for each environmental variable separately. t1$cal_cor(use_data = &quot;Genus&quot;, p_adjust_method = &quot;fdr&quot;, p_adjust_type = &quot;Env&quot;) ## The correlation result is stored in object$res_cor ... # return t1$res_cor Then, we can plot the correlation results using plot_cor function. # default ggplot2 method with clustering t1$plot_cor() There are too many genera. We can use the filter_feature parameter in plot_cor to filter some taxa that do not have any significance &lt; 0.001. # filter genera that donot have at least one *** t1$plot_cor(filter_feature = c(&quot;&quot;, &quot;*&quot;, &quot;**&quot;)) Sometimes, if the user wants to do the correlation analysis between the environmental factors and some important taxa detected in the biomarker analysis, please use other_taxa parameter in cal_cor function. # first create trans_diff object as a demonstration t2 &lt;- trans_diff$new(dataset = dataset, method = &quot;rf&quot;, group = &quot;Group&quot;, taxa_level = &quot;Genus&quot;) # then create trans_env object t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use other_taxa to select taxa you need t1$cal_cor(use_data = &quot;other&quot;, p_adjust_method = &quot;fdr&quot;, other_taxa = t2$res_diff$Taxa[1:40]) t1$plot_cor() The pheatmap method is also available. Note that, besides the color_vector parameter, color_palette can also be used to control color palette with customized colors. # clustering heatmap; require pheatmap package # Let&#39;s take another color pallete t1$plot_cor(pheatmap = TRUE, color_palette = rev(RColorBrewer::brewer.pal(n = 9, name = &quot;RdYlBu&quot;))) Sometimes, if it is needed to study the correlations between environmental variables and taxa for different groups, by_group parameter can be used for this goal. # calculate correlations for different groups using parameter by_group t1$cal_cor(by_group = &quot;Group&quot;, use_data = &quot;other&quot;, p_adjust_method = &quot;fdr&quot;, other_taxa = t2$res_diff$Taxa[1:40]) # return t1$res_cor t1$plot_cor() If the user is concerned with the relationship between environmental factors and alpha diversity, please use add_abund_table parameter in the cal_cor function. t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) # use add_abund_table parameter to add the extra data table t1$cal_cor(add_abund_table = dataset$alpha_diversity) # try to use ggplot2 with clustering plot # require ggtree and aplot packages to be installed (https://chiliubio.github.io/microeco_tutorial/intro.html#dependence) t1$plot_cor(cluster_ggplot = &quot;both&quot;) The function plot_scatterfit in trans_env class is designed for the scatter plot, adding the fitted line and statistics of correlation or regression. # use pH and bray-curtis distance # add correlation statistics t1$plot_scatterfit( x = &quot;pH&quot;, y = dataset$beta_diversity$bray[rownames(t1$data_env), rownames(t1$data_env)], type = &quot;cor&quot;, point_size = 3, point_alpha = 0.1, label.x.npc = &quot;center&quot;, label.y.npc = &quot;bottom&quot;, x_axis_title = &quot;Euclidean distance of pH&quot;, y_axis_title = &quot;Bray-Curtis distance&quot; ) # regression with type = &quot;lm&quot;, use group parameter for different groups t1$plot_scatterfit( x = dataset$beta_diversity$bray[rownames(t1$data_env), rownames(t1$data_env)], y = &quot;pH&quot;, type = &quot;lm&quot;, group = &quot;Group&quot;, group_order = c(&quot;CW&quot;, &quot;TW&quot;, &quot;IW&quot;), point_size = 3, point_alpha = 0.3, line_se = FALSE, line_size = 1.5, shape_values = c(16, 17, 7), y_axis_title = &quot;Euclidean distance of pH&quot;, x_axis_title = &quot;Bray-Curtis distance&quot; ) + theme(axis.title = element_text(size = 17)) Other examples. t1 &lt;- trans_env$new(dataset = new_test, env_cols = 8:15) # with forward selection in RDA t1$cal_ordination(method = &quot;dbRDA&quot;, feature_sel = TRUE) # CCA, canonical correspondence analysis t1$cal_ordination(method = &quot;CCA&quot;, taxa_level = &quot;Genus&quot;) t1$trans_ordination(adjust_arrow_length = TRUE) t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;ellipse&quot;)) # correlation analysis without p adjustment t1$cal_cor(use_data = &quot;Genus&quot;, p_adjust_method = &quot;none&quot;, use_taxa_num = 30) # correlation heatmap with clustering based on the ggplot2 and aplot packages g1 &lt;- t1$plot_cor(cluster_ggplot = &quot;both&quot;) g1 # clustering heatmap with ggplot2 depends on aplot package # to change the detail in the plot, please manipulate each element of g1 g1[[1]] # standardize x axis text format g1[[1]] &lt;- g1[[1]] + scale_x_discrete(labels = c(NH4 = expression(NH[4]^&#39;+&#39;-N), NO3 = expression(NO[3]^&#39;-&#39;-N))) g1[[1]] g1 ggplot2::ggsave(&quot;test.pdf&quot;, g1, width = 8, height = 6) # For regression, lm_equation = FALSE can be applied to not display the equation. t1$plot_scatterfit(x = 1, y = 2, type = &quot;lm&quot;, lm_equation = TRUE) # use line_alpha to adjust the transparency of the confidence interval t1$plot_scatterfit(x = 1, y = 2, type = &quot;lm&quot;, lm_equation = FALSE, line_alpha = 0.3) t1$plot_scatterfit(x = 1, y = 2, type = &quot;lm&quot;, point_alpha = .3, line_se = FALSE) t1$plot_scatterfit(x = 1, y = 2, type = &quot;lm&quot;, line_se_color = &quot;grey90&quot;, label_sep = &quot;,&quot;, label.x.npc = &quot;center&quot;, label.y.npc = &quot;bottom&quot;) t1$plot_scatterfit(x = 1, y = 2, line_se = FALSE, pvalue_trim = 3, cor_coef_trim = 3) t1$plot_scatterfit(x = &quot;pH&quot;, y = &quot;TOC&quot;, type = &quot;lm&quot;, group = &quot;Group&quot;, line_se = FALSE, label.x.npc = &quot;center&quot;, shape_values = 1:3, x_axis_title = &quot;pH&quot;, y_axis_title = &quot;TOC&quot;) # correlation between relative abundance of Genus-Arthrobacter and pH tmp &lt;- unlist(dataset$taxa_abund$Genus[&quot;k__Bacteria|p__Actinobacteria|c__Actinobacteria|o__Micrococcales|f__Micrococcaceae|g__Arthrobacter&quot;, ]) t1$plot_scatterfit(x = &quot;pH&quot;, y = tmp, point_size = 3, point_alpha = 0.3, y_axis_title = &quot;Arthrobacter&quot;, x_axis_title = &quot;pH&quot;) 7.1.2 Key points complete_na parameter in trans_env$new: used to fill the NA (missing value) of the environmental data based on the mice package. env_cols parameter in trans_env$new: select the variables from sample_table of your microtable object. add_abund_table parameter in cal_cor: other customized data can be also provided for the correlation analysis. use_cor parameter in plot_scatterfit: both the correlation and regression are available in this function. cal_mantel(): partial_mantel = TRUE can be used for partial mantel test. plot_ordination(): use plot_type parameter to select point types and env_nudge_x and taxa_nudge_x (also _y) to adjust the text positions. 7.2 trans_func class  Ecological researchers are usually interested in the the funtional profiles of microbial communities, because functional or metabolic data is powerful to explain the structure and dynamics of microbial communities. As metagenomic sequencing is complicated and expensive, using amplicon sequencing data to predict functional profiles is an alternative choice. Several software are often used for this goal, such as PICRUSt (Langille et al. 2013), Tax4Fun (Aßhauer et al. 2015) and FAPROTAX (Stilianos Louca et al. 2016; S. Louca, Parfrey, and Doebeli 2016). These tools are great to be used for the prediction of functional profiles based on the prokaryotic communities from sequencing results. In addition, it is also important to obtain the traits or functions for each taxa, not just the whole profile of communities. FAPROTAX database is a collection of the traits and functions of prokaryotes based on the known research results published in books and literatures. We match the taxonomic information of prokaryotes against this database to predict the traits of prokaryotes on biogeochemical roles. The NJC19 database (Lim et al. 2020) is also available for animal-associated prokaryotic data, such as human gut microbiota. We also implement the FUNGuild (Nguyen et al. 2016) and FungalTraits (Põlme et al. 2020) databases to predict the fungal traits. The idea identifying prokaryotic traits and functional redundancy was initially inspired by our another study (C. Liu et al. 2022). 7.2.1 Example We first identify/predict traits of taxa with the prokaryotic example data. # create object of trans_func t2 &lt;- trans_func$new(dataset) # mapping the taxonomy to the database # this can recognize prokaryotes or fungi automatically if the names of taxonomic levels are standard. # for fungi example, see https://chiliubio.github.io/microeco_tutorial/other-dataset.html#fungi-data # default database for prokaryotes is FAPROTAX database t2$cal_spe_func(prok_database = &quot;FAPROTAX&quot;) ## FAPROTAX v1.2.6. Please also cite the original FAPROTAX paper: Louca et al. (2016). ## Decoupling function and taxonomy in the global ocean microbiome. Science, 353(6305), 1272. ## The functional binary table is stored in object$res_spe_func ... # return t2$res_spe_func, 1 represent trait exists, 0 represent no or cannot confirmed. t2$res_spe_func[1:5, 1:2]   methanotrophy acetoclastic_methanogenesis OTU_4272 0 0 OTU_236 0 0 OTU_399 0 0 OTU_1556 0 0 OTU_32 0 0 The percentages of the OTUs having the same trait can reflect the functional redundancy of this function in the community. # calculate the percentages for communities # here do not consider the abundance t2$cal_spe_func_perc(abundance_weighted = FALSE) ## The result table is stored in object$res_spe_func_perc ... # t2$res_spe_func_perc[1:5, 1:2]   methanotrophy acetoclastic_methanogenesis S1 0.39 0.04 S2 0.27 0 S3 0.48 0 S4 0.48 0 S5 0.56 0 From v1.3.0, the trans_spe_func_perc function is implemented to get the long-format table for more flexible manipulation, e.g., filtering and grouping. The return res_spe_func_perc_trans in the object is the table for the following visualization. Note that this step is not necessary as plot_spe_func_perc function can automatically invoke this function if res_spe_func_perc_trans is not found. t2$trans_spe_func_perc() t2$plot_spe_func_perc() For the differential test of the abundance percentages across groups, please move to another part (https://chiliubio.github.io/microeco_tutorial/other-examples-1.html#faprotax-differential-test). Then we take another example to show the percentages of the OTUs for each trait in network modules. # construct a network for the example network &lt;- trans_network$new(dataset = dataset, cal_cor = &quot;base&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.0001, cor_method = &quot;spearman&quot;) network$cal_network(p_thres = 0.01, COR_cut = 0.7) network$cal_module() # convert module info to microtable object meco_module &lt;- network$trans_comm(use_col = &quot;module&quot;) meco_module_func &lt;- trans_func$new(meco_module) meco_module_func$cal_spe_func(prok_database = &quot;FAPROTAX&quot;) meco_module_func$cal_spe_func_perc(abundance_weighted = FALSE) meco_module_func$plot_spe_func_perc(order_x = paste0(&quot;M&quot;, 1:10)) # If you want to change the group list, reset the list t2$func_group_list t2$func_group_list # use show_prok_func to see the detailed information of prokaryotic traits t2$show_prok_func(&quot;methanotrophy&quot;) Then we try to correlate the percentage data in res_spe_func_perc to environmental variables. t3 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) t3$cal_cor(add_abund_table = t2$res_spe_func_perc, cor_method = &quot;spearman&quot;) t3$plot_cor(pheatmap = TRUE) Tax4Fun (Aßhauer et al. 2015) requires a strict input file format associated with the taxonomic information. To analyze the trimmed or changed OTU data in R with Tax4Fun, we provide a link to the Tax4Fun functional prediction. Please check out the dependence part https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun for installing Tax4Fun package and download SILVA123 ref data. t1 &lt;- trans_func$new(dataset) # https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun for the installation description # and provide the file path of SILVA123 t1$cal_tax4fun(folderReferenceData = &quot;./SILVA123&quot;) # return two files: t1$tax4fun_KO: KO file; t1$tax4fun_path: pathway file. # t1$tax4fun_KO$Tax4FunProfile[1:5, 1:2]   K00001; alcohol dehydrogenase [EC:1.1.1.1] K00002; alcohol dehydrogenase (NADP+) [EC:1.1.1.2] S1 0.0004823 5.942e-06 S2 0.0005266 4.017e-06 S3 0.0005054 6.168e-06 S4 0.0005109 5.888e-06 S5 0.0005083 5.547e-06 We further analyze the abundance of predicted metabolic pathways. # must transpose to taxa row, sample column pathway_file &lt;- t1$tax4fun_path$Tax4FunProfile %&gt;% t %&gt;% as.data.frame # filter rownames, only keep ko+number rownames(pathway_file) %&lt;&gt;% gsub(&quot;(^.*);\\\\s.*&quot;, &quot;\\\\1&quot;, .) # load the pathway hierarchical metadata data(Tax4Fun2_KEGG) # further create a microtable object, familiar? func1 &lt;- microtable$new(otu_table = pathway_file, tax_table = Tax4Fun2_KEGG$ptw_desc, sample_table = t1$sample_table) print(func1) ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 284 rows and 90 columns ## tax_table have 444 rows and 3 columns Now, we need to trim data and calculate abundance. func1$tidy_dataset() # calculate abundance automatically at three levels: Level.1, Level.2, Level.3 func1$cal_abund() ## The result is stored in object$taxa_abund ... print(func1) ## microtable-class object: ## sample_table have 90 rows and 4 columns ## otu_table have 282 rows and 90 columns ## tax_table have 282 rows and 3 columns ## Taxa abundance: calculated for Level.1,Level.2,Level.3 Then, we can plot the abundance. # bar plot at Level.1 func2 &lt;- trans_abund$new(func1, taxrank = &quot;Level.1&quot;, groupmean = &quot;Group&quot;) func2$plot_bar(legend_text_italic = FALSE) We can also do something else. For example, we can use lefse to test the differences of the abundances and find the important enriched pathways across groups. func2 &lt;- trans_diff$new(dataset = func1, method = &quot;lefse&quot;, group = &quot;Group&quot;, alpha = 0.05, lefse_subgroup = NULL) func2$plot_diff_bar(threshold = 3, width = 0.8) Tax4Fun2 (Wemheuer et al. 2020) is another R package for the prediction of functional profiles of prokaryotic communities from 16S rRNA gene sequences. It also provides two indexes for the evaluation of functional gene redundancies. If the user want to use Tax4Fun2 method, the representative fasta file is necessary to be added in the microtable object. Please check out https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun2 to see how to read fasta file with read.fasta of seqinr package or readDNAStringSet of Biostrings package. Please also see https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun2 for downloading ncbi-blast and Ref99NR/Ref100NR. For windows system, ncbi-blast-2.5.0+ is recommended since other versions can not operate well. # first delete the dataset created before rm(dataset) # load the example dataset from microeco package as there is the rep_fasta object in it data(dataset) dataset t1 &lt;- trans_func$new(dataset) # create a directory for result and log files dir.create(&quot;test_prediction&quot;) # https://chiliubio.github.io/microeco_tutorial/intro.html#tax4fun2 for installation # ignore blast_tool_path parameter if blast tools have been in path # the function can search whether blast tool directory is in the path, if not, automatically use provided blast_tool_path parameter t1$cal_tax4fun2(blast_tool_path = &quot;ncbi-blast-2.5.0+/bin&quot;, path_to_reference_data = &quot;Tax4Fun2_ReferenceData_v2&quot;, database_mode = &quot;Ref99NR&quot;, path_to_temp_folder = &quot;test_prediction&quot;) # prepare feature table and metadata data(Tax4Fun2_KEGG) # create a microtable object for pathways func2 &lt;- microtable$new(otu_table = t1$res_tax4fun2_pathway, tax_table = Tax4Fun2_KEGG$ptw_desc, sample_table = dataset$sample_table) func2$tidy_dataset() func2$cal_abund() # calculate functional redundancies t1$cal_tax4fun2_FRI() 7.2.2 Key points blast_tool_path parameter in cal_tax4fun2: if the blast tool has been in ‘environment variable’ of computer, it is ok to use blast_tool_path = NULL blast version: tax4fun2 require NCBI blast tool. However, some errors often come from the latest versions (https://www.biostars.org/p/413294/). An easy solution is to use previous version (such as v2.5.0). References "],["file2meco-package.html", "Chapter 8 file2meco package 8.1 QIIME 8.2 QIIME2 8.3 HUMAnN 8.4 MetaPhlAn 8.5 Kraken2/Braken 8.6 NCycDB/PCycDB 8.7 phyloseq 8.8 PICRUSt2 8.9 ViromeScan", " Chapter 8 file2meco package In the microtable class part, we showed the basic way about how to create microtable object with the example data. Actually, constructing the microtable object from other tools/platforms (e.g., QIIME, QIIME2, HUMAnN, Kraken2 and phyloseq) can be easily achieved with the package file2meco (https://github.com/ChiLiubio/file2meco). The idea of creating file2meco package comes from a study involved in complex metagenomic analysis (C. Liu et al. 2022). Note that the sample_table parameter in each function of file2meco package supports various metadata input format, including 1) comma seperated file with the suffix .csv or tab seperated file with the suffix .tsv or .txt; 2) Excel file with the suffix .xlsx or .xls; 3) data.frame object in R session. # install file2meco package (&gt;= 0.7.0) if(!require(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) if(!require(&quot;file2meco&quot;)) install.packages(&quot;file2meco&quot;, repos = BiocManager::repositories()) ▲ Trouble shooting: • The files in the following examples all come from the package file2meco and are found by the function system.file automatically irrespective of Operating System. When the user imports a file, please donot use this function. The first thing should be to make sure that R can find your input file. The user should either provide a full path to the import function or only the file name after putting the file into the R working directory. For the latter one, if the user does not know where the working directory is, please use the function getwd to find the working directory or directly create a new project in the target directory with RStudio [File –&gt; New Project]. 8.1 QIIME The qiime1meco() function can be used to construct the microtable object using the raw OTU file from QIIME 1 (Caporaso et al. 2010). library(file2meco) # see the help document ?qiime1meco # Let&#39;s run the examples # use the raw data files stored inside the package otu_file_path &lt;- system.file(&quot;extdata&quot;, &quot;otu_table_raw.txt&quot;, package=&quot;file2meco&quot;) # csv file of metadata sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample_info.csv&quot;, package=&quot;file2meco&quot;) phylo_file_path &lt;- system.file(&quot;extdata&quot;, &quot;rep_phylo.tre&quot;, package=&quot;file2meco&quot;) # if you want to use Tax4Fun2 approach, you need read the representative sequences and add it to the microtable object. rep_fasta_path &lt;- system.file(&quot;extdata&quot;, &quot;rep.fna&quot;, package=&quot;file2meco&quot;) # contruct microtable object qiime1meco(otu_file_path) qiime1meco(otu_file_path, sample_table = sample_file_path) qiime1meco(otu_file_path, sample_table = sample_file_path, phylo_tree = phylo_file_path) qiime1meco(otu_file_path, sample_table = sample_file_path, phylo_tree = phylo_file_path, rep_fasta = rep_fasta_path) 8.2 QIIME2 The qiime2meco() function is designed to create the microtable object using files from QIIME2 (Bolyen et al. 2019). The example data is the ASV (amplicon sequence variant) abundance table based on DADA2 (Callahan et al. 2016). library(file2meco) ?qiime2meco # use data files inside the package which were downloaded from (https://docs.qiime2.org/2022.2/tutorials/pd-mice/). abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;dada2_table.qza&quot;, package=&quot;file2meco&quot;) # tsv file of metadata sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample-metadata.tsv&quot;, package=&quot;file2meco&quot;) taxonomy_file_path &lt;- system.file(&quot;extdata&quot;, &quot;taxonomy.qza&quot;, package=&quot;file2meco&quot;) # construct microtable object qiime2meco(abund_file_path) qiime2meco(abund_file_path, sample_table = sample_file_path, taxonomy_table = taxonomy_file_path) # add phylogenetic tree and fasta for more demonstrations # please download tree from https://docs.qiime2.org/2022.2/data/tutorials/pd-mice/tree.qza # the file name is &#39;tree.qza&#39;; put it into the R working directory tree_data &lt;- &quot;tree.qza&quot; # please download fasta from https://docs.qiime2.org/2022.2/data/tutorials/pd-mice/dada2_rep_set.qza # the file name is &#39;dada2_rep_set.qza&#39;; put it into the R working directory rep_data &lt;- &quot;dada2_rep_set.qza&quot; test1 &lt;- qiime2meco(abund_file_path, sample_table = sample_file_path, taxonomy_table = taxonomy_file_path, phylo_tree = tree_data, rep_fasta = rep_data, auto_tidy = TRUE) test1 8.3 HUMAnN Many methods in microeco package can be used not only for the traditional species abundance data, i.e. species-sample table, but also for other data, such as metagenomic data. HUMAnN (Franzosa et al. 2018) is an excellent tool for functional profiling analysis of metagenomes and metatranscriptomes at species-level. The humann2meco() function can be used to create the microtable object using metagenomic analysis files from HUMAnN3 (https://huttenhower.sph.harvard.edu/humann). Certainly, it can also be used for the whole community profile of metabolic pathways when needed. Currently, it supports both the MetaCyc (https://metacyc.org/) and KEGG pathway abundance file input directly. library(file2meco) library(microeco) library(magrittr) ?humann2meco sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) # MetaCyc pathway database based analysis # use the raw data files stored inside the package for MetaCyc pathway database based analysis abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_HUMAnN_MetaCyc_abund.tsv&quot;, package=&quot;file2meco&quot;) # the default db is &quot;MetaCyc&quot; humann2meco(abund_file_path, db = &quot;MetaCyc&quot;) humann2meco(abund_file_path, db = &quot;MetaCyc&quot;, sample_table = sample_file_path, match_table = match_file_path) # Let&#39;s try more interesting usages with microeco test &lt;- humann2meco(abund_file_path, db = &quot;MetaCyc&quot;, sample_table = sample_file_path, match_table = match_file_path) test$tidy_dataset() # rel = FALSE sum original abundance instead of relative abundance test$cal_abund(select_cols = 1:3, rel = FALSE) test$taxa_abund$Superclass1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] # use_percentage = FALSE disable percentage for relative abundance test1 &lt;- trans_abund$new(test, taxrank = &quot;Superclass1&quot;, ntaxa = 10, use_percentage = FALSE) # reassign ylab title instead of default &#39;Relative Abundance&#39; test1$ylabname &lt;- &quot;Abundance (RPK)&quot; # bar_type = &quot;notfull&quot; show original abundance instead of normalized 0-1 test1$plot_bar(facet = &quot;Group&quot;, bar_type = &quot;notfull&quot;) # select both function and taxa test$cal_abund(select_cols = c(&quot;Superclass1&quot;, &quot;Phylum&quot;, &quot;Genus&quot;), rel = TRUE) test1 &lt;- trans_abund$new(test, taxrank = &quot;Phylum&quot;, ntaxa = 10, delete_taxonomy_lineage = T) test1$plot_bar(facet = &quot;Group&quot;) # functional biomarker test$cal_abund(select_cols = 1:3, rel = TRUE) test$taxa_abund$Superclass1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;) test1$plot_diff_bar(use_number = 1:20) # taxa biomarker test$cal_abund(select_cols = 4:9, rel = TRUE) test$taxa_abund$Phylum %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] # p_adjust_method = &quot;none&quot; shut down the p value adjustment test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;, p_adjust_method = &quot;none&quot;) test1$plot_diff_bar(threshold = 2) # use KEGG pathway based HUMAnN result abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_HUMAnN_KEGG_abund.tsv&quot;, package=&quot;file2meco&quot;) test &lt;- humann2meco(abund_file_path, db = &quot;KEGG&quot;, sample_table = sample_file_path, match_table = match_file_path) test$tax_table %&lt;&gt;% subset(Level.1 != &quot;unclassified&quot;) test$tidy_dataset() 8.4 MetaPhlAn MetaPhlAn is an software used for metagenomic taxonomic profiling (Truong et al. 2015). The format of MetaPhlAn classification results is usually called ‘mpa’ format. The mpa2meco function is developed for this format conversion to microtable object. See the following example of Kraken2 part. 8.5 Kraken2/Braken Kraken is a taxonomic sequence classifier that assigns taxonomic labels to DNA sequences. Kraken examines the k-mers within a query sequence and uses the information within those k-mers to query a database. That database maps k-mers to the lowest common ancestor (LCA) of all genomes known to contain a given k-mer. Kraken2 (Wood, Lu, and Langmead 2019) is the newest version. Braken (Lu et al. 2017) can be applied to estimate species abundance following the Kraken analysis. The merged Kraken2/Braken results can be obtained by merge_metaphlan_tables.py from MetaPhlAn or combine_mpa.py from KrakenTools (https://ccb.jhu.edu/software/krakentools/). # the example is metagenomic classification result # use the raw data files stored inside the package abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_kraken2_merge.txt&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) mpa2meco(abund_file_path) test &lt;- mpa2meco(abund_file_path, sample_table = sample_file_path, match_table = match_file_path) test$tidy_dataset() 8.6 NCycDB/PCycDB NCycDB database (Tu et al. 2018) is a curated integrative database for fast and accurate metagenomic profiling of nitrogen cycling genes. The ncyc2meco function is designed for construct the microtable object using gene abundance files from NCycDB. This function can also be used to parse the output of PCycDB (Zeng et al. 2022) database benefiting from implemented mapping database from v0.7.0. The ncyc2meco function can identify the database and invoke the internal mapping data automatically according to the gene names of input features. library(file2meco) library(microeco) library(magrittr) ?ncyc2meco # use the raw data files stored inside the package abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_Ncyc_table.tsv&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) ncyc2meco(abund_file_path) ncyc2meco(abund_file_path, sample_table = sample_file_path, match_table = match_file_path) # Let&#39;s try more interesting usages with microeco test &lt;- ncyc2meco(abund_file_path, sample_table = sample_file_path, match_table = match_file_path) test$tidy_dataset() # use split_group = TRUE to calculate the pathway abundance with multipe map correspondance test$cal_abund(select_cols = 1:2, rel = TRUE, split_group = TRUE, split_column = &quot;Pathway&quot;) test$taxa_abund$Pathway %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Pathway&quot;) test1$plot_bar(bar_type = &quot;notfull&quot;) # for gene abundance, no splitting on the pathways test$cal_abund(select_cols = 1:2, rel = TRUE, split_group = FALSE) test$taxa_abund$Gene %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Gene&quot;) test1$plot_bar(bar_type = &quot;notfull&quot;) 8.7 phyloseq Two functions meco2phyloseq() and phyloseq2meco() were provided for the conversion between microtable object and phyloseq object of phyloseq package (Mcmurdie and Holmes 2013). # Please first install phyloseq if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;phyloseq&quot;) library(phyloseq) # from microtable to phyloseq object data(&quot;dataset&quot;) physeq &lt;- meco2phyloseq(dataset) physeq # from phyloseq to microtable object data(&quot;GlobalPatterns&quot;) meco_dataset &lt;- phyloseq2meco(GlobalPatterns) meco_dataset 8.8 PICRUSt2 PICRUSt2 (Douglas et al. 2020) contains an updated and larger database of gene families and reference genomes compared to the original version of PICRUSt. We do not create a special file conversion function for PICRUSt2 as it is very easy to convert the output pathway files of PICRUSt2 to microtable object. Two example files of PICRUSt2 output in file2meco package were used to show the operation. # MetaCyc pathway output tmp_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_PICRUSt2_MetaCyc_path_abun_unstrat.tsv&quot;, package=&quot;file2meco&quot;) pathway_table &lt;- read.delim(tmp_file_path, row.names = 1) data(&quot;MetaCyc_pathway_map&quot;) tmp &lt;- microtable$new(otu_table = pathway_table, tax_table = MetaCyc_pathway_map) tmp$tidy_dataset() tmp # KEGG pathway output tmp_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_PICRUSt2_KEGG_path_abun_unstrat.tsv&quot;, package=&quot;file2meco&quot;) pathway_table &lt;- read.delim(tmp_file_path, row.names = 1) data(&quot;Tax4Fun2_KEGG&quot;) tmp &lt;- microtable$new(otu_table = pathway_table, tax_table = Tax4Fun2_KEGG$ptw_desc) tmp$tidy_dataset() tmp 8.9 ViromeScan ViromeScan (Rampelli et al. 2016) is a tool for metagenomic viral community profiling. The input of vs2meco function must be a folder containing all the directories named by sample names. Each sample directory should have the original output files generated by ViromeScan software. library(microeco) library(file2meco) # use viromescan directory inside the package dir_path &lt;- system.file(&quot;extdata&quot;, &quot;viromescan&quot;, package=&quot;file2meco&quot;) d1 &lt;- vs2meco(dir_path) d1$cal_abund(rel = TRUE) # d1$taxa_abund$Family is same with the percentage output of viromescan at # Family level, i.e. Family_level_results-%.txt file d1$cal_abund(rel = FALSE) # d1$taxa_abund$Family is same with the count output of viromescan at # Family level, i.e. Family_level_results-Counts.txt file References "],["other-dataset.html", "Chapter 9 Other dataset 9.1 Fungi data 9.2 Metagenomic data 9.3 Gut microbiome", " Chapter 9 Other dataset 9.1 Fungi data Another ITS sequencing dataset (Gao et al. 2019) is also stored in the example data of the package. Here, we use it as an example to show the use of FUNGuild database(Nguyen et al. 2016). FungalTraits (Põlme et al. 2020) database is also available for identifying fungal traits. library(microeco) library(magrittr) # load ITS data data(sample_info_ITS) data(otu_table_ITS) data(taxonomy_table_ITS) # create microtable object meco_fungi &lt;- microtable$new(sample_table = sample_info_ITS, otu_table = otu_table_ITS, tax_table = taxonomy_table_ITS) # remove the taxa not assigned in the Kingdom &quot;k__Fungi&quot; meco_fungi$tax_table %&lt;&gt;% base::subset(Kingdom == &quot;k__Fungi&quot;) # use tidy_dataset() to make OTUs and samples information consistent across files meco_fungi$tidy_dataset() # create trans_network object t1 &lt;- trans_network$new(dataset = meco_fungi, cal_cor = &quot;WGCNA&quot;, taxa_level = &quot;OTU&quot;, filter_thres = 0.000001, cor_method = &quot;spearman&quot;) # create correlation network t1$cal_network(COR_p_thres = 0.05, COR_cut = 0.6) # add modules t1$cal_module() # convert module info to microtable object meco_module &lt;- t1$trans_comm(use_col = &quot;module&quot;) # create trans_func object t2 &lt;- trans_func$new(meco_module) # identify species traits, automatically select database for prokaryotes or fungi # fungi_database = &quot;FungalTraits&quot; for the FungalTraits database t2$cal_spe_func(fungi_database = &quot;FUNGuild&quot;) # calculate abundance-unweighted functional redundancy of each trait for each network module t2$cal_spe_func_perc(abundance_weighted = FALSE) # plot the functional redundancy of network modules t2$plot_spe_func_perc(order_x = paste0(&quot;M&quot;, 1:10)) 9.2 Metagenomic data In the file2meco package part, we provide several examples to transform the output files of some famous metagenomic tools (e.g. HUMAnN and kraken2) to the microtable object directly. Here, we show some detailed examples using KEGG pathway results. library(microeco) library(file2meco) library(magrittr) ?humann2meco sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_sample_info.tsv&quot;, package=&quot;file2meco&quot;) match_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_metagenome_match_table.tsv&quot;, package=&quot;file2meco&quot;) # use KEGG pathway based HUMAnN result abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;example_HUMAnN_KEGG_abund.tsv&quot;, package=&quot;file2meco&quot;) # match_table parameter can be used to replace sample names test &lt;- humann2meco(abund_file_path, db = &quot;KEGG&quot;, sample_table = sample_file_path, match_table = match_file_path) # remove the unclassified pathway in Level.1 test$tax_table %&lt;&gt;% subset(Level.1 != &quot;unclassified&quot;) test$tidy_dataset() # rel = FALSE donot use relative abundance, use the raw RPK test$cal_abund(select_cols = 1:3, rel = FALSE) # use_percentage = FALSE disable percentage for relative abundance test1 &lt;- trans_abund$new(test, taxrank = &quot;Level.2&quot;, ntaxa = 10, use_percentage = FALSE) test1$plot_bar(facet = &quot;Group&quot;, bar_type = &quot;notfull&quot;, xtext_angle = 30) + ggplot2::ylab(&quot;Abundance (RPK)&quot;) Then, we select both function and taxa to see which taxa those high abundant pathways come from. # This operation is more flexible test$cal_abund(select_cols = c(&quot;Level.1&quot;, &quot;Phylum&quot;, &quot;Genus&quot;), rel = FALSE) test$taxa_abund$Level.1 %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test$taxa_abund$Phylum %&lt;&gt;% .[!grepl(&quot;unclass&quot;, rownames(.)), ] test1 &lt;- trans_abund$new(test, taxrank = &quot;Phylum&quot;, ntaxa = 10, use_percentage = FALSE) test1$plot_bar(facet = &quot;Group&quot;, bar_type = &quot;notfull&quot;, xtext_angle = 30) + ggplot2::ylab(&quot;Abundance (RPK)&quot;) Let’s run LEfSe to find some functional biomarkers to differentiate two groups. # functional biomarker test$cal_abund(select_cols = 1:3, rel = TRUE) test1 &lt;- trans_diff$new(test, method = &quot;lefse&quot;, group = &quot;Group&quot;) test1$plot_diff_bar(threshold = 3) 9.3 Gut microbiome We use mouse gut data stored in file2meco package to show the input of QIIME2 file and the use of metabolic trait database NJC19 database(Lim et al. 2020). library(microeco) library(file2meco) library(ggplot2) # use data files inside the file2meco package. abund_file_path &lt;- system.file(&quot;extdata&quot;, &quot;dada2_table.qza&quot;, package=&quot;file2meco&quot;) sample_file_path &lt;- system.file(&quot;extdata&quot;, &quot;sample-metadata.tsv&quot;, package=&quot;file2meco&quot;) taxonomy_file_path &lt;- system.file(&quot;extdata&quot;, &quot;taxonomy.qza&quot;, package=&quot;file2meco&quot;) # construct microtable object data1 &lt;- qiime2meco(abund_file_path, sample_table = sample_file_path, taxonomy_table = taxonomy_file_path) data1$tidy_dataset() # revise the species names in tax_table as the information in the example file is not standard select_rows &lt;- data1$tax_table$Species != &quot;s__&quot; data1$tax_table$Species[select_rows] &lt;- paste0(&quot;s__&quot;, gsub(&quot;g__&quot;, &quot;&quot;, data1$tax_table$Genus[select_rows]), &quot; &quot;, gsub(&quot;s__&quot;, &quot;&quot;, data1$tax_table$Species[select_rows])) # taxonomic abundance data1$cal_abund() # create object of trans_func data2 &lt;- trans_func$new(data1) # Select NJC19 database data2$cal_spe_func(prok_database = &quot;NJC19&quot;) # get the trait percentage data data2$cal_spe_func_perc(abundance_weighted = FALSE) # inset the trait percentage result into taxa_abund of microtable object data1$taxa_abund$Trait &lt;- as.data.frame(t(data2$res_spe_func_perc)) # use trans_abund to plot t1 &lt;- trans_abund$new(dataset = data1, taxrank = &quot;Trait&quot;, ntaxa = 10, use_percentage = FALSE) t1$plot_box(group = &quot;donor_status&quot;, xtext_angle = 30) + ylab(&quot;Relative population abundance (%)&quot;) + theme(axis.text.x = element_text(size = 13)) # differential abundance test of the traits percentage and use random forest to find biomarkers t1 &lt;- trans_diff$new(dataset = data1, method = &quot;rf&quot;, group = &quot;donor_status&quot;, taxa_level = &quot;Trait&quot;) t1$plot_diff_bar(use_number = 1:30) References "],["notes.html", "Chapter 10 Notes 10.1 clone function 10.2 save function 10.3 Github Issues 10.4 change object 10.5 group order 10.6 add layers to plot 10.7 colors for more groups 10.8 customized data input", " Chapter 10 Notes We show some other important points here. 10.1 clone function R6 class has a special copy mechanism which is different from S3 and S4. If you want to copy an object completely, you should use the function clone instead of direct assignment. # use clone to copy completely t1 &lt;- clone(dataset) t2 &lt;- clone(t1) t2$sample_table &lt;- NULL identical(t2, t1) ## [1] FALSE # this operation is usually unuseful, because changing t2 will also affect t1 t2 &lt;- t1 t2$sample_table &lt;- NULL identical(t2, t1) ## [1] TRUE 10.2 save function As an R6 object is an encapsulated environment, there is also another useful advantage, i.e. the data repeatability. By applying R6 classes, the analyzed data in ‘R Environment’ can have fewest intermediate files. It is also very convenient to save the analyzed data (i.e. object) to local computer with save function for back-up and communication with others. This is the recommended way to send data for the test in ‘Github Issues’. # save &#39;dataset&#39; to local computer save(dataset, file = &quot;dataset.RData&quot;) # load the data by others in their R project load(&quot;dataset.RData&quot;) The dataset.RData can be compressed into zip format for the upload in ‘Github Issues’ (https://github.com/ChiLiubio/microeco/issues). If you want to use R to compress it, please run the following command. zip(&quot;test_data.zip&quot;, &quot;dataset.RData&quot;) The ‘test_data.zip’ is the final compressed file for the upload. This saved object is only related with the package version when you save it and has no matter with the updated package when one load it again. So it is repeatable. 10.3 Github Issues Please write the question/bug/suggestion in ‘Github Issues’ (https://github.com/ChiLiubio/microeco/issues). Several points are recommended. Before creating a ‘New issue’, please first skim through the ‘Issues’ including ‘Open’ and ‘Closed’. Then go ahead if no similar issue is found or the similar issue has not been addressed. Please remember to provide your package version when writing a ‘New issue’. For the specific issue related with data, please provide the data and scripts for the reproduction. If the data has not been published, please provide a toy example or a subset data as far as possible. To provide the data, please use save function as previous part shows (https://chiliubio.github.io/microeco_tutorial/notes.html#save-function), and paste the compressed zip format data. When pasting the script directly, please use ``` at the beginning and end of scripts to mark the code block for the readability as # can cause format chaos without code tag. 10.4 change object All the classes are set public, meaning that you can change, add or remove the objects stored in them as you want. # add a matrix you think useful dataset$my_matrix &lt;- matrix(1, nrow = 4, ncol = 4) # change the information dataset$sample_table %&lt;&gt;% .[, -2] 10.5 group order If the user want to reorder the groups, assigning factors may be the simplest way. data(dataset) t1 &lt;- trans_beta$new(dataset = dataset, measure = &quot;bray&quot;) t1$cal_ordination(ordination = &quot;PCoA&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;) Then we assign factors to the ‘Group’ in sample_table of dataset. We can find the changed group order in the legend and colors in the plot. dataset$sample_table$Group %&lt;&gt;% factor(., levels = c(&quot;IW&quot;, &quot;TW&quot;, &quot;CW&quot;)) str(dataset$sample_table) t1 &lt;- trans_beta$new(dataset = dataset, measure = &quot;bray&quot;) t1$cal_ordination(ordination = &quot;PCoA&quot;) t1$plot_ordination(plot_color = &quot;Group&quot;) 10.6 add layers to plot Most of the plots are generated by applying the ggplot2 package. The important parameters in the plotting functions are configured according to our experience. If the inner parameters can not enough, the user can add the layers to the plot like the following operation or make the plot using the data (generally data.frame class) stored in the object. t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) g1 &lt;- t1$plot_bar(others_color = &quot;grey70&quot;, legend_text_italic = FALSE) g1 + theme_classic() + theme(axis.title.y = element_text(size = 18)) 10.7 colors for more groups Within the R microeco package, for the visualization of discrete data, RColorBrewer::brewer.pal(8, \"Dark2\") is employed as the default color generation option. As this palette encompasses merely eight unique colors, users who require additional variations or seek to switch to a different color palette are advised to utilize the paletteer package (https://r-charts.com/color-palettes/). install.packages(&quot;paletteer&quot;) library(&quot;paletteer&quot;) # examples paletteer_d(&quot;RColorBrewer::Spectral&quot;) paletteer_d(&quot;RColorBrewer::Set3&quot;) paletteer_d(&quot;RColorBrewer::Paired&quot;) paletteer_d(&quot;ggsci::nrc_npg&quot;) paletteer_d(&quot;ggsci::default_aaas&quot;) paletteer_d(&quot;ggsci::lanonc_lancet&quot;) paletteer_d(&quot;ggsci::default_nejm&quot;) paletteer_d(&quot;ggsci::category10_d3&quot;) paletteer_d(&quot;ggthemes::Classic_10_Light&quot;) paletteer_d(&quot;ggthemes::Classic_10_Medium&quot;) paletteer_d(&quot;ggthemes::Classic_Cyclic&quot;) # 20 color values paletteer_d(&quot;ggsci::category20c_d3&quot;) paletteer_d(&quot;ggsci::category20_d3&quot;) paletteer_d(&quot;ggthemes::Classic_20&quot;) t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 10, groupmean = &quot;Group&quot;) t1$plot_bar(color_values = paletteer_d(&quot;ggthemes::Classic_10_Medium&quot;)) t1 &lt;- trans_abund$new(dataset = dataset, taxrank = &quot;Phylum&quot;, ntaxa = 20, groupmean = &quot;Group&quot;) t1$plot_bar(color_values = paletteer_d(&quot;ggthemes::Classic_20&quot;)) 10.8 customized data input From v0.7.0, trans_alpha, trans_env and trans_venn classes can accept NULL dataset input for some customized usage of some functions in those classes. t1 &lt;- trans_env$new() t1 &lt;- trans_alpha$new(dataset = NULL, group = NULL) "],["mecodev-package.html", "Chapter 11 mecodev package 11.1 trans_rarefy 11.2 trans_norm 11.3 trans_ts 11.4 trans_gamma", " Chapter 11 mecodev package The mecodev package (https://github.com/ChiLiubio/mecodev/) is designed for more extended analysis approaches based on the microeco package. 11.1 trans_rarefy The class trans_rarefy in mecodev package can be used for the rarefaction and the following plotting to see whether the sequencing depth is enough to cover all the so-called species in the microbial community. library(microeco) library(mecodev) data(sample_info_16S) data(otu_table_16S) # set.seed is used to fix the random number generation to make the results repeatable set.seed(123) dataset &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S) dataset$tidy_dataset() # trans_rarefy class t1 &lt;- trans_rarefy$new(dataset, alphadiv = &quot;Observed&quot;, depth = c(0, 10, 50, 500, 2000, 4000, 6000, 8000)) t1$plot_rarefy(color = &quot;Group&quot;, show_point = FALSE, add_fitting = FALSE) t1$plot_rarefy(color = &quot;Group&quot;, show_point = FALSE, add_fitting = TRUE) 11.2 trans_norm The class trans_norm provide several data normalization or transformation approaches for the microtable object or data.frame object. The format of output will be same with the input. library(microeco) library(mecodev) data(dataset) test1 &lt;- trans_norm$new(dataset = dataset) # Centered log-ratio normalization test2 &lt;- test1$norm(method = &quot;CLR&quot;) # test2 is another microtable object # Cumulative sum scaling normalization test2 &lt;- test1$norm(method = &quot;CCS&quot;) # Total sum scaling, dividing counts by the sequencing depth test2 &lt;- test1$norm(method = &quot;TSS&quot;) # log transformation test2 &lt;- test1$norm(method = &quot;log&quot;) # Arc sine square root transformation test1 &lt;- trans_norm$new(dataset$taxa_abund$Genus) test3 &lt;- test1$norm(method = &quot;AST&quot;) # test3 is data.frame format 11.3 trans_ts The class trans_ts is designed for the time series data analysis. A commonly used approach for modeling microbial ecology for time series data is the generalized Lotka-Volterra (gLV) model, the classical predator-prey systems. gLV models are based on ordinary differential equations that model the logistic growth of species; naturally capture predator-prey, amensalistic, and competitive interactions; and have been applied to study dynamics of microbial ecosystems. More importantly, from a practical perspective, gLV models have been used for a range of applications including identifying potential probiotics against pathogens, forecasting changes in microbial density, characterizing important community members (e.g., keystone species), and analyzing community stability (see (Li et al. 2019) and the references therein). Currently, the biomass estimation and biological interaction prediction approaches are implemented based on the beem package (Li et al. 2019). The example data ‘gut_microb_ts’ comes from the article (Gibbons et al. 2017). # install the necessary packages # For windows system: install.packages(&quot;doMC&quot;, repos = &quot;http://R-Forge.R-project.org&quot;) # For linux or mac install.packages(&quot;doMC&quot;) # Then install the following packages install.packages(&quot;lokern&quot;) install.packages(&quot;monomvn&quot;) install.packages(&quot;pspline&quot;) devtools::install_github(&#39;csb5/beem&#39;) library(mecodev) # load the example data in mecodev package; the input must be a microtable object # There are several strict requirements on the sample_table; see the document of the class. data(&quot;gut_microb_ts&quot;) # generally, using filter_thres to filter the taxa with low abundance is crutial # there are only 22 taxa in the example data, we use 0 t1 &lt;- trans_ts$new(dataset = gut_microb_ts, filter_thres = 0.005) # use minimal 30 times for iteration t1$cal_biomass(min_iter = 30) # return t1$res_biomass and t1$res_param # t2 is a trans_network object t2 &lt;- t1$cal_network() # use cluster_optimal; as the default cluster_fast_greedy can not be used for the directed network t2$cal_module(method = &quot;cluster_optimal&quot;) 11.4 trans_gamma The class trans_gamma is developed to explore the relationship between gamma diversity and beta diversity based on the methods from biogeographic studies(Zhang et al. 2020). Currently, the contents include the observed beta-gamma diversity relationship, simulated beta-gamma diversity relationship and the following plotting. If the observed gamma diversity and beta diversity are significantly correlated, species pool at regional scale (or maybe your defined scale, e.g., different treatments in the lab) can have large effect on the beta diversity. Thus, species pool should be first considered to explain beta diversity patterns. This class also provide simulation function to explore the relation between gamma diversity and beta diversity in the absence of any process other than random sampling based on the species log-normal distribution. We use the wetland data to show the observed beta-gamma diversity relationship. library(microeco) library(mecodev) # load the example data data(sample_info_16S) data(otu_table_16S) test &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S) test$tidy_dataset() test$rarefy_samples(sample.size = 10000) # then create trans_gamma object test1 &lt;- trans_gamma$new(dataset = test, group = &quot;Type&quot;, method = &quot;bray&quot;) test1$cal_observed(sample_size = NULL) test1$res_observed # use Spearman correlation test1$plot_observed(cor_method = &quot;spearman&quot;) Let’s simulate the relation between gamma diversity and beta diversity in the absence of any process other than random sampling based on the species log-normal distribution. # if you only run the simulation, dataset parameter is not necessary test1 &lt;- trans_gamma$new(method = &quot;bray&quot;) # use individul numbers at 200, 1000 and 2000, and hypothesize each species pool have 20 samples. test1$cal_simulation(ncom = 20, ind_vect = c(200, 1000, 2000)) test1$plot_simulation(add_fitting = FALSE) References "],["meconetcomp-package.html", "Chapter 12 meconetcomp package 12.1 Network modularity for all networks 12.2 Network topological attributes for all networks 12.3 Node and edge properties extraction for all networks 12.4 Compare nodes across networks 12.5 Compare edges across networks 12.6 Extract overlapped edges of networks to a new network 12.7 Compare phylogenetic distances of paired nodes in edges 12.8 Compare node sources of edges across networks 12.9 Compare topological properties of sub-networks 12.10 Robustness of network 12.11 Vulnerability of nodes", " Chapter 12 meconetcomp package To facilitate microbial co-occurrence network comparison, R package meconetcomp (https://github.com/ChiLiubio/meconetcomp) was developed. The basic strategy is to use R list to put into all the trans_network objects and perform the following analysis. The flow chart and following contents are adapted from the published article (C. Liu et al. 2023). For more details, please see the online paper (https://doi.org/10.1002/imt2.71). # install the required packages # aplot: one dependency of the trans_venn class of microeco package # agricolae: for Duncan&#39;s new multiple range test packages &lt;- c(&quot;meconetcomp&quot;, &quot;rgexf&quot;, &quot;pheatmap&quot;, &quot;aplot&quot;, &quot;agricolae&quot;) # Now check or install for(x in packages){ if(!require(x, character.only = TRUE)) { install.packages(x, dependencies = TRUE) } } library(microeco) library(meconetcomp) # use pipe operator in magrittr package library(magrittr) library(igraph) library(ggplot2) # load soil amplicon sequencing dataset data(soil_amp) First reconstruct three correlation networks for the three groups ‘IW’, ‘TW’ and ‘CW’ as the example. # first create a list soil_amp_network &lt;- list() # select samples of &quot;IW&quot; group # use clone to get a deep copy of soil_amp (R6 object) tmp &lt;- clone(soil_amp) # change sample_table directly tmp$sample_table %&lt;&gt;% subset(Group == &quot;IW&quot;) # trim all files in the object tmp$tidy_dataset() # use filter_thres parameter to filter the feature with low relative abundance tmp &lt;- trans_network$new(dataset = tmp, cor_method = &quot;spearman&quot;, filter_thres = 0.0005) # COR_p_thres represents the p value threshold # COR_cut denotes the correlation coefficient threshold tmp$cal_network(COR_p_thres = 0.01, COR_cut = 0.6) # put the network into the list soil_amp_network$IW &lt;- tmp # select samples of &quot;TW&quot; group tmp &lt;- clone(soil_amp) tmp$sample_table %&lt;&gt;% subset(Group == &quot;TW&quot;) tmp$tidy_dataset() tmp &lt;- trans_network$new(dataset = tmp, cor_method = &quot;spearman&quot;, filter_thres = 0.0005) tmp$cal_network(COR_p_thres = 0.01, COR_cut = 0.6) soil_amp_network$TW &lt;- tmp # select samples of &quot;CW&quot; group tmp &lt;- clone(soil_amp) tmp$sample_table %&lt;&gt;% subset(Group == &quot;CW&quot;) tmp$tidy_dataset() tmp &lt;- trans_network$new(dataset = tmp, cor_method = &quot;spearman&quot;, filter_thres = 0.0005) tmp$cal_network(COR_p_thres = 0.01, COR_cut = 0.6) soil_amp_network$CW &lt;- tmp # Now we have the list soil_amp_network 12.1 Network modularity for all networks The function cal_module in meconetcomp package is designed to partition modules for all the networks in the list. soil_amp_network %&lt;&gt;% cal_module(undirected_method = &quot;cluster_fast_greedy&quot;) 12.2 Network topological attributes for all networks we extracted all the res_network_attr tables in the networks and merged them into one final table by using cal_network_attr function in meconetcomp package. tmp &lt;- cal_network_attr(soil_amp_network) # tmp is a data.frame object 12.3 Node and edge properties extraction for all networks The get_node_table and get_edge_table functions of meconetcomp package can be used to directly extract node and edge properties for all the networks. The return table is stored in each network object. soil_amp_network %&lt;&gt;% get_node_table(node_roles = TRUE) %&gt;% get_edge_table 12.4 Compare nodes across networks The nodes in all the networks can be converted to a new microtable object by using the node_comp function of meconetcomp package. Then, it is easy to analyse the nodes overlap with trans_venn class. # obtain the node distributions by searching the res_node_table in the object tmp &lt;- node_comp(soil_amp_network, property = &quot;name&quot;) # obtain nodes intersection tmp1 &lt;- trans_venn$new(tmp, ratio = &quot;numratio&quot;) g1 &lt;- tmp1$plot_venn(fill_color = FALSE) ggsave(&quot;soil_amp_node_overlap.pdf&quot;, g1, width = 7, height = 6) # calculate jaccard distance to reflect the overall differences of networks tmp$cal_betadiv(method = &quot;jaccard&quot;) tmp$beta_diversity$jaccard 12.5 Compare edges across networks The pipeline of studying edges overlap is similar with the above operations of nodes comparison. The edge_comp function of meconetcomp package is used to convert edges distribution to a new microtable object. # get the edge distributions across networks tmp &lt;- edge_comp(soil_amp_network) # obtain edges intersection tmp1 &lt;- trans_venn$new(tmp, ratio = &quot;numratio&quot;) g1 &lt;- tmp1$plot_venn(fill_color = FALSE) ggsave(&quot;soil_amp_edge_overlap.pdf&quot;, g1, width = 7, height = 6) # calculate jaccard distance tmp$cal_betadiv(method = &quot;jaccard&quot;) tmp$beta_diversity$jaccard 12.6 Extract overlapped edges of networks to a new network Then we extracted the subset of edges according to the intersections of edges across networks, which can be accomplished with the subset_network function in meconetcomp package. # first obtain edges distribution and intersection tmp &lt;- edge_comp(soil_amp_network) tmp1 &lt;- trans_venn$new(tmp) # convert intersection result to a microtable object tmp2 &lt;- tmp1$trans_comm() # extract the intersection of all the three networks (&quot;IW&quot;, &quot;TW&quot; and &quot;CW&quot;) # please use colnames(tmp2$otu_table) to find the required name Intersec_all &lt;- subset_network(soil_amp_network, venn = tmp2, name = &quot;IW&amp;TW&amp;CW&quot;) # Intersec_all is a trans_network object # for example, save Intersec_all as gexf format Intersec_all$save_network(&quot;Intersec_all.gexf&quot;) 12.7 Compare phylogenetic distances of paired nodes in edges The edge_node_distance class (R6 class) in meconetcomp package is designed to compare the distribution of distance values of paired nodes in all the edges across networks. Here, we indicated the phylogenetic distance distributions and performed the differential test among networks. The input parameter dis_matrix can be any symmetric matrix with both the column names and row names (i.e. feature names). So it is also feasible to compare other properties of features, such as Levin’s niche overlap. # filter useless features to speed up the calculation node_names &lt;- unique(unlist(lapply(soil_amp_network, function(x){colnames(x$data_abund)}))) filter_soil_amp &lt;- microeco::clone(soil_amp) filter_soil_amp$otu_table &lt;- filter_soil_amp$otu_table[node_names, ] filter_soil_amp$tidy_dataset() # obtain phylogenetic distance matrix phylogenetic_distance_soil &lt;- as.matrix(cophenetic(filter_soil_amp$phylo_tree)) # use both the positive and negative labels tmp &lt;- edge_node_distance$new(network_list = soil_amp_network, dis_matrix = phylogenetic_distance_soil, label = c(&quot;+&quot;, &quot;-&quot;)) tmp$cal_diff(method = &quot;anova&quot;) # visualization g1 &lt;- tmp$plot(boxplot_add = &quot;none&quot;, add_sig = TRUE, add_sig_text_size = 5) + ylab(&quot;Phylogenetic distance&quot;) ggsave(&quot;soil_amp_phylo_distance.pdf&quot;, g1, width = 7, height = 6) # show different modules with at least 10 nodes and positive edges tmp &lt;- edge_node_distance$new(network_list = soil_amp_network, dis_matrix = phylogenetic_distance_soil, label = &quot;+&quot;, with_module = TRUE, module_thres = 10) tmp$cal_diff(method = &quot;anova&quot;) g1 &lt;- tmp$plot(boxplot_add = &quot;none&quot;, add_sig = TRUE, add_sig_text_size = 5) + ylab(&quot;Phylogenetic distance&quot;) ggsave(&quot;soil_amp_phylo_distance_modules.pdf&quot;, g1, width = 8, height = 6) 12.8 Compare node sources of edges across networks To know which taxa constitute the nodes in edges is important in understanding species co-occurrence patterns and answering ecological questions. In this part, as an instance, we used edge_tax_comp function of meconetcomp package to get the sums of node sources (at Phylum level) in the positive edges. In other words, how many linked nodes of positive edges come from different phyla or the same phyla. Then, to make the results comparable, the ratio was calculated with the positive edge number as denominator. soil_amp_network_edgetax &lt;- edge_tax_comp(soil_amp_network, taxrank = &quot;Phylum&quot;, label = &quot;+&quot;, rel = TRUE) # filter the features with small number soil_amp_network_edgetax &lt;- soil_amp_network_edgetax[apply(soil_amp_network_edgetax, 1, mean) &gt; 0.01, ] # visualization g1 &lt;- pheatmap::pheatmap(soil_amp_network_edgetax, display_numbers = TRUE) ggsave(&quot;soil_amp_edge_tax_comp.pdf&quot;, g1, width = 7, height = 7) 12.9 Compare topological properties of sub-networks In this part, we extracted the sub-networks according to the OTU existed in each sample of soil_amp dataset for each network in soil_amp_network. Then, the global topological properties of sub-networks were calculated. All the operations were encapsulated into the subnet_property function of meconetcomp package. # calculate global properties of all sub-networks tmp &lt;- subnet_property(soil_amp_network) # then prepare the data for the correlation analysis # use sample names (second column) as rownames rownames(tmp) &lt;- tmp[, 2] # delete first two columns (network name and sample name) tmp &lt;- tmp[, -c(1:2)] # load ready-made abiotic factor and diversity table data(soil_measure_diversity) tmp1 &lt;- trans_env$new(dataset = soil_amp, add_data = soil_measure_diversity) tmp1$cal_cor(use_data = &quot;other&quot;, by_group = &quot;Group&quot;, add_abund_table = tmp, cor_method = &quot;spearman&quot;) # generate correlation heatmap g1 &lt;- tmp1$plot_cor() ggsave(&quot;soil_amp_subnet_property.pdf&quot;, g1, width = 11, height = 5) 12.10 Robustness of network From v0.4.0, the robustness analysis is implemented in the robustness class based on several edge and node removal strategies and robustness measures (Bellingeri et al. 2020; J. Liu et al. 2017). For the details of each method, please see the help document with the command ?robustness. tmp &lt;- robustness$new(soil_amp_network, remove_strategy = c(&quot;edge_rand&quot;, &quot;edge_strong&quot;, &quot;node_degree_high&quot;), remove_ratio = seq(0, 0.99, 0.1), measure = c(&quot;Eff&quot;, &quot;Eigen&quot;, &quot;Pcr&quot;), run = 10) View(tmp$res_table) tmp$plot(linewidth = 1) 12.11 Vulnerability of nodes From v0.4.0, the vulnerability of nodes can be calculated with the vulnerability function. The vulnerability of one node is defined as the efficiency of network after removing this targeted node (Yuan et al. 2021). For the details, please see the help document. vul_table &lt;- vulnerability(soil_amp_network) View(vul_table) References "],["mecoturn-package.html", "Chapter 13 mecoturn package 13.1 betaturn class 13.2 taxaturn class", " Chapter 13 mecoturn package The mecoturn package is designed to study microbial turnover along plant compartments originally (https://github.com/ChiLiubio/mecoturn). Generally speaking, it can be used in any case associated with a gradient. # mecoturn v0.3.0 install.packages(&quot;mecoturn&quot;) # check and install dependent packages packages &lt;- c(&quot;agricolae&quot;) for(x in packages){ if(!require(x, character.only = TRUE)){ install.packages(x) } } 13.1 betaturn class The betaturn class is used to study the turnover of communities, i.e. beta diversity along a gradient (Anderson et al. 2011). The pipeline consists of the steps of dissimilarity matrix generation, matrix conversion, differential test and visualization. Creating betaturn object can generate the dissimilarity matrix stored in the object. The example data wheat_16S is the amplicon sequencing data of 16S rDNA of wheat samples from different regions. In wheat_16S$sample_table, the Type column represents the niches, i.e. plant compartments, including S (bulk soil), RS (rhizosphere soil) and R (root endophyte). The Plant_ID column denotes each unique plant individual that the samples belong to. The Region column means the sampling region of those plants. Each region has five plant individuals. Schematic diagrams of the framework in betaturn class. In the flow chart, Roman numeral represents the data for the input or output of associated step. Arabic numeral within brackets denotes the step for the corresponding operation. The workflow of betaturn class consists of the dissimilarity matrix generation, matrix conversion, differential test and visualization. The core of the workflow is the matrix conversion, which can be classified into two cases (step 5 and 8) in the Figure. Ⅰ: Feature abundance table: microtable$otu_table object. The microtable object can be created by the microtable class (R6 class) in microeco package. The feature abundance table denotes the amplicon sequence variants (ASV) table or operational taxonomic units (OTU) abundance table in a study and should be data.frame format. Ⅱ: Phylogenetic tree: microtable$phylo_tree object. It represents reconstructed phylogenetic tree based on the representative sequences and should be “phylo” format coming from read.tree function in ape package. It is designed for calculating phylogenetic distance matrix of beta diversity, such as mean nearest taxon distance (betaMNTD) and UniFrac metrics. Ⅲ: Sample information table: microtable$sample_table object. It is the sample metadata and must be data.frame format. The ‘Type’ column represents plant compartments (including bulk soil) or other ordered groups used for the following comparison. S: bulk soil; RS: rhizosphere soil; R: root endophyte. The ‘Plant_ID’ column denotes each plant, by which the ordered distance transformation can be accomplished. Ⅳ: Dissimilarity matrix: symmetric distance matrix in betaturn$dataset$beta_diversity list. The names of both the rows and columns of this symmetrical matrix are the sample names and they are correspondingly aligned as well. Ⅴ: Converted table: betaturn$res_group_distance object. It is the output of function cal_group_distance of betaturn class with the parameter “within_group = FALSE”. The table conversion is performed between any two samples of ‘Type’ column in Ⅲ, but the combination of any two samples is constrained by the by_group parameter, i.e. the conversion is only completed within the same plant according to ‘Plant_ID’ column of Ⅲ in the example, which is one of the key features of the mecoturn package. The converted distance table has a new ‘Type’ column as the combination of the elements in ‘Type’ column of original sample information table. The ordered_group is designed optionally to sort the group order in the result. Ⅵ: Statistical analysis: betaturn$res_group_distance_diff object. The approaches that used to compare means or medians across groups (i.e. groups in ‘Type’ column of Ⅲ) are adapted from the cal_diff function of trans_alpha class in microeco package. By accessing the data in betaturn$res_group_distance object, correlation and regression analysis can be easily conducted with the trans_env class of microeco package. Ⅶ: Visualization: the ggplot2 object for the mode-“within_group = FALSE”. Ⅷ: Sample information table similar with Ⅲ. In this example, “Region” column represents that the plants are collected from different regions. It is used to show the mode-“within_group = TRUE”. Ⅸ: Converted table: similar with Ⅴ, but it is generated with the parameter “within_group = TRUE” in cal_group_distance function of betaturn class. The table conversion is accomplished within each element of the “Region” column in Ⅷ for this study. It can also be other column, such as “Plant_ID”. Any two samples within an element of “Region” column will be combined. Under such a circumstance, by_group parameter is designed to generate the additional combinations related to the ‘Type’ and ‘Plant_ID’ columns in this study used for the following filtering. So, in the mode-“within_group = TRUE”, the aim of by_group parameter is to create the combinations of groups as the table shows, not to play a role of restriction of the by_group in the mode-“within_group = FALSE”. Ⅹ: Filtered table: similar with Ⅸ. Here, the filtered table is an example to show the flexible manipulation on the converted table. In this example, needless rows (combined by different plants) are deleted by customized operation in order to generate a final table for the following statistics and visualization. Ⅺ: Visualization: ggplot2 object for the mode-“within_group = TRUE”. (1): betaturn$new function with the parameter measure = “bray” (Bray-Curtis dissimilarity) or measure = “jaccard” (Jaccard dissimilarity). Several beta diversity metrics are provided to obtain the distance matrix by creating betaturn object. (2): betaturn$new function with the parameter measure = “wei_unifrac”, “unwei_unifrac”, “betaMPD” or “betaMNTD”. Several distance metrics of phylogenetic beta diversity require both the file Ⅰ and Ⅱ. (3): betaturn$new function with the parameter measure = “RCbray”. RCbray: Raup–Crick based Bray-Curtis dissimilarity. (4): betaturn$new function with the parameter measure = “betaNRI”, “betaNTI” or “ses_UniFrac”. Phylogenetic beta diversity, plus null model, can be used to obtain the standardized effect size of observed phylogenetic beta diversity. betaNTI: beta nearest taxon index; betaNRI: beta net relatedness index; ses_UniFrac: standardized effect size of UniFrac distance. (5): betaturn$cal_group_distance(within_group = FALSE, …). The distance matrix can be converted to a long format table according to the group classifications in Ⅲ. The ‘Plant_ID’ (or other name) is used for guiding the file conversion in the mode-“within_group = FALSE” of Ⅴ. The new ‘Type’ in Ⅴ is generated by combining paired plant compartments. (6): betaturn$cal_group_distance_diff function. The differential test can be performed with several available approaches shown in the Ⅵ. (7): betaturn$plot_group_distance function. The visualization is implemented based on R ggplo2 and ggpubr packages. The differential test results in step (6) can be mapped to the plot automatically. (8): betaturn$cal_group_distance(within_group = TRUE, …). This step is similar with step (5), but it is performed by the function cal_group_distance with the parameter “within_group = TRUE”. (9): customized manipulation on betaturn$res_group_distance file. This step is to manipulate the file res_group_distance in the betaturn object and delete useless rows in the file according to the customized requirement. (10): Similar with step (6). (11): Similar with step (7). library(mecoturn) library(magrittr) data(wheat_16S) # see the help document of betaturn ?betaturn # use &#39;bray&#39;, i.e. Bray-Curtis dissimilarity, as the example b1 &lt;- betaturn$new(wheat_16S, measure = &quot;bray&quot;) ## The distance matrix is stored in object$beta_diversity list ... The matrix conversion is the core step in the betaturn class. It has two cases: within_group = TRUE and within_group = FALSE. The case within_group = FALSE means the distance conversion is carried out between any two elements of Type column (group parameter). The parameter by_group is used to constrain the conversion, i.e. the conversion is performed for each plant. b1$cal_group_distance(group = &quot;Type&quot;, within_group = FALSE, by_group = &quot;Plant_ID&quot;) ## The result is stored in object$res_group_distance ... head(b1$res_group_distance) ## Value Type Plant_ID ## 1 0.7844286 S vs RS Northwest_Wheat_1 ## 2 0.7922857 S vs RS Northwest_Wheat_2 ## 3 0.6602857 S vs RS Northwest_Wheat_3 ## 4 0.8028571 S vs RS Northwest_Wheat_4 ## 5 0.7151429 S vs RS Northwest_Wheat_5 ## 6 0.6704286 S vs RS East_Wheat_1 The combinations of Type may be not well-organized. We use ordered_group parameter to sort them and sep parameter to assign the direction. b1$cal_group_distance(group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), within_group = FALSE, by_group = &quot;Plant_ID&quot;, sep = &quot; -&gt; &quot;) ## The result is stored in object$res_group_distance ... head(b1$res_group_distance) ## Value Type Plant_ID ## 1 0.7844286 S -&gt; RS Northwest_Wheat_1 ## 2 0.7922857 S -&gt; RS Northwest_Wheat_2 ## 3 0.6602857 S -&gt; RS Northwest_Wheat_3 ## 4 0.8028571 S -&gt; RS Northwest_Wheat_4 ## 5 0.7151429 S -&gt; RS Northwest_Wheat_5 ## 6 0.6704286 S -&gt; RS East_Wheat_1 The cal_group_distance_diff function can be used to perform the statistical analysis. # Wilcoxon rank sum test b1$cal_group_distance_diff(method = &quot;wilcox&quot;) # paired Wilcoxon test by adding by_ID b1$cal_group_distance_diff(method = &quot;wilcox&quot;, by_ID = &quot;Plant_ID&quot;) # box plot b1$plot_group_distance() The parameter add_cols can be used to add other columns in sample_table to the final table when within_group = FALSE. This is especially useful when the statistical analysis will be performed for different groups. b1$cal_group_distance(group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), within_group = FALSE, by_group = &quot;Plant_ID&quot;, sep = &quot; -&gt; &quot;, add_cols = &quot;Region&quot;) head(b1$res_group_distance) # Wilcoxon test for each region b1$cal_group_distance_diff(method = &quot;wilcox&quot;, by_group = &quot;Region&quot;) b1$plot_group_distance() Then let’s use linear mixed-effects model to check the random effects of plants. For the usages of the formula in linear mixed-effects model (lme4 package), see https://mspeekenbrink.github.io/sdam-r-companion/linear-mixed-effects-models.html b1$cal_group_distance(group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), within_group = FALSE, by_group = &quot;Plant_ID&quot;, sep = &quot; -&gt; &quot;, add_cols = &quot;Region&quot;) # random intercept and slope of Region b1$cal_group_distance_diff(method = &quot;lme&quot;, formula = &quot;Type + (1 + Type| Region)&quot;) # random intercept of Plant_ID b1$cal_group_distance_diff(method = &quot;lme&quot;, formula = &quot;Type + (1 | Plant_ID)&quot;) # random intercept of Plant_ID nested in Region b1$cal_group_distance_diff(method = &quot;lme&quot;, formula = &quot;Type + (1 | Region/Plant_ID)&quot;) b1$res_group_distance_diff Another case within_group = TURE means the distance conversion is performed according to each element of the group. For example, when group = \"Region\", any two samples within an element of \"Region\" column will be combined. In this scenario, by_group parameter is designed to generate the additional combinations related to other columns. b1$cal_group_distance(within_group = TRUE, group = &quot;Region&quot;, by_group = c(&quot;Type&quot;, &quot;Plant_ID&quot;)) head(b1$res_group_distance) # filter the combinations not coming from the same plant all_plants &lt;- unique(wheat_16S$sample_table$Plant_ID) b1$res_group_distance %&lt;&gt;% .[.$Plant_ID %in% paste0(all_plants, &quot; vs &quot;, all_plants), ] # compare values across regions b1$cal_group_distance_diff(method = &quot;anova&quot;) b1$plot_group_distance(add_sig_text_size = 5.6, xtext_angle = 30) 13.2 taxaturn class The taxaturn class refers to microbial abundance change along a gradient. Its workflow includes the taxonomic abundance calculation, abundance transformation, abundance change summary, statistical analysis and visualization. The core of this workflow is the abundance change summary and statistical analysis, which can be classified into two cases: by_ID = NULL and by_ID = “Plant_ID” in the example (step 1 or 4, and step 8 in the Figure). Ⅰ: Taxonomic abundance table: the table (data.frame format) in microtable$taxa_abund list. It denotes taxonomic abundance table with the data.frame format at a specific taxonomic level. Ⅱ: Sample information table: the sample metadata, i.e. sample_table in microtable object. The ‘Type’ column represents the plant compartments or other ordered groups used for the following comparisons. The ‘Plant_ID’ column denotes each plant, which can guide the comparison of abundances for each plant when by_ID = “Plant_ID”. “Region” column is used for the cases with by_group = “Region”. Ⅲ: Summarized abundance: taxaturn$res_abund object. This summarized abundance table is converted under the condition of by_ID = NULL and by_group = NULL. Under this condition, the abundance is summarized by the groups of “Type” column of Ⅱ in order to generate ‘Mean’ and ‘SD’ in the result (mean and standard deviation of each group). ‘N’ is the sample number in each group. Ⅳ: Abundance change table: res_change_pair (the upper one) and res_change (the table below) in the taxaturn object. The change pattern along the ordered groups is generated according to the mean abundance in Ⅲ for each taxon. The res_change_pair table has all paired abundance difference values between two neighboring niches for each taxon (the abundance of the latter minus that of the former). The res_change is the following summary information of difference values along ordered paired groups in res_change_pair table. In res_change table, there are three types of changes: ‘Increase’, ‘Decrease’ and others (fluctuation with the combination of ‘+’, ‘-’ or ‘0’, or nothing when no consistent result is obtained across plants). Ⅴ: Statistical analysis. The approaches include beta regression model and differential abundance test between two groups. The differential abundance test is designed for the comparison of two groups, such as differential test between S and RS or between RS and R. There are two implemented approaches: t-Test and Wilcoxon Rank Sum Test. Ⅵ: Summarized abundance. Similar with Ⅲ, but the Mean and SD are performed by both the group (‘Type’) and by_group (‘Region’). So N is less than that in Ⅲ. Ⅶ: Abundance change table. Similar with Ⅳ, but the ‘change’ trend is summarized for different regions, respectively. Ⅷ: Summarized abundance. As by_ID is provided (“Plant_ID”), the N is 1. The Mean is the abundance of each sample of each plant. SD is not available (NA). Ⅸ: Abundance change table: res_change_pair (the upper one) and res_change (the table below) in the taxaturn object. The res_change_pair is a little different from that in Ⅳ, because it is calculated for each individual plant. So the table has a column named by_ID (“Plant_ID”). This table is particularly useful for the association between abundance difference values and environmental factors. The res_change table is the summary result of res_change_pair table. For the case ‘by_group = NULL’, the data in res_change is the consistent abundance comparison along ordered groups and across all the plants. Ⅹ: Abundance change table. Different from the res_change table of Ⅸ, the res_change table in Ⅹ is generated according to the by_group (‘Region’). So the result is the consistent abundance comparisons along ordered groups within each region. Note that the res_change_pair table is not shown here as it is same with res_change_pair in Ⅸ, because the parameter by_group = “Region” only affects the change summary result. Ⅺ: Statistical analysis. Different from Ⅴ, some approaches for this case (by_ID is provided) necessitates consideration of the paired data, such as paired t-Test and paired Wilcoxon Rank Sum Test. The input data will be first sorted by the elements in “Plant_ID” column of Ⅱ. The linear mixed-effects model can be used to test the random effects of plant individuals similar with the Ⅵ. To better fit the relative abundance (bounded by 0 and 1), the family function of generalized linear mixed model (GLMM) in taxaturn class is fixed with the beta distribution function, and the link function is “logit” function. The correlation and regression analysis can be performed by means of the trans_env class of microeco package. (1) and (2): taxaturn$new function. The parameter by_ID = NULL and by_group = NULL is applied in this example. Creating taxaturn object can generate Ⅲ (i.e. res_abund) in the object. If the taxonomic abundance (i.e. taxa_abund list) in the input microtable object is NULL, the function can automatically invoke the cal_abund function in microtable object to calculate it. Creating taxaturn object can also create Ⅳ (i.e. res_change_pair and res_change) in the object. (3): taxaturn$cal_diff function. The cal_diff function in taxaturn class is designed to perform the differential test. (4) and (5): taxaturn$new function. Similar with step (1). The parameter by_ID = NULL and by_group = “Region” is used in this example. (6): Similar with step (3). (7): taxaturn$plot function. The plot function in taxaturn class is used to plot the abundance along ordered groups and generate a ggplot2 object. (8) and (9): taxaturn$new function with the parameter by_ID = “Plant_ID” and by_group = NULL. (10): taxaturn$cal_diff function. For the case that by_ID parameter is provided, the differential abundance test between two groups are designed for the paired data. (8) and (11): taxaturn$new function with the parameter by_ID = “Plant_ID” and by_group = “Region”. (12): Similar with step (10). (13): Similar with step (7). For the case that by_ID parameter is provided, abundance visualization is performed for each element of by_ID parameter, i.e. each plant individual in this example. # study the abundance change of phyla by comparing the mean abundances without the consideration of plants t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), by_ID = NULL, by_group = NULL, filter_thres = 0.001) ## Taxa abundance data is stored in object$res_abund ... ## Abundance change along groups is stored in object$res_change_pair ... ## Abundance change summary is stored in object$res_change ... head(t1$res_change) ## Taxa Direction Change ## 1 k__Archaea|p__Thaumarchaeota S -&gt; RS -&gt; R Decrease ## 2 k__Bacteria|p__Acidobacteria S -&gt; RS -&gt; R Decrease ## 3 k__Bacteria|p__Actinobacteria S -&gt; RS -&gt; R Increase ## 4 k__Bacteria|p__Armatimonadetes S -&gt; RS -&gt; R Decrease ## 5 k__Bacteria|p__Bacteroidetes S -&gt; RS -&gt; R +|- ## 6 k__Bacteria|p__Chloroflexi S -&gt; RS -&gt; R Decrease t1$cal_diff(method = &quot;wilcox&quot;, p_adjust_method = NULL) ## Raw differential test results are stored in object$res_diff_raw ... ## Differential test results have been added into object$res_change ... head(t1$res_change) ## Taxa Direction Change S -&gt; RS | Significance ## 1 k__Archaea|p__Thaumarchaeota S -&gt; RS -&gt; R Decrease *** ## 2 k__Bacteria|p__Acidobacteria S -&gt; RS -&gt; R Decrease *** ## 3 k__Bacteria|p__Actinobacteria S -&gt; RS -&gt; R Increase ns ## 4 k__Bacteria|p__Armatimonadetes S -&gt; RS -&gt; R Decrease * ## 5 k__Bacteria|p__Bacteroidetes S -&gt; RS -&gt; R +|- ns ## 6 k__Bacteria|p__Chloroflexi S -&gt; RS -&gt; R Decrease ** ## RS -&gt; R | Significance ## 1 *** ## 2 *** ## 3 ** ## 4 ** ## 5 ns ## 6 *** # compare the abundance change by summarizing the results for each plant individual t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), by_ID = &quot;Plant_ID&quot;, by_group = NULL, filter_thres = 0.001) ## Taxa abundance data is stored in object$res_abund ... ## Abundance change along groups is stored in object$res_change_pair ... ## Abundance change summary is stored in object$res_change ... head(t1$res_change) ## Taxa Direction Change ## 1 k__Archaea|p__Thaumarchaeota S -&gt; RS -&gt; R ## 2 k__Bacteria|p__Acidobacteria S -&gt; RS -&gt; R Decrease ## 3 k__Bacteria|p__Actinobacteria S -&gt; RS -&gt; R ## 4 k__Bacteria|p__Armatimonadetes S -&gt; RS -&gt; R ## 5 k__Bacteria|p__Bacteroidetes S -&gt; RS -&gt; R ## 6 k__Bacteria|p__Chloroflexi S -&gt; RS -&gt; R # paired Wilcoxon test t1$cal_diff(method = &quot;wilcox&quot;, p_adjust_method = NULL) ## Raw differential test results are stored in object$res_diff_raw ... ## Differential test results have been added into object$res_change ... head(t1$res_change) ## Taxa Direction Change S -&gt; RS | Significance ## 1 k__Archaea|p__Thaumarchaeota S -&gt; RS -&gt; R *** ## 2 k__Bacteria|p__Acidobacteria S -&gt; RS -&gt; R Decrease *** ## 3 k__Bacteria|p__Actinobacteria S -&gt; RS -&gt; R ns ## 4 k__Bacteria|p__Armatimonadetes S -&gt; RS -&gt; R ** ## 5 k__Bacteria|p__Bacteroidetes S -&gt; RS -&gt; R * ## 6 k__Bacteria|p__Chloroflexi S -&gt; RS -&gt; R *** ## RS -&gt; R | Significance ## 1 *** ## 2 *** ## 3 ** ## 4 *** ## 5 ns ## 6 *** The upper operations can also be applied to different groups. # for each region without the consideration of plants t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), by_ID = NULL, by_group = &quot;Region&quot;, filter_thres = 0.001) head(t1$res_change) t1$cal_diff(method = &quot;wilcox&quot;, p_adjust_method = NULL) head(t1$res_change) # for each region with the consideration of plants t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), by_ID = &quot;Plant_ID&quot;, by_group = &quot;Region&quot;, filter_thres = 0.001) head(t1$res_change) # paired Wilcoxon test t1$cal_diff(method = &quot;wilcox&quot;, p_adjust_method = NULL) head(t1$res_change) t1$plot(point_size = 2) Then let’s show the linear mixed-effects model to analyze both the fixed and random effects. t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), by_ID = &quot;Plant_ID&quot;, by_group = &quot;Region&quot;) t1$cal_diff(method = &quot;lme&quot;, formula = &quot;Type + (1 + Type | Region)&quot;, measure = &quot;p__Proteobacteria&quot;) t1$res_diff For the relative abundance fitting, common parametric tests like anova is not a good way since the dependent variable is proportion data, which is not normally distributed or homoscedastic generally. Beta regression is suitable for the proportion data (bound at 0 and 1) (Douma, Weedon, and Warton 2019). This method is implemented based on the betareg package (Cribari-Neto and Zeileis 2010). # for all samples t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), by_ID = &quot;Plant_ID&quot;, by_group = NULL, filter_thres = 0.001) t1$cal_diff(method = &quot;betareg&quot;, formula = &quot;Type&quot;) t1$res_diff # for different regions t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), by_ID = &quot;Plant_ID&quot;, by_group = &quot;Region&quot;, filter_thres = 0.001) # measure can be assigned with a taxon t1$cal_diff(method = &quot;betareg&quot;, formula = &quot;Type&quot;, measure = &quot;p__Proteobacteria&quot;) t1$res_diff t1$plot(point_size = 2, select_taxon = &quot;p__Proteobacteria&quot;, plot_type = c(&quot;point&quot;, &quot;smooth&quot;), rect_fill = FALSE) When both the random effects and beta distribution fitting are considered in the model, generalized linear mixed model can be employed with the family function beta distribution function. t1 &lt;- taxaturn$new(wheat_16S, taxa_level = &quot;Phylum&quot;, group = &quot;Type&quot;, ordered_group = c(&quot;S&quot;, &quot;RS&quot;, &quot;R&quot;), filter_thres = 0.001) t1$cal_diff(method = &quot;glmm&quot;, formula = &quot;Type + (1|Region)&quot;, return_model = TRUE, group2num = TRUE) View(t1$res_diff) # extract the original models m1 &lt;- t1$res_model # without the random effect term t1$cal_diff(method = &quot;glmm&quot;, formula = &quot;Type&quot;, return_model = TRUE, group2num = TRUE) m2 &lt;- t1$res_model # use anova to compare models # names(m1)[1]: p__Proteobacteria anova(m1[[1]], m2[[1]]) References "],["other-examples-1.html", "Chapter 14 Other examples 14.1 Custom taxa order in bar plot 14.2 tidy_taxonomy function 14.3 Show the abundance of unknown taxa 14.4 Question of prefix in the taxa 14.5 The use of phylogenetic tree 14.6 Mantel test + Correlation heatmap 14.7 PCoA + boxplot 14.8 FAPROTAX + differential test 14.9 RDA results output", " Chapter 14 Other examples We’ve gathered a few tricks to make several issues easier to solve. We encourage users to contribute some unique, special or helpful examples inspired by the packages. 14.1 Custom taxa order in bar plot The flexibility of the package design can be reflected on many aspects. In some cases, it is possible to tactfully handle some particular challenges. For example, Dr.Jarrod contribute a cool answer to the question that how to use custom taxa and the order in bar plot by modifying the data inside the object. This is a discussion topic in microeco Discussions (https://github.com/ChiLiubio/microeco/discussions/45). 14.2 tidy_taxonomy function The taxonomic classification with standard prefix is very important for some analyses, e.g. taxonomic abundance plotting and biomarker finding. The tidy_taxonomy function in microeco package is designed to make the taxa having standard prefix. See those Issues with the detailed examples: (https://github.com/ChiLiubio/microeco/issues/32), (https://github.com/ChiLiubio/microeco/issues/22) and (https://github.com/ChiLiubio/microeco/issues/231). 14.3 Show the abundance of unknown taxa In the trans_abund class, the default operation can filter the unclassified taxa, such as those with ’g__’. Sometimes, these unknown taxa may be useful to represent uncultured species. Under the circumstance, the abundance of unknown taxa can be used to show the ratio of unknown taxa in the system. Please see the solution in this topic (https://github.com/ChiLiubio/microeco/issues/165). 14.4 Question of prefix in the taxa The prefix of taxa in taxonomic table may affect the following performance of plotting, e.g. text in legend. Please see those Issues (https://github.com/ChiLiubio/microeco/issues/32), (https://github.com/ChiLiubio/microeco/issues/7) and (https://github.com/ChiLiubio/microeco/issues/15). 14.5 The use of phylogenetic tree One of Issues referred to the basic use of phylogenetic tree in the microeco package (https://github.com/ChiLiubio/microeco/issues/33). 14.6 Mantel test + Correlation heatmap Sometimes, mantel test results and correlations of environmental factors are visualized together to deliver more information. In this example, we show how to extend the mantel test results from trans_env class with the package ggcor. Please install ggcor package according to the document (https://chiliubio.github.io/microeco_tutorial/intro.html#github-packages). # prepare data library(microeco) library(magrittr) data(dataset) data(env_data_16S) dataset$sample_table &lt;- data.frame(dataset$sample_table, env_data_16S[rownames(dataset$sample_table), ]) # extract two phyla to show the steps d1 &lt;- clone(dataset) d1$tax_table &lt;- d1$tax_table[d1$tax_table$Phylum == &quot;p__Proteobacteria&quot;, ] d1$tidy_dataset() d1$cal_betadiv() d2 &lt;- clone(dataset) d2$tax_table &lt;- d2$tax_table[d2$tax_table$Phylum == &quot;p__Bacteroidetes&quot;, ] d2$tidy_dataset() d2$cal_betadiv() # first perform mantel test t1 &lt;- trans_env$new(dataset = d1, env_cols = 8:15) t1$cal_mantel(use_measure = &quot;bray&quot;, partial_mantel = TRUE) t2 &lt;- trans_env$new(dataset = d2, env_cols = 8:15) t2$cal_mantel(use_measure = &quot;bray&quot;, partial_mantel = TRUE) # extract a part of the results x1 &lt;- data.frame(spec = &quot;Proteobacteria&quot;, t1$res_mantel) %&gt;% .[, c(1, 3, 6, 8)] x2 &lt;- data.frame(spec = &quot;Bacteroidetes&quot;, t2$res_mantel) %&gt;% .[, c(1, 3, 6, 8)] # rename columns colnames(x1) &lt;- colnames(x2) &lt;- c(&quot;spec&quot;, &quot;env&quot;, &quot;r&quot;, &quot;p.value&quot;) # generate interval data x1 %&lt;&gt;% dplyr::mutate(rd = cut(r, breaks = c(-Inf, 0.3, 0.6, Inf), labels = c(&quot;&lt; 0.3&quot;, &quot;0.3 - 0.6&quot;, &quot;&gt;= 0.6&quot;)), pd = cut(p.value, breaks = c(-Inf, 0.01, 0.05, Inf), labels = c(&quot;&lt; 0.01&quot;, &quot;0.01 - 0.05&quot;, &quot;&gt;= 0.05&quot;))) x2 %&lt;&gt;% dplyr::mutate(rd = cut(r, breaks = c(-Inf, 0.3, 0.6, Inf), labels = c(&quot;&lt; 0.3&quot;, &quot;0.3 - 0.6&quot;, &quot;&gt;= 0.6&quot;)), pd = cut(p.value, breaks = c(-Inf, 0.01, 0.05, Inf), labels = c(&quot;&lt; 0.01&quot;, &quot;0.01 - 0.05&quot;, &quot;&gt;= 0.05&quot;))) # cobine two tables plot_table &lt;- rbind(x1, x2) # install ggcor following the steps (https://chiliubio.github.io/microeco_tutorial/intro.html#github-packages) library(ggplot2) library(ggcor) set_scale() g1 &lt;- quickcor(t1$data_env, type = &quot;upper&quot;, cor.test = TRUE, show.diag = FALSE) + geom_square() + geom_mark(sig.thres = 0.05, markonly = TRUE, color = &quot;black&quot;, size = 6) + anno_link(aes(colour = pd, size = rd), data = plot_table) + scale_size_manual(values = c(0.5, 1.5, 3)) + scale_colour_manual(values = c(&quot;#D95F02&quot;, &quot;#1B9E77&quot;, &quot;#A2A2A288&quot;)) + guides(size = guide_legend(title = &quot;Mantel&#39;s r&quot;, override.aes = list(colour = &quot;grey35&quot;), order = 2), colour = guide_legend(title = &quot;Mantel&#39;s p&quot;, override.aes = list(size = 3), order = 1), fill = guide_colorbar(title = &quot;Pearson&#39;s r&quot;, order = 3)) g1 14.7 PCoA + boxplot In the sections involving trans_venn and trans_env classes, we mentioned some combination graphs generated based on the aplot package. Here, we continue to use the aplot and microeco packages to demonstrate how to add boxplots of coordinate scores to PCoA graphs. Similar combination graphs can be easily manipulated, so we no longer include this type of visualization in the plotting functions of ordination methods. Firstly, we use trans_beta class to compute PCoA, then perform differential test based on the cal_diff function in trans_env class. library(microeco) library(magrittr) library(ggplot2) library(aplot) theme_set(theme_bw()) data(dataset) # PCoA t1 &lt;- trans_beta$new(dataset = dataset, group = &quot;Group&quot;, measure = &quot;bray&quot;) t1$cal_ordination(ordination = &quot;PCoA&quot;) # extract the axis scores tmp &lt;- t1$res_ordination$scores # differential test with trans_env class t2 &lt;- trans_env$new(dataset = dataset, add_data = tmp[, 1:2]) # &#39;KW_dunn&#39; for non-parametric test t2$cal_diff(group = &quot;Group&quot;, method = &quot;anova&quot;) Then, employ the plotting functions in t1 and t2 objects for visualization. p1 &lt;- t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;, plot_type = c(&quot;point&quot;, &quot;ellipse&quot;)) # groups order in p2 is same with p1; use legend.position = &quot;none&quot; to remove redundant legend p2 &lt;- t2$plot_diff(measure = &quot;PCo1&quot;, add_sig = T) + theme_bw() + coord_flip() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank()) p3 &lt;- t2$plot_diff(measure = &quot;PCo2&quot;, add_sig = T) + theme_bw() + theme(legend.position = &quot;none&quot;, axis.title.y = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) # height of the upper figure and width of the right-hand figure are both 0.2-fold of the main figure g &lt;- p1 %&gt;% insert_top(p2, height = 0.2) %&gt;% insert_right(p3, width = 0.2) g At this point, we notice that the horizontal axis of the upper figure and the vertical axis of the right-hand figure do not correspond precisely with those of the main figure. Therefore, if we proceed with these graphs, the axis ticks of the upper and right-hand figures should be kept. If the user requires complete correspondence of the ticks, further control over the coordinate axes should be implemented. Here, we manually control the coordinate range. # use 1.4-fold of the scores as axis ranges x_lim &lt;- range(tmp[, 1]) * 1.4 y_lim &lt;- range(tmp[, 2]) * 1.4 # limit x and y axis without any extension p1 &lt;- p1 + scale_y_continuous(limits = y_lim, expand = c(0, 0)) + scale_x_continuous(limits = x_lim, expand = c(0, 0)) # limit x axis of upper figure (it&#39;s y axis when flipped) p2 &lt;- p2 + scale_y_continuous(limits = x_lim, expand = c(0, 0)) # limit y axis of right-hand figure p3 &lt;- p3 + scale_y_continuous(limits = y_lim, expand = c(0, 0)) g &lt;- p1 %&gt;% insert_top(p2, height = 0.2) %&gt;% insert_right(p3, width = 0.2) g Now, the ticks of the coordinate axes fully correspond, and we may selectively remove the ticks on the upper and right-hand figures. p2 &lt;- p2 + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) p3 &lt;- p3 + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) g &lt;- p1 %&gt;% insert_top(p2, height = 0.2) %&gt;% insert_right(p3, width = 0.2) g # save g to computer ggsave(&quot;test1.pdf&quot;, g, width = 7, height= 6) 14.8 FAPROTAX + differential test In the trans_func section, we showed an example of correlations between the abundances of OTUs with the traits from FAPROTAX database and environmental factors. Now, we go ahead and use trans_diff class to demonstrate the differential test of the abundances of OTUs with the traits across groups. library(microeco) data(dataset) t1 &lt;- trans_func$new(dataset) t1$cal_spe_func(prok_database = &quot;FAPROTAX&quot;) t1$cal_spe_func_perc(abundance_weighted = TRUE) # use list to prepare data tmp &lt;- list() # transpose res_spe_func_perc to be a data.frame like taxonomic abundance tmp$func &lt;- as.data.frame(t(t1$res_spe_func_perc), check.names = FALSE) # assign the list as taxa_abund in your microtable object dataset$taxa_abund &lt;- tmp # use trans_diff class to perform differential test t2 &lt;- trans_diff$new(dataset = dataset, method = &quot;anova&quot;, group = &quot;Group&quot;, taxa_level = &quot;all&quot;) t2$plot_diff_abund(add_sig = T) + ggplot2::ylab(&quot;Relative abundance (%)&quot;) 14.9 RDA results output In some analyses, it is often necessary to preserve intermediate files of various analysis results, and not all files are in the data.frame format. For example, in RDA analysis, the res_ordination_R2 generated by cal_ordination function is a numeric vector, and the res_ordination_envfit generated by the cal_ordination_envfit function is of envfit class. For those outputs, we can utilize the capture.output function to redirect the contents displayed in the dialogue box into a file. library(microeco) data(dataset) data(env_data_16S) t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11]) t1$cal_ordination(method = &quot;RDA&quot;, taxa_level = &quot;Genus&quot;) # get the significance of the terms t1$cal_ordination_anova() # fit factors onto the ordination to get R2 for each factor t1$cal_ordination_envfit() t1$trans_ordination(adjust_arrow_length = TRUE) g1 &lt;- t1$plot_ordination(plot_color = &quot;Group&quot;, plot_shape = &quot;Group&quot;) ggplot2::ggsave(&quot;RDA.pdf&quot;, g1, width = 8, height = 6.5) # use capture.output to save output capture.output(t1$res_ordination_R2, file = &quot;RDA_R2.txt&quot;) capture.output(t1$res_ordination_envfit, file = &quot;RDA_envfit.txt&quot;) # save data.frame objects write.table(t1$res_ordination_terms, &quot;RDA_anova_termsig.txt&quot;, sep = &quot;\\t&quot;) write.table(t1$res_ordination_axis, &quot;RDA_anova_axissig.txt&quot;, sep = &quot;\\t&quot;) write.table(t1$res_ordination_trans$df_sites, &quot;RDA_axis_sample.txt&quot;, sep = &quot;\\t&quot;) write.table(t1$res_ordination_trans$df_arrows, &quot;RDA_axis_term.txt&quot;, sep = &quot;\\t&quot;) write.table(t1$res_ordination_trans$df_arrows_spe, &quot;RDA_axis_taxa.txt&quot;, sep = &quot;\\t&quot;) "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
